# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.serialization import Model


class MeasureDefinition(Model):
    """Represents a measure definition.

    :param kind: Possible values include: 'entity', 'attribute'
    :type kind: str or ~dynamics.customerinsights.api.models.enum
    :param is_scalar: Gets a value indicating whether the current measure is a
     scalar measure e doesn't have any dimensions
    :type is_scalar: bool
    :param linked_entities: Gets list of linked entities associated with the
     measure.
    :type linked_entities:
     list[~dynamics.customerinsights.api.models.MeasureLinkedEntity]
    :param variables: Gets list of variables (computed columns) for the
     measure.
    :type variables:
     list[~dynamics.customerinsights.api.models.MeasureVariable]
    :param filters:
    :type filters: ~dynamics.customerinsights.api.models.MeasureExpression
    :param filtering_criteria:
    :type filtering_criteria:
     ~dynamics.customerinsights.api.models.SegmentMembershipCriteria
    :param dimensions: Gets list of dimensions with the measure.
    :type dimensions:
     list[~dynamics.customerinsights.api.models.MeasureDimension]
    :param aggregates: Gets list of aggregates of the measure.
    :type aggregates:
     list[~dynamics.customerinsights.api.models.MeasureAggregate]
    :param is_profile: Gets a value indicating whether the current measure is
     a profile measure
    :type is_profile: bool
    :param measure_query_sql: Gets the user specified custom SQL query.
    :type measure_query_sql: str
    :param type: Possible values include: 'structured', 'manual'
    :type type: str or ~dynamics.customerinsights.api.models.enum
    :param is_manual_query_scalar: Gets the indicating whether the Business
     Measure is Scalar or not.
    :type is_manual_query_scalar: bool
    :param dependencies: Gets the list of measures that this measure depends
     on.
    :type dependencies:
     list[~dynamics.customerinsights.api.models.EntityDependency]
    """

    _attribute_map = {
        'kind': {'key': 'kind', 'type': 'str'},
        'is_scalar': {'key': 'isScalar', 'type': 'bool'},
        'linked_entities': {'key': 'linkedEntities', 'type': '[MeasureLinkedEntity]'},
        'variables': {'key': 'variables', 'type': '[MeasureVariable]'},
        'filters': {'key': 'filters', 'type': 'MeasureExpression'},
        'filtering_criteria': {'key': 'filteringCriteria', 'type': 'SegmentMembershipCriteria'},
        'dimensions': {'key': 'dimensions', 'type': '[MeasureDimension]'},
        'aggregates': {'key': 'aggregates', 'type': '[MeasureAggregate]'},
        'is_profile': {'key': 'isProfile', 'type': 'bool'},
        'measure_query_sql': {'key': 'measureQuerySql', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'is_manual_query_scalar': {'key': 'isManualQueryScalar', 'type': 'bool'},
        'dependencies': {'key': 'dependencies', 'type': '[EntityDependency]'},
    }

    def __init__(self, *, kind=None, is_scalar: bool=None, linked_entities=None, variables=None, filters=None, filtering_criteria=None, dimensions=None, aggregates=None, is_profile: bool=None, measure_query_sql: str=None, type=None, is_manual_query_scalar: bool=None, dependencies=None, **kwargs) -> None:
        super(MeasureDefinition, self).__init__(**kwargs)
        self.kind = kind
        self.is_scalar = is_scalar
        self.linked_entities = linked_entities
        self.variables = variables
        self.filters = filters
        self.filtering_criteria = filtering_criteria
        self.dimensions = dimensions
        self.aggregates = aggregates
        self.is_profile = is_profile
        self.measure_query_sql = measure_query_sql
        self.type = type
        self.is_manual_query_scalar = is_manual_query_scalar
        self.dependencies = dependencies
