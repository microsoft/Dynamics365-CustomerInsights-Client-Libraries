/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.dynamics.customerinsights.apiclient.implementation;

import com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights;
import com.microsoft.rest.ServiceClient;
import com.microsoft.rest.RestClient;
import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import com.google.common.reflect.TypeToken;
import com.microsoft.dynamics.customerinsights.apiclient.models.AcceptedResult;
import com.microsoft.dynamics.customerinsights.apiclient.models.ActivateSegmentHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.ApiError;
import com.microsoft.dynamics.customerinsights.apiclient.models.ApiErrorResult;
import com.microsoft.dynamics.customerinsights.apiclient.models.AttributeDataProfile;
import com.microsoft.dynamics.customerinsights.apiclient.models.CancelAWorkflowJobHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.CopyAnInstanceHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.CreateAMeasureHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.CreateAnEntityHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.CreateAnInstanceHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.CreateARelationshipHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.CreateASegmentHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.CreatedResult;
import com.microsoft.dynamics.customerinsights.apiclient.models.CreateWorkflowRefreshScheduleHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DataSourceInfo;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeactivateSegmentHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeleteADataSourceHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeleteAMeasureHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeleteAnInstanceHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeleteARelationshipHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeletesARoleAssignmentHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeleteSegmentHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.DeletionResponse;
import com.microsoft.dynamics.customerinsights.apiclient.models.EntityDataProfile;
import com.microsoft.dynamics.customerinsights.apiclient.models.EntitySize;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAListOfMeasuresMetadataHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllDataSourcesHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllEntityMetadataHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllInstancesHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllInstancesInBatchesByInstanceidsHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllRelationshipsHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllRoleAssignmentsHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllRoleDefinitionsHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAllSegmentsHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAnAttributeProfileHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAnEntityProfileHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetARelationshipHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetAWorkflowJobInformationHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetCurrentUserRoleHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetDataSourceHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetEntitiesWithODataPathHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetEntityMetadataHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetEntitySizeHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetInstanceMetadataHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetKeyRingHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetListOfRecentWorkflowJobsHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetListOfWorkflowTaskInformationHistoryHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetMetadataForAMeasureHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetProfileStoreStateHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetSearchConfigurationHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetSupportedTimezonesHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetWorkflowSchedulesHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GetWorkflowStatusHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.GraphJobInfo;
import com.microsoft.dynamics.customerinsights.apiclient.models.GraphNodeInfo;
import com.microsoft.dynamics.customerinsights.apiclient.models.GraphTaskInfo;
import com.microsoft.dynamics.customerinsights.apiclient.models.IC360EntityModel;
import com.microsoft.dynamics.customerinsights.apiclient.models.IEntityMetadata;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstanceInfo;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstanceMetadata;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstancesCopyPostRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstanceSearchConfiguration;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstancesInstanceIdManageMeasuresMeasureNamePutRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstancesInstanceIdManageMeasuresPostRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstancesInstanceIdManageRelationshipsPostRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstancesInstanceIdManageRelationshipsRelationshipNamePutRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstancesInstanceIdManageSearchPutRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstancesInstanceIdManageSegmentsPostRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstancesInstanceIdManageSegmentsSegmentNamePutRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstancesInstanceIdRbacPrincipalsPrincipalIdAssignmentPutRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstancesInstanceIdV2PatchRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstancesInstanceIdWorkflowsWorkflowNameJobsPostRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstancesInstanceIdWorkflowsWorkflowNameSchedulesPostRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.InstancesV2PostRequest;
import com.microsoft.dynamics.customerinsights.apiclient.models.KeyRingResponse;
import com.microsoft.dynamics.customerinsights.apiclient.models.MeasureMetadata;
import com.microsoft.dynamics.customerinsights.apiclient.models.NoContentResult;
import com.microsoft.dynamics.customerinsights.apiclient.models.ODataEntityPayload;
import com.microsoft.dynamics.customerinsights.apiclient.models.ODataError;
import com.microsoft.dynamics.customerinsights.apiclient.models.OkResult;
import com.microsoft.dynamics.customerinsights.apiclient.models.ParsingError;
import com.microsoft.dynamics.customerinsights.apiclient.models.ProfileStoreStateInfo;
import com.microsoft.dynamics.customerinsights.apiclient.models.RelationshipMetadata;
import com.microsoft.dynamics.customerinsights.apiclient.models.ResetAnInstanceHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.RoleAssignment;
import com.microsoft.dynamics.customerinsights.apiclient.models.RoleDefinition;
import com.microsoft.dynamics.customerinsights.apiclient.models.SegmentMetadata;
import com.microsoft.dynamics.customerinsights.apiclient.models.SubmitAWorkflowJobHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.TimezoneDetail;
import com.microsoft.dynamics.customerinsights.apiclient.models.UpdateAMeasureHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.UpdateAnEntityHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.UpdateAnInstanceHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.UpdateARelationshipHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.UpdateARoleAssignmentHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.UpdateASegmentHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.UpdateSearchConfigurationHeaders;
import com.microsoft.dynamics.customerinsights.apiclient.models.WorkflowRefreshSchedule;
import com.microsoft.rest.CollectionFormat;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import java.util.List;
import java.util.UUID;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.HTTP;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * Initializes a new instance of the CustomerInsights class.
 */
public class CustomerInsightsImpl extends ServiceClient implements CustomerInsights {
    /**
     * The Retrofit service to perform REST calls.
     */
    private CustomerInsightsService service;

    /**
     * Initializes an instance of CustomerInsights client.
     */
    public CustomerInsightsImpl() {
        this("https://api.ci.ai.dynamics.com/v1");
    }

    /**
     * Initializes an instance of CustomerInsights client.
     *
     * @param baseUrl the base URL of the host
     */
    public CustomerInsightsImpl(String baseUrl) {
        super(baseUrl);
        initialize();
    }

    /**
     * Initializes an instance of CustomerInsights client.
     *
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public CustomerInsightsImpl(OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        this("https://api.ci.ai.dynamics.com/v1", clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of CustomerInsights client.
     *
     * @param baseUrl the base URL of the host
     * @param clientBuilder the builder for building an OkHttp client, bundled with user configurations
     * @param restBuilder the builder for building an Retrofit client, bundled with user configurations
     */
    public CustomerInsightsImpl(String baseUrl, OkHttpClient.Builder clientBuilder, Retrofit.Builder restBuilder) {
        super(baseUrl, clientBuilder, restBuilder);
        initialize();
    }

    /**
     * Initializes an instance of CustomerInsights client.
     *
     * @param restClient the REST client containing pre-configured settings
     */
    public CustomerInsightsImpl(RestClient restClient) {
        super(restClient);
        initialize();
    }

    private void initialize() {
        initializeService();
    }

    private void initializeService() {
        service = retrofit().create(CustomerInsightsService.class);
    }

    /**
     * The interface defining all the services for CustomerInsights to be
     * used by Retrofit to perform actually REST calls.
     */
    interface CustomerInsightsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAnAttributeProfile" })
        @GET("instances/{instanceId}/dataprofile/{qualifiedEntityName}/{attributeName}")
        Observable<Response<ResponseBody>> getAnAttributeProfile(@Path("instanceId") String instanceId, @Path("qualifiedEntityName") String qualifiedEntityName, @Path("attributeName") String attributeName);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllDataSources" })
        @GET("instances/{instanceId}/manage/datasources")
        Observable<Response<ResponseBody>> getAllDataSources(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getDataSource" })
        @GET("instances/{instanceId}/manage/datasources/{dataSourceId}")
        Observable<Response<ResponseBody>> getDataSource(@Path("instanceId") String instanceId, @Path("dataSourceId") String dataSourceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights deleteADataSource" })
        @HTTP(path = "instances/{instanceId}/manage/datasources/{dataSourceId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteADataSource(@Path("instanceId") String instanceId, @Path("dataSourceId") String dataSourceId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights createAnEntity" })
        @POST("instances/{instanceId}/data/{entityName}")
        Observable<Response<ResponseBody>> createAnEntity(@Path("instanceId") String instanceId, @Path("entityName") String entityName, @Body String body, @Query("validUntil") String validUntil, @Query("caller") String caller);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights updateAnEntity" })
        @PATCH("instances/{instanceId}/data/{entityName}/{entityId}")
        Observable<Response<ResponseBody>> updateAnEntity(@Path("instanceId") String instanceId, @Path("entityName") String entityName, @Path("entityId") String entityId, @Body String body, @Query("validUntil") String validUntil, @Query("caller") String caller);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getEntitiesWithODataPath" })
        @GET("instances/{instanceId}/data/{relativePath}")
        Observable<Response<ResponseBody>> getEntitiesWithODataPath(@Path("instanceId") String instanceId, @Path("relativePath") String relativePath, @Query("forceSearch") Boolean forceSearch, @Query("proxy") Boolean proxy, @Query("$search") String search, @Query("$select") String select, @Query("$skip") String skip, @Query("$skiptoken") String skiptoken, @Query("$filter") String filter, @Query("$orderby") String orderby, @Query("$expand") String expand, @Query("$top") String top);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllEntityMetadata" })
        @GET("instances/{instanceId}/manage/entities")
        Observable<Response<ResponseBody>> getAllEntityMetadata(@Path("instanceId") String instanceId, @Query("attributesAnnotations") Boolean attributesAnnotations, @Query("includeQuarantined") Boolean includeQuarantined);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getEntityMetadata" })
        @GET("instances/{instanceId}/manage/entities/{entityName}")
        Observable<Response<ResponseBody>> getEntityMetadata(@Path("instanceId") String instanceId, @Path("entityName") String entityName, @Query("attributesAnnotations") Boolean attributesAnnotations);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getEntitySize" })
        @GET("instances/{instanceId}/manage/entities/{entityName}/entitysize")
        Observable<Response<ResponseBody>> getEntitySize(@Path("instanceId") String instanceId, @Path("entityName") String entityName);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights resetAnInstance" })
        @HTTP(path = "instances/{instanceId}/manage/reset", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> resetAnInstance(@Path("instanceId") String instanceId, @Query("instanceManagementOperationScope") String instanceManagementOperationScope);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllInstances" })
        @GET("instances")
        Observable<Response<ResponseBody>> getAllInstances();

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllInstancesInBatchesByInstanceids" })
        @POST("instances/batch")
        Observable<Response<ResponseBody>> getAllInstancesInBatchesByInstanceids(@Body List<UUID> body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getInstanceMetadata" })
        @GET("instances/{instanceId}")
        Observable<Response<ResponseBody>> getInstanceMetadata(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights deleteAnInstance" })
        @HTTP(path = "instances/{instanceId}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteAnInstance(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights createAnInstance" })
        @POST("instances/V2")
        Observable<Response<ResponseBody>> createAnInstance(@Body InstancesV2PostRequest body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights updateAnInstance" })
        @PATCH("instances/{instanceId}/V2")
        Observable<Response<ResponseBody>> updateAnInstance(@Path("instanceId") String instanceId, @Body InstancesInstanceIdV2PatchRequest body);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights copyAnInstance" })
        @POST("instances/copy")
        Observable<Response<ResponseBody>> copyAnInstance(@Body InstancesCopyPostRequest body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAListOfMeasuresMetadata" })
        @GET("instances/{instanceId}/manage/measures")
        Observable<Response<ResponseBody>> getAListOfMeasuresMetadata(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights createAMeasure" })
        @POST("instances/{instanceId}/manage/measures")
        Observable<Response<ResponseBody>> createAMeasure(@Path("instanceId") String instanceId, @Body InstancesInstanceIdManageMeasuresPostRequest body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getMetadataForAMeasure" })
        @GET("instances/{instanceId}/manage/measures/{measureName}")
        Observable<Response<ResponseBody>> getMetadataForAMeasure(@Path("instanceId") String instanceId, @Path("measureName") String measureName, @Query("includeHistoricStats") Boolean includeHistoricStats, @Query("historicStatsDays") Integer historicStatsDays);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights updateAMeasure" })
        @PUT("instances/{instanceId}/manage/measures/{measureName}")
        Observable<Response<ResponseBody>> updateAMeasure(@Path("instanceId") String instanceId, @Path("measureName") String measureName, @Body InstancesInstanceIdManageMeasuresMeasureNamePutRequest body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights deleteAMeasure" })
        @HTTP(path = "instances/{instanceId}/manage/measures/{measureName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteAMeasure(@Path("instanceId") String instanceId, @Path("measureName") String measureName);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getKeyRing" })
        @GET("instances/{instanceId}/profile/keyring")
        Observable<Response<ResponseBody>> getKeyRing(@Path("instanceId") String instanceId, @Query("dataSourceName") String dataSourceName, @Query("entityName") String entityName, @Query("key") String key);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getProfileStoreState" })
        @GET("instances/{instanceId}/profilestore/stateinfo")
        Observable<Response<ResponseBody>> getProfileStoreState(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllRoleDefinitions" })
        @GET("instances/{instanceId}/rbac/roles")
        Observable<Response<ResponseBody>> getAllRoleDefinitions(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getCurrentUserRole" })
        @GET("instances/{instanceId}/rbac/myrole")
        Observable<Response<ResponseBody>> getCurrentUserRole(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights updateARoleAssignment" })
        @PUT("instances/{instanceId}/rbac/principals/{principalId}/assignment")
        Observable<Response<ResponseBody>> updateARoleAssignment(@Path("instanceId") String instanceId, @Path("principalId") String principalId, @Body InstancesInstanceIdRbacPrincipalsPrincipalIdAssignmentPutRequest body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights deletesARoleAssignment" })
        @HTTP(path = "instances/{instanceId}/rbac/principals/{principalId}/assignment", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deletesARoleAssignment(@Path("instanceId") String instanceId, @Path("principalId") String principalId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllRoleAssignments" })
        @GET("instances/{instanceId}/rbac/assignments")
        Observable<Response<ResponseBody>> getAllRoleAssignments(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllRelationships" })
        @GET("instances/{instanceId}/manage/relationships")
        Observable<Response<ResponseBody>> getAllRelationships(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights createARelationship" })
        @POST("instances/{instanceId}/manage/relationships")
        Observable<Response<ResponseBody>> createARelationship(@Path("instanceId") String instanceId, @Body InstancesInstanceIdManageRelationshipsPostRequest body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getARelationship" })
        @GET("instances/{instanceId}/manage/relationships/{relationshipName}")
        Observable<Response<ResponseBody>> getARelationship(@Path("instanceId") String instanceId, @Path("relationshipName") String relationshipName);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights deleteARelationship" })
        @HTTP(path = "instances/{instanceId}/manage/relationships/{relationshipName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteARelationship(@Path("instanceId") String instanceId, @Path("relationshipName") String relationshipName);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights updateARelationship" })
        @PUT("instances/{instanceId}/manage/relationships/{relationshipName}")
        Observable<Response<ResponseBody>> updateARelationship(@Path("instanceId") String instanceId, @Path("relationshipName") String relationshipName, @Body InstancesInstanceIdManageRelationshipsRelationshipNamePutRequest body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getSearchConfiguration" })
        @GET("instances/{instanceId}/manage/search")
        Observable<Response<ResponseBody>> getSearchConfiguration(@Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights updateSearchConfiguration" })
        @PUT("instances/{instanceId}/manage/search")
        Observable<Response<ResponseBody>> updateSearchConfiguration(@Path("instanceId") String instanceId, @Body InstancesInstanceIdManageSearchPutRequest body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAllSegments" })
        @GET("instances/{instanceId}/manage/segments")
        Observable<Response<ResponseBody>> getAllSegments(@Path("instanceId") String instanceId, @Query("includeHistoricStats") Boolean includeHistoricStats, @Query("historicStatsDays") Integer historicStatsDays, @Query("numberOfSegments") Integer numberOfSegments);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights createASegment" })
        @POST("instances/{instanceId}/manage/segments")
        Observable<Response<ResponseBody>> createASegment(@Path("instanceId") String instanceId, @Body InstancesInstanceIdManageSegmentsPostRequest body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights activateSegment" })
        @PUT("instances/{instanceId}/manage/segments/{segmentName}/activate")
        Observable<Response<ResponseBody>> activateSegment(@Path("instanceId") String instanceId, @Path("segmentName") String segmentName);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights deactivateSegment" })
        @PUT("instances/{instanceId}/manage/segments/{segmentName}/deactivate")
        Observable<Response<ResponseBody>> deactivateSegment(@Path("instanceId") String instanceId, @Path("segmentName") String segmentName);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights updateASegment" })
        @PUT("instances/{instanceId}/manage/segments/{segmentName}")
        Observable<Response<ResponseBody>> updateASegment(@Path("instanceId") String instanceId, @Path("segmentName") String segmentName, @Body InstancesInstanceIdManageSegmentsSegmentNamePutRequest body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights deleteSegment" })
        @HTTP(path = "instances/{instanceId}/manage/segments/{segmentName}", method = "DELETE", hasBody = true)
        Observable<Response<ResponseBody>> deleteSegment(@Path("instanceId") String instanceId, @Path("segmentName") String segmentName);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAWorkflowJobInformation" })
        @GET("instances/{instanceId}/workflows/{workflowName}/jobs/{jobId}")
        Observable<Response<ResponseBody>> getAWorkflowJobInformation(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName, @Path("jobId") String jobId, @Query("includeTasks") Boolean includeTasks);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights cancelAWorkflowJob" })
        @POST("instances/{instanceId}/workflows/{workflowName}/jobs/{jobId}/cancel")
        Observable<Response<ResponseBody>> cancelAWorkflowJob(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName, @Path("jobId") String jobId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getListOfRecentWorkflowJobs" })
        @GET("instances/{instanceId}/workflows/{workflowName}/jobs")
        Observable<Response<ResponseBody>> getListOfRecentWorkflowJobs(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName, @Query("top") Integer top1, @Query("includeTasks") Boolean includeTasks);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights submitAWorkflowJob" })
        @POST("instances/{instanceId}/workflows/{workflowName}/jobs")
        Observable<Response<ResponseBody>> submitAWorkflowJob(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName, @Body InstancesInstanceIdWorkflowsWorkflowNameJobsPostRequest body, @Query("operationType") String operationType, @Query("identifiers") String identifiers, @Query("forceRunRequested") Boolean forceRunRequested);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getListOfWorkflowTaskInformationHistory" })
        @GET("instances/{instanceId}/workflows/{workflowName}/history")
        Observable<Response<ResponseBody>> getListOfWorkflowTaskInformationHistory(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName, @Query("top") Integer top1);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getWorkflowStatus" })
        @GET("instances/{instanceId}/workflows/{workflowName}/status")
        Observable<Response<ResponseBody>> getWorkflowStatus(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getSupportedTimezones" })
        @GET("instances/{instanceId}/workflows/{workflowName}/schedules/supportedTimezones")
        Observable<Response<ResponseBody>> getSupportedTimezones(@Path("workflowName") String workflowName, @Path("instanceId") String instanceId);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getWorkflowSchedules" })
        @GET("instances/{instanceId}/workflows/{workflowName}/schedules")
        Observable<Response<ResponseBody>> getWorkflowSchedules(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName);

        @Headers({ "Content-Type: application/json-patch+json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights createWorkflowRefreshSchedule" })
        @POST("instances/{instanceId}/workflows/{workflowName}/schedules")
        Observable<Response<ResponseBody>> createWorkflowRefreshSchedule(@Path("instanceId") String instanceId, @Path("workflowName") String workflowName, @Body InstancesInstanceIdWorkflowsWorkflowNameSchedulesPostRequest body);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.dynamics.customerinsights.apiclient.CustomerInsights getAnEntityProfile" })
        @GET("instances/{instanceId}/dataprofile/{qualifiedEntityName}")
        Observable<Response<ResponseBody>> getAnEntityProfile(@Path("instanceId") String instanceId, @Path("qualifiedEntityName") String qualifiedEntityName);

    }

    /**
     * GetAttributeProfile.
     * Gets the specific attribute profile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @param attributeName Attribute Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAnAttributeProfile(String instanceId, String qualifiedEntityName, String attributeName) {
        return getAnAttributeProfileWithServiceResponseAsync(instanceId, qualifiedEntityName, attributeName).toBlocking().single().body();
    }

    /**
     * GetAttributeProfile.
     * Gets the specific attribute profile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @param attributeName Attribute Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAnAttributeProfileAsync(String instanceId, String qualifiedEntityName, String attributeName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAnAttributeProfileWithServiceResponseAsync(instanceId, qualifiedEntityName, attributeName), serviceCallback);
    }

    /**
     * GetAttributeProfile.
     * Gets the specific attribute profile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @param attributeName Attribute Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAnAttributeProfileAsync(String instanceId, String qualifiedEntityName, String attributeName) {
        return getAnAttributeProfileWithServiceResponseAsync(instanceId, qualifiedEntityName, attributeName).map(new Func1<ServiceResponseWithHeaders<Object, GetAnAttributeProfileHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAnAttributeProfileHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetAttributeProfile.
     * Gets the specific attribute profile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @param attributeName Attribute Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAnAttributeProfileHeaders>> getAnAttributeProfileWithServiceResponseAsync(String instanceId, String qualifiedEntityName, String attributeName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (qualifiedEntityName == null) {
            throw new IllegalArgumentException("Parameter qualifiedEntityName is required and cannot be null.");
        }
        if (attributeName == null) {
            throw new IllegalArgumentException("Parameter attributeName is required and cannot be null.");
        }
        return service.getAnAttributeProfile(instanceId, qualifiedEntityName, attributeName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAnAttributeProfileHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAnAttributeProfileHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAnAttributeProfileHeaders> clientResponse = getAnAttributeProfileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAnAttributeProfileHeaders> getAnAttributeProfileDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<AttributeDataProfile>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAnAttributeProfileHeaders.class);
    }

    /**
     * GetAllDataSources.
     * Returns a collections of DataSourceInfo configured for the given Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id for which to fetch data source info.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllDataSources(String instanceId) {
        return getAllDataSourcesWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * GetAllDataSources.
     * Returns a collections of DataSourceInfo configured for the given Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id for which to fetch data source info.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllDataSourcesAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllDataSourcesWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * GetAllDataSources.
     * Returns a collections of DataSourceInfo configured for the given Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id for which to fetch data source info.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllDataSourcesAsync(String instanceId) {
        return getAllDataSourcesWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetAllDataSourcesHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllDataSourcesHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetAllDataSources.
     * Returns a collections of DataSourceInfo configured for the given Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id for which to fetch data source info.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllDataSourcesHeaders>> getAllDataSourcesWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getAllDataSources(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllDataSourcesHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllDataSourcesHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllDataSourcesHeaders> clientResponse = getAllDataSourcesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAllDataSourcesHeaders> getAllDataSourcesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<DataSourceInfo>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAllDataSourcesHeaders.class);
    }

    /**
     * GetDataSource.
     * Fetches a DataSourceInfo matching the dataSourceId configured for the Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id to fetch data source info for.
     * @param dataSourceId Format - uuid. The data source id to fetch info for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getDataSource(String instanceId, String dataSourceId) {
        return getDataSourceWithServiceResponseAsync(instanceId, dataSourceId).toBlocking().single().body();
    }

    /**
     * GetDataSource.
     * Fetches a DataSourceInfo matching the dataSourceId configured for the Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id to fetch data source info for.
     * @param dataSourceId Format - uuid. The data source id to fetch info for.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getDataSourceAsync(String instanceId, String dataSourceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getDataSourceWithServiceResponseAsync(instanceId, dataSourceId), serviceCallback);
    }

    /**
     * GetDataSource.
     * Fetches a DataSourceInfo matching the dataSourceId configured for the Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id to fetch data source info for.
     * @param dataSourceId Format - uuid. The data source id to fetch info for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getDataSourceAsync(String instanceId, String dataSourceId) {
        return getDataSourceWithServiceResponseAsync(instanceId, dataSourceId).map(new Func1<ServiceResponseWithHeaders<Object, GetDataSourceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetDataSourceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetDataSource.
     * Fetches a DataSourceInfo matching the dataSourceId configured for the Customer Insights instance.
     *
     * @param instanceId Format - uuid. The instance id to fetch data source info for.
     * @param dataSourceId Format - uuid. The data source id to fetch info for.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetDataSourceHeaders>> getDataSourceWithServiceResponseAsync(String instanceId, String dataSourceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (dataSourceId == null) {
            throw new IllegalArgumentException("Parameter dataSourceId is required and cannot be null.");
        }
        return service.getDataSource(instanceId, dataSourceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetDataSourceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetDataSourceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetDataSourceHeaders> clientResponse = getDataSourceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetDataSourceHeaders> getDataSourceDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DataSourceInfo>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetDataSourceHeaders.class);
    }

    /**
     * DeleteDataSource.
     * Deletes a data source from the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param dataSourceId Format - uuid. The data source id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteADataSource(String instanceId, String dataSourceId) {
        return deleteADataSourceWithServiceResponseAsync(instanceId, dataSourceId).toBlocking().single().body();
    }

    /**
     * DeleteDataSource.
     * Deletes a data source from the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param dataSourceId Format - uuid. The data source id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteADataSourceAsync(String instanceId, String dataSourceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteADataSourceWithServiceResponseAsync(instanceId, dataSourceId), serviceCallback);
    }

    /**
     * DeleteDataSource.
     * Deletes a data source from the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param dataSourceId Format - uuid. The data source id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteADataSourceAsync(String instanceId, String dataSourceId) {
        return deleteADataSourceWithServiceResponseAsync(instanceId, dataSourceId).map(new Func1<ServiceResponseWithHeaders<Object, DeleteADataSourceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DeleteADataSourceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * DeleteDataSource.
     * Deletes a data source from the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param dataSourceId Format - uuid. The data source id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DeleteADataSourceHeaders>> deleteADataSourceWithServiceResponseAsync(String instanceId, String dataSourceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (dataSourceId == null) {
            throw new IllegalArgumentException("Parameter dataSourceId is required and cannot be null.");
        }
        return service.deleteADataSource(instanceId, dataSourceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DeleteADataSourceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DeleteADataSourceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DeleteADataSourceHeaders> clientResponse = deleteADataSourceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DeleteADataSourceHeaders> deleteADataSourceDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<OkResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, DeleteADataSourceHeaders.class);
    }

    /**
     * CreateEntity (Preview).
     * Writes an entity instance into the store, g. an activity entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createAnEntity(String instanceId, String entityName) {
        return createAnEntityWithServiceResponseAsync(instanceId, entityName).toBlocking().single().body();
    }

    /**
     * CreateEntity (Preview).
     * Writes an entity instance into the store, g. an activity entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAnEntityAsync(String instanceId, String entityName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createAnEntityWithServiceResponseAsync(instanceId, entityName), serviceCallback);
    }

    /**
     * CreateEntity (Preview).
     * Writes an entity instance into the store, g. an activity entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAnEntityAsync(String instanceId, String entityName) {
        return createAnEntityWithServiceResponseAsync(instanceId, entityName).map(new Func1<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateAnEntityHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * CreateEntity (Preview).
     * Writes an entity instance into the store, g. an activity entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>> createAnEntityWithServiceResponseAsync(String instanceId, String entityName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        final String body = null;
        final String validUntil = null;
        final String caller = null;
        return service.createAnEntity(instanceId, entityName, body, validUntil, caller)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateAnEntityHeaders> clientResponse = createAnEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * CreateEntity (Preview).
     * Writes an entity instance into the store, g. an activity entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @param body JSON document representing the entity. The schema must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createAnEntity(String instanceId, String entityName, String body, String validUntil, String caller) {
        return createAnEntityWithServiceResponseAsync(instanceId, entityName, body, validUntil, caller).toBlocking().single().body();
    }

    /**
     * CreateEntity (Preview).
     * Writes an entity instance into the store, g. an activity entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @param body JSON document representing the entity. The schema must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAnEntityAsync(String instanceId, String entityName, String body, String validUntil, String caller, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createAnEntityWithServiceResponseAsync(instanceId, entityName, body, validUntil, caller), serviceCallback);
    }

    /**
     * CreateEntity (Preview).
     * Writes an entity instance into the store, g. an activity entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @param body JSON document representing the entity. The schema must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAnEntityAsync(String instanceId, String entityName, String body, String validUntil, String caller) {
        return createAnEntityWithServiceResponseAsync(instanceId, entityName, body, validUntil, caller).map(new Func1<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateAnEntityHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * CreateEntity (Preview).
     * Writes an entity instance into the store, g. an activity entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, consisting of 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
     * @param body JSON document representing the entity. The schema must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>> createAnEntityWithServiceResponseAsync(String instanceId, String entityName, String body, String validUntil, String caller) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        return service.createAnEntity(instanceId, entityName, body, validUntil, caller)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateAnEntityHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateAnEntityHeaders> clientResponse = createAnEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CreateAnEntityHeaders> createAnEntityDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<CreatedResult>() { }.getType())
                .register(202, new TypeToken<AcceptedResult>() { }.getType())
                .register(400, new TypeToken<ODataError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(409, new TypeToken<ODataError>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, CreateAnEntityHeaders.class);
    }

    /**
     * UpdateEntity (Preview).
     * Updates an entity instance in the store, g. Customer entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateAnEntity(String instanceId, String entityName, String entityId) {
        return updateAnEntityWithServiceResponseAsync(instanceId, entityName, entityId).toBlocking().single().body();
    }

    /**
     * UpdateEntity (Preview).
     * Updates an entity instance in the store, g. Customer entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAnEntityAsync(String instanceId, String entityName, String entityId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateAnEntityWithServiceResponseAsync(instanceId, entityName, entityId), serviceCallback);
    }

    /**
     * UpdateEntity (Preview).
     * Updates an entity instance in the store, g. Customer entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAnEntityAsync(String instanceId, String entityName, String entityId) {
        return updateAnEntityWithServiceResponseAsync(instanceId, entityName, entityId).map(new Func1<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateEntity (Preview).
     * Updates an entity instance in the store, g. Customer entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>> updateAnEntityWithServiceResponseAsync(String instanceId, String entityName, String entityId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        final String body = null;
        final String validUntil = null;
        final String caller = null;
        return service.updateAnEntity(instanceId, entityName, entityId, body, validUntil, caller)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders> clientResponse = updateAnEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * UpdateEntity (Preview).
     * Updates an entity instance in the store, g. Customer entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @param body JSON document with set of changes to apply on the entity. Each change must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateAnEntity(String instanceId, String entityName, String entityId, String body, String validUntil, String caller) {
        return updateAnEntityWithServiceResponseAsync(instanceId, entityName, entityId, body, validUntil, caller).toBlocking().single().body();
    }

    /**
     * UpdateEntity (Preview).
     * Updates an entity instance in the store, g. Customer entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @param body JSON document with set of changes to apply on the entity. Each change must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAnEntityAsync(String instanceId, String entityName, String entityId, String body, String validUntil, String caller, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateAnEntityWithServiceResponseAsync(instanceId, entityName, entityId, body, validUntil, caller), serviceCallback);
    }

    /**
     * UpdateEntity (Preview).
     * Updates an entity instance in the store, g. Customer entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @param body JSON document with set of changes to apply on the entity. Each change must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAnEntityAsync(String instanceId, String entityName, String entityId, String body, String validUntil, String caller) {
        return updateAnEntityWithServiceResponseAsync(instanceId, entityName, entityId, body, validUntil, caller).map(new Func1<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateEntity (Preview).
     * Updates an entity instance in the store, g. Customer entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance Id.
     * @param entityName Fully qualified entity name, e.g. 'Customer'.
     * @param entityId Id of the entity to update, e.g. 'CustomerId' of a Customer entity.
     * @param body JSON document with set of changes to apply on the entity. Each change must be consistent with the entity metadata. Use GET action of this resource to obtain an example.
     * @param validUntil Format - date-time (as date-time in RFC3339). Expiration time of the change; ISO8601; optional. The value can be maximum 30 days in the future. If the datasource for this entity doesn't contain the changes after this time, the update disappears from the store.
     * @param caller String to identify the caller; optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>> updateAnEntityWithServiceResponseAsync(String instanceId, String entityName, String entityId, String body, String validUntil, String caller) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (entityId == null) {
            throw new IllegalArgumentException("Parameter entityId is required and cannot be null.");
        }
        return service.updateAnEntity(instanceId, entityName, entityId, body, validUntil, caller)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders> clientResponse = updateAnEntityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateAnEntityHeaders> updateAnEntityDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(204, new TypeToken<NoContentResult>() { }.getType())
                .register(400, new TypeToken<ODataError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ODataError>() { }.getType())
                .register(429, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, UpdateAnEntityHeaders.class);
    }

    /**
     * GetEntityByODataQuery.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param relativePath Relative OData path. See https://www.odata.org/getting-started/basic-tutorial/ for info.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getEntitiesWithODataPath(String instanceId, String relativePath) {
        return getEntitiesWithODataPathWithServiceResponseAsync(instanceId, relativePath).toBlocking().single().body();
    }

    /**
     * GetEntityByODataQuery.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param relativePath Relative OData path. See https://www.odata.org/getting-started/basic-tutorial/ for info.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getEntitiesWithODataPathAsync(String instanceId, String relativePath, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getEntitiesWithODataPathWithServiceResponseAsync(instanceId, relativePath), serviceCallback);
    }

    /**
     * GetEntityByODataQuery.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param relativePath Relative OData path. See https://www.odata.org/getting-started/basic-tutorial/ for info.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getEntitiesWithODataPathAsync(String instanceId, String relativePath) {
        return getEntitiesWithODataPathWithServiceResponseAsync(instanceId, relativePath).map(new Func1<ServiceResponseWithHeaders<Object, GetEntitiesWithODataPathHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetEntitiesWithODataPathHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetEntityByODataQuery.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param relativePath Relative OData path. See https://www.odata.org/getting-started/basic-tutorial/ for info.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetEntitiesWithODataPathHeaders>> getEntitiesWithODataPathWithServiceResponseAsync(String instanceId, String relativePath) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (relativePath == null) {
            throw new IllegalArgumentException("Parameter relativePath is required and cannot be null.");
        }
        final Boolean forceSearch = null;
        final Boolean proxy = null;
        final String search = null;
        final String select = null;
        final String skip = null;
        final String skiptoken = null;
        final String filter = null;
        final String orderby = null;
        final String expand = null;
        final String top = null;
        return service.getEntitiesWithODataPath(instanceId, relativePath, forceSearch, proxy, search, select, skip, skiptoken, filter, orderby, expand, top)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetEntitiesWithODataPathHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetEntitiesWithODataPathHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetEntitiesWithODataPathHeaders> clientResponse = getEntitiesWithODataPathDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * GetEntityByODataQuery.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param relativePath Relative OData path. See https://www.odata.org/getting-started/basic-tutorial/ for info.
     * @param forceSearch Whether force use search to support the query.
     * @param proxy Whether or not we are requesting data by proxy.
     * @param search Search OData parameter.
     * @param select Select OData parameter.
     * @param skip Skip OData parameter.
     * @param skiptoken SkipToken OData parameter.
     * @param filter Filter OData parameter.
     * @param orderby OrderBy OData parameter.
     * @param expand Expand OData parameter.
     * @param top Top OData parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getEntitiesWithODataPath(String instanceId, String relativePath, Boolean forceSearch, Boolean proxy, String search, String select, String skip, String skiptoken, String filter, String orderby, String expand, String top) {
        return getEntitiesWithODataPathWithServiceResponseAsync(instanceId, relativePath, forceSearch, proxy, search, select, skip, skiptoken, filter, orderby, expand, top).toBlocking().single().body();
    }

    /**
     * GetEntityByODataQuery.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param relativePath Relative OData path. See https://www.odata.org/getting-started/basic-tutorial/ for info.
     * @param forceSearch Whether force use search to support the query.
     * @param proxy Whether or not we are requesting data by proxy.
     * @param search Search OData parameter.
     * @param select Select OData parameter.
     * @param skip Skip OData parameter.
     * @param skiptoken SkipToken OData parameter.
     * @param filter Filter OData parameter.
     * @param orderby OrderBy OData parameter.
     * @param expand Expand OData parameter.
     * @param top Top OData parameter.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getEntitiesWithODataPathAsync(String instanceId, String relativePath, Boolean forceSearch, Boolean proxy, String search, String select, String skip, String skiptoken, String filter, String orderby, String expand, String top, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getEntitiesWithODataPathWithServiceResponseAsync(instanceId, relativePath, forceSearch, proxy, search, select, skip, skiptoken, filter, orderby, expand, top), serviceCallback);
    }

    /**
     * GetEntityByODataQuery.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param relativePath Relative OData path. See https://www.odata.org/getting-started/basic-tutorial/ for info.
     * @param forceSearch Whether force use search to support the query.
     * @param proxy Whether or not we are requesting data by proxy.
     * @param search Search OData parameter.
     * @param select Select OData parameter.
     * @param skip Skip OData parameter.
     * @param skiptoken SkipToken OData parameter.
     * @param filter Filter OData parameter.
     * @param orderby OrderBy OData parameter.
     * @param expand Expand OData parameter.
     * @param top Top OData parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getEntitiesWithODataPathAsync(String instanceId, String relativePath, Boolean forceSearch, Boolean proxy, String search, String select, String skip, String skiptoken, String filter, String orderby, String expand, String top) {
        return getEntitiesWithODataPathWithServiceResponseAsync(instanceId, relativePath, forceSearch, proxy, search, select, skip, skiptoken, filter, orderby, expand, top).map(new Func1<ServiceResponseWithHeaders<Object, GetEntitiesWithODataPathHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetEntitiesWithODataPathHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetEntityByODataQuery.
     * Submits an OData request to the service.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param relativePath Relative OData path. See https://www.odata.org/getting-started/basic-tutorial/ for info.
     * @param forceSearch Whether force use search to support the query.
     * @param proxy Whether or not we are requesting data by proxy.
     * @param search Search OData parameter.
     * @param select Select OData parameter.
     * @param skip Skip OData parameter.
     * @param skiptoken SkipToken OData parameter.
     * @param filter Filter OData parameter.
     * @param orderby OrderBy OData parameter.
     * @param expand Expand OData parameter.
     * @param top Top OData parameter.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetEntitiesWithODataPathHeaders>> getEntitiesWithODataPathWithServiceResponseAsync(String instanceId, String relativePath, Boolean forceSearch, Boolean proxy, String search, String select, String skip, String skiptoken, String filter, String orderby, String expand, String top) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (relativePath == null) {
            throw new IllegalArgumentException("Parameter relativePath is required and cannot be null.");
        }
        return service.getEntitiesWithODataPath(instanceId, relativePath, forceSearch, proxy, search, select, skip, skiptoken, filter, orderby, expand, top)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetEntitiesWithODataPathHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetEntitiesWithODataPathHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetEntitiesWithODataPathHeaders> clientResponse = getEntitiesWithODataPathDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetEntitiesWithODataPathHeaders> getEntitiesWithODataPathDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ODataEntityPayload>() { }.getType())
                .register(400, new TypeToken<ODataError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ODataError>() { }.getType())
                .register(406, new TypeToken<ODataError>() { }.getType())
                .register(500, new TypeToken<ODataError>() { }.getType())
                .register(503, new TypeToken<ODataError>() { }.getType())
                .buildWithHeaders(response, GetEntitiesWithODataPathHeaders.class);
    }

    /**
     * GetAllEntitiesMetadata.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllEntityMetadata(String instanceId) {
        return getAllEntityMetadataWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * GetAllEntitiesMetadata.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllEntityMetadataAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllEntityMetadataWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * GetAllEntitiesMetadata.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllEntityMetadataAsync(String instanceId) {
        return getAllEntityMetadataWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetAllEntitiesMetadata.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>> getAllEntityMetadataWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final Boolean attributesAnnotations = null;
        final Boolean includeQuarantined = null;
        return service.getAllEntityMetadata(instanceId, attributesAnnotations, includeQuarantined)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders> clientResponse = getAllEntityMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * GetAllEntitiesMetadata.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @param includeQuarantined Indicates if quarantined entities should be included in the output entity model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllEntityMetadata(String instanceId, Boolean attributesAnnotations, Boolean includeQuarantined) {
        return getAllEntityMetadataWithServiceResponseAsync(instanceId, attributesAnnotations, includeQuarantined).toBlocking().single().body();
    }

    /**
     * GetAllEntitiesMetadata.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @param includeQuarantined Indicates if quarantined entities should be included in the output entity model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllEntityMetadataAsync(String instanceId, Boolean attributesAnnotations, Boolean includeQuarantined, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllEntityMetadataWithServiceResponseAsync(instanceId, attributesAnnotations, includeQuarantined), serviceCallback);
    }

    /**
     * GetAllEntitiesMetadata.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @param includeQuarantined Indicates if quarantined entities should be included in the output entity model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllEntityMetadataAsync(String instanceId, Boolean attributesAnnotations, Boolean includeQuarantined) {
        return getAllEntityMetadataWithServiceResponseAsync(instanceId, attributesAnnotations, includeQuarantined).map(new Func1<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetAllEntitiesMetadata.
     * Retrieves the flattened entity model for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @param includeQuarantined Indicates if quarantined entities should be included in the output entity model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>> getAllEntityMetadataWithServiceResponseAsync(String instanceId, Boolean attributesAnnotations, Boolean includeQuarantined) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getAllEntityMetadata(instanceId, attributesAnnotations, includeQuarantined)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders> clientResponse = getAllEntityMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAllEntityMetadataHeaders> getAllEntityMetadataDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IC360EntityModel>() { }.getType())
                .register(400, new TypeToken<ApiError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, GetAllEntityMetadataHeaders.class);
    }

    /**
     * GetEntityMetadata.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getEntityMetadata(String instanceId, String entityName) {
        return getEntityMetadataWithServiceResponseAsync(instanceId, entityName).toBlocking().single().body();
    }

    /**
     * GetEntityMetadata.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getEntityMetadataAsync(String instanceId, String entityName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getEntityMetadataWithServiceResponseAsync(instanceId, entityName), serviceCallback);
    }

    /**
     * GetEntityMetadata.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getEntityMetadataAsync(String instanceId, String entityName) {
        return getEntityMetadataWithServiceResponseAsync(instanceId, entityName).map(new Func1<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetEntityMetadata.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>> getEntityMetadataWithServiceResponseAsync(String instanceId, String entityName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        final Boolean attributesAnnotations = null;
        return service.getEntityMetadata(instanceId, entityName, attributesAnnotations)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders> clientResponse = getEntityMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * GetEntityMetadata.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getEntityMetadata(String instanceId, String entityName, Boolean attributesAnnotations) {
        return getEntityMetadataWithServiceResponseAsync(instanceId, entityName, attributesAnnotations).toBlocking().single().body();
    }

    /**
     * GetEntityMetadata.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getEntityMetadataAsync(String instanceId, String entityName, Boolean attributesAnnotations, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getEntityMetadataWithServiceResponseAsync(instanceId, entityName, attributesAnnotations), serviceCallback);
    }

    /**
     * GetEntityMetadata.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getEntityMetadataAsync(String instanceId, String entityName, Boolean attributesAnnotations) {
        return getEntityMetadataWithServiceResponseAsync(instanceId, entityName, attributesAnnotations).map(new Func1<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetEntityMetadata.
     * Retrieves the entity metadata for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @param attributesAnnotations Indicates if extra annotations like 'ReadOnly' or 'Mandatory' should be included.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>> getEntityMetadataWithServiceResponseAsync(String instanceId, String entityName, Boolean attributesAnnotations) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        return service.getEntityMetadata(instanceId, entityName, attributesAnnotations)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders> clientResponse = getEntityMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetEntityMetadataHeaders> getEntityMetadataDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<IEntityMetadata>() { }.getType())
                .register(400, new TypeToken<ApiError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, GetEntityMetadataHeaders.class);
    }

    /**
     * GetEntitySize.
     * Retrieves the entity size for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getEntitySize(String instanceId, String entityName) {
        return getEntitySizeWithServiceResponseAsync(instanceId, entityName).toBlocking().single().body();
    }

    /**
     * GetEntitySize.
     * Retrieves the entity size for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getEntitySizeAsync(String instanceId, String entityName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getEntitySizeWithServiceResponseAsync(instanceId, entityName), serviceCallback);
    }

    /**
     * GetEntitySize.
     * Retrieves the entity size for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getEntitySizeAsync(String instanceId, String entityName) {
        return getEntitySizeWithServiceResponseAsync(instanceId, entityName).map(new Func1<ServiceResponseWithHeaders<Object, GetEntitySizeHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetEntitySizeHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetEntitySize.
     * Retrieves the entity size for the provided instanceId and entityName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param entityName Entity name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetEntitySizeHeaders>> getEntitySizeWithServiceResponseAsync(String instanceId, String entityName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        return service.getEntitySize(instanceId, entityName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetEntitySizeHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetEntitySizeHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetEntitySizeHeaders> clientResponse = getEntitySizeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetEntitySizeHeaders> getEntitySizeDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EntitySize>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<ApiError>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, GetEntitySizeHeaders.class);
    }

    /**
     * ResetInstance.
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope.
     *
     * @param instanceId Format - uuid. The instance Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object resetAnInstance(String instanceId) {
        return resetAnInstanceWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * ResetInstance.
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope.
     *
     * @param instanceId Format - uuid. The instance Id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> resetAnInstanceAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(resetAnInstanceWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * ResetInstance.
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope.
     *
     * @param instanceId Format - uuid. The instance Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> resetAnInstanceAsync(String instanceId) {
        return resetAnInstanceWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ResetInstance.
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope.
     *
     * @param instanceId Format - uuid. The instance Id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>> resetAnInstanceWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final String instanceManagementOperationScope = null;
        return service.resetAnInstance(instanceId, instanceManagementOperationScope)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders> clientResponse = resetAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * ResetInstance.
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope.
     *
     * @param instanceId Format - uuid. The instance Id.
     * @param instanceManagementOperationScope The management operation scope for reset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object resetAnInstance(String instanceId, String instanceManagementOperationScope) {
        return resetAnInstanceWithServiceResponseAsync(instanceId, instanceManagementOperationScope).toBlocking().single().body();
    }

    /**
     * ResetInstance.
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope.
     *
     * @param instanceId Format - uuid. The instance Id.
     * @param instanceManagementOperationScope The management operation scope for reset.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> resetAnInstanceAsync(String instanceId, String instanceManagementOperationScope, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(resetAnInstanceWithServiceResponseAsync(instanceId, instanceManagementOperationScope), serviceCallback);
    }

    /**
     * ResetInstance.
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope.
     *
     * @param instanceId Format - uuid. The instance Id.
     * @param instanceManagementOperationScope The management operation scope for reset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> resetAnInstanceAsync(String instanceId, String instanceManagementOperationScope) {
        return resetAnInstanceWithServiceResponseAsync(instanceId, instanceManagementOperationScope).map(new Func1<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ResetInstance.
     * Reset scopes in the given instance. Provide optional management operation scope to reset only that scope.
     *
     * @param instanceId Format - uuid. The instance Id.
     * @param instanceManagementOperationScope The management operation scope for reset.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>> resetAnInstanceWithServiceResponseAsync(String instanceId, String instanceManagementOperationScope) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.resetAnInstance(instanceId, instanceManagementOperationScope)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders> clientResponse = resetAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, ResetAnInstanceHeaders> resetAnInstanceDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Boolean>() { }.getType())
                .register(400, new TypeToken<ApiErrorResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<ApiErrorResult>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, ResetAnInstanceHeaders.class);
    }

    /**
     * ListAllInstances.
     * Retrieves all instances of the current user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllInstances() {
        return getAllInstancesWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * ListAllInstances.
     * Retrieves all instances of the current user.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllInstancesAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllInstancesWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * ListAllInstances.
     * Retrieves all instances of the current user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllInstancesAsync() {
        return getAllInstancesWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetAllInstancesHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllInstancesHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ListAllInstances.
     * Retrieves all instances of the current user.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllInstancesHeaders>> getAllInstancesWithServiceResponseAsync() {
        return service.getAllInstances()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllInstancesHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllInstancesHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllInstancesHeaders> clientResponse = getAllInstancesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAllInstancesHeaders> getAllInstancesDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<InstanceInfo>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAllInstancesHeaders.class);
    }

    /**
     * ListInstancesByInstanceIds.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllInstancesInBatchesByInstanceids() {
        return getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * ListInstancesByInstanceIds.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllInstancesInBatchesByInstanceidsAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * ListInstancesByInstanceIds.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllInstancesInBatchesByInstanceidsAsync() {
        return getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ListInstancesByInstanceIds.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>> getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync() {
        final List<UUID> body = null;
        return service.getAllInstancesInBatchesByInstanceids(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders> clientResponse = getAllInstancesInBatchesByInstanceidsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * ListInstancesByInstanceIds.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @param body Instance ids of instances to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllInstancesInBatchesByInstanceids(List<UUID> body) {
        return getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * ListInstancesByInstanceIds.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @param body Instance ids of instances to get.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllInstancesInBatchesByInstanceidsAsync(List<UUID> body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * ListInstancesByInstanceIds.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @param body Instance ids of instances to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllInstancesInBatchesByInstanceidsAsync(List<UUID> body) {
        return getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync(body).map(new Func1<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ListInstancesByInstanceIds.
     * Retrieves instances based on instance ids, it can only accept batch of instances.
     *
     * @param body Instance ids of instances to get.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>> getAllInstancesInBatchesByInstanceidsWithServiceResponseAsync(List<UUID> body) {
        Validator.validate(body);
        return service.getAllInstancesInBatchesByInstanceids(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders> clientResponse = getAllInstancesInBatchesByInstanceidsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAllInstancesInBatchesByInstanceidsHeaders> getAllInstancesInBatchesByInstanceidsDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<InstanceInfo>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAllInstancesInBatchesByInstanceidsHeaders.class);
    }

    /**
     * GetInstance.
     * Retrieves metadata for a Customer Insights instance based on its instanceId.
     *
     * @param instanceId Format - uuid. Unique id for the Customer Insights instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getInstanceMetadata(String instanceId) {
        return getInstanceMetadataWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * GetInstance.
     * Retrieves metadata for a Customer Insights instance based on its instanceId.
     *
     * @param instanceId Format - uuid. Unique id for the Customer Insights instance.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getInstanceMetadataAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getInstanceMetadataWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * GetInstance.
     * Retrieves metadata for a Customer Insights instance based on its instanceId.
     *
     * @param instanceId Format - uuid. Unique id for the Customer Insights instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getInstanceMetadataAsync(String instanceId) {
        return getInstanceMetadataWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetInstanceMetadataHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetInstanceMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetInstance.
     * Retrieves metadata for a Customer Insights instance based on its instanceId.
     *
     * @param instanceId Format - uuid. Unique id for the Customer Insights instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetInstanceMetadataHeaders>> getInstanceMetadataWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getInstanceMetadata(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetInstanceMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetInstanceMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetInstanceMetadataHeaders> clientResponse = getInstanceMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetInstanceMetadataHeaders> getInstanceMetadataDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<InstanceMetadata>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetInstanceMetadataHeaders.class);
    }

    /**
     * DeleteInstance.
     * Delete an instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteAnInstance(String instanceId) {
        return deleteAnInstanceWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * DeleteInstance.
     * Delete an instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteAnInstanceAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteAnInstanceWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * DeleteInstance.
     * Delete an instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteAnInstanceAsync(String instanceId) {
        return deleteAnInstanceWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, DeleteAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DeleteAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * DeleteInstance.
     * Delete an instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DeleteAnInstanceHeaders>> deleteAnInstanceWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.deleteAnInstance(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DeleteAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DeleteAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DeleteAnInstanceHeaders> clientResponse = deleteAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DeleteAnInstanceHeaders> deleteAnInstanceDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Boolean>() { }.getType())
                .register(400, new TypeToken<ApiErrorResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<ApiErrorResult>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, DeleteAnInstanceHeaders.class);
    }

    /**
     * CreateInstance.
     * Creates a new instance.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createAnInstance() {
        return createAnInstanceWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * CreateInstance.
     * Creates a new instance.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAnInstanceAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createAnInstanceWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * CreateInstance.
     * Creates a new instance.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAnInstanceAsync() {
        return createAnInstanceWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * CreateInstance.
     * Creates a new instance.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>> createAnInstanceWithServiceResponseAsync() {
        final InstancesV2PostRequest body = null;
        return service.createAnInstance(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders> clientResponse = createAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * CreateInstance.
     * Creates a new instance.
     *
     * @param body The instance creation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createAnInstance(InstancesV2PostRequest body) {
        return createAnInstanceWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * CreateInstance.
     * Creates a new instance.
     *
     * @param body The instance creation request.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAnInstanceAsync(InstancesV2PostRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createAnInstanceWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * CreateInstance.
     * Creates a new instance.
     *
     * @param body The instance creation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAnInstanceAsync(InstancesV2PostRequest body) {
        return createAnInstanceWithServiceResponseAsync(body).map(new Func1<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * CreateInstance.
     * Creates a new instance.
     *
     * @param body The instance creation request.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>> createAnInstanceWithServiceResponseAsync(InstancesV2PostRequest body) {
        Validator.validate(body);
        return service.createAnInstance(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders> clientResponse = createAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CreateAnInstanceHeaders> createAnInstanceDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<InstanceMetadata>() { }.getType())
                .register(400, new TypeToken<ApiErrorResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<ApiErrorResult>() { }.getType())
                .register(409, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, CreateAnInstanceHeaders.class);
    }

    /**
     * UpdateInstance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateAnInstance(String instanceId) {
        return updateAnInstanceWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * UpdateInstance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAnInstanceAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateAnInstanceWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * UpdateInstance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAnInstanceAsync(String instanceId) {
        return updateAnInstanceWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateInstance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>> updateAnInstanceWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final InstancesInstanceIdV2PatchRequest body = null;
        return service.updateAnInstance(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders> clientResponse = updateAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * UpdateInstance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @param body the InstancesInstanceIdV2PatchRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateAnInstance(String instanceId, InstancesInstanceIdV2PatchRequest body) {
        return updateAnInstanceWithServiceResponseAsync(instanceId, body).toBlocking().single().body();
    }

    /**
     * UpdateInstance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @param body the InstancesInstanceIdV2PatchRequest value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAnInstanceAsync(String instanceId, InstancesInstanceIdV2PatchRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateAnInstanceWithServiceResponseAsync(instanceId, body), serviceCallback);
    }

    /**
     * UpdateInstance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @param body the InstancesInstanceIdV2PatchRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAnInstanceAsync(String instanceId, InstancesInstanceIdV2PatchRequest body) {
        return updateAnInstanceWithServiceResponseAsync(instanceId, body).map(new Func1<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateInstance.
     * Patches the Market Verticals, Display name, Domain Name, CDS environment and BYOSA secret to the instance.
     *
     * @param instanceId Format - uuid.
     * @param body the InstancesInstanceIdV2PatchRequest value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>> updateAnInstanceWithServiceResponseAsync(String instanceId, InstancesInstanceIdV2PatchRequest body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        Validator.validate(body);
        return service.updateAnInstance(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders> clientResponse = updateAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateAnInstanceHeaders> updateAnInstanceDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<InstanceMetadata>() { }.getType())
                .register(400, new TypeToken<ApiErrorResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, UpdateAnInstanceHeaders.class);
    }

    /**
     * CopyInstance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object copyAnInstance() {
        return copyAnInstanceWithServiceResponseAsync().toBlocking().single().body();
    }

    /**
     * CopyInstance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> copyAnInstanceAsync(final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(copyAnInstanceWithServiceResponseAsync(), serviceCallback);
    }

    /**
     * CopyInstance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> copyAnInstanceAsync() {
        return copyAnInstanceWithServiceResponseAsync().map(new Func1<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * CopyInstance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>> copyAnInstanceWithServiceResponseAsync() {
        final InstancesCopyPostRequest body = null;
        return service.copyAnInstance(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders> clientResponse = copyAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * CopyInstance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @param body The metadata to use to create the new instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object copyAnInstance(InstancesCopyPostRequest body) {
        return copyAnInstanceWithServiceResponseAsync(body).toBlocking().single().body();
    }

    /**
     * CopyInstance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @param body The metadata to use to create the new instance.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> copyAnInstanceAsync(InstancesCopyPostRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(copyAnInstanceWithServiceResponseAsync(body), serviceCallback);
    }

    /**
     * CopyInstance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @param body The metadata to use to create the new instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> copyAnInstanceAsync(InstancesCopyPostRequest body) {
        return copyAnInstanceWithServiceResponseAsync(body).map(new Func1<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * CopyInstance.
     * Create a new instance and copy metadata from an existing instance.
     *
     * @param body The metadata to use to create the new instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>> copyAnInstanceWithServiceResponseAsync(InstancesCopyPostRequest body) {
        Validator.validate(body);
        return service.copyAnInstance(body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders> clientResponse = copyAnInstanceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CopyAnInstanceHeaders> copyAnInstanceDelegate(Response<ResponseBody> response) throws RestException, IOException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<InstanceMetadata>() { }.getType())
                .register(400, new TypeToken<ApiErrorResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(403, new TypeToken<ApiErrorResult>() { }.getType())
                .register(409, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, CopyAnInstanceHeaders.class);
    }

    /**
     * ListAllMeasuresMetadata.
     * ListAllMeasuresMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAListOfMeasuresMetadata(String instanceId) {
        return getAListOfMeasuresMetadataWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * ListAllMeasuresMetadata.
     * ListAllMeasuresMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAListOfMeasuresMetadataAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAListOfMeasuresMetadataWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * ListAllMeasuresMetadata.
     * ListAllMeasuresMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAListOfMeasuresMetadataAsync(String instanceId) {
        return getAListOfMeasuresMetadataWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetAListOfMeasuresMetadataHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAListOfMeasuresMetadataHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ListAllMeasuresMetadata.
     * ListAllMeasuresMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAListOfMeasuresMetadataHeaders>> getAListOfMeasuresMetadataWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getAListOfMeasuresMetadata(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAListOfMeasuresMetadataHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAListOfMeasuresMetadataHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAListOfMeasuresMetadataHeaders> clientResponse = getAListOfMeasuresMetadataDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAListOfMeasuresMetadataHeaders> getAListOfMeasuresMetadataDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<MeasureMetadata>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAListOfMeasuresMetadataHeaders.class);
    }

    /**
     * CreateMeasure.
     * CreateMeasure.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createAMeasure(String instanceId) {
        return createAMeasureWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * CreateMeasure.
     * CreateMeasure.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAMeasureAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createAMeasureWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * CreateMeasure.
     * CreateMeasure.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAMeasureAsync(String instanceId) {
        return createAMeasureWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateAMeasureHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * CreateMeasure.
     * CreateMeasure.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>> createAMeasureWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final InstancesInstanceIdManageMeasuresPostRequest body = null;
        return service.createAMeasure(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateAMeasureHeaders> clientResponse = createAMeasureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * CreateMeasure.
     * CreateMeasure.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Measure metadata to be created
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createAMeasure(String instanceId, InstancesInstanceIdManageMeasuresPostRequest body) {
        return createAMeasureWithServiceResponseAsync(instanceId, body).toBlocking().single().body();
    }

    /**
     * CreateMeasure.
     * CreateMeasure.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Measure metadata to be created
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createAMeasureAsync(String instanceId, InstancesInstanceIdManageMeasuresPostRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createAMeasureWithServiceResponseAsync(instanceId, body), serviceCallback);
    }

    /**
     * CreateMeasure.
     * CreateMeasure.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Measure metadata to be created
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createAMeasureAsync(String instanceId, InstancesInstanceIdManageMeasuresPostRequest body) {
        return createAMeasureWithServiceResponseAsync(instanceId, body).map(new Func1<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateAMeasureHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * CreateMeasure.
     * CreateMeasure.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Measure metadata to be created
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>> createAMeasureWithServiceResponseAsync(String instanceId, InstancesInstanceIdManageMeasuresPostRequest body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        Validator.validate(body);
        return service.createAMeasure(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateAMeasureHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateAMeasureHeaders> clientResponse = createAMeasureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CreateAMeasureHeaders> createAMeasureDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<MeasureMetadata>() { }.getType())
                .register(400, new TypeToken<ParsingError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, CreateAMeasureHeaders.class);
    }

    /**
     * GetMeasureMetadata.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getMetadataForAMeasure(String instanceId, String measureName) {
        return getMetadataForAMeasureWithServiceResponseAsync(instanceId, measureName).toBlocking().single().body();
    }

    /**
     * GetMeasureMetadata.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getMetadataForAMeasureAsync(String instanceId, String measureName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getMetadataForAMeasureWithServiceResponseAsync(instanceId, measureName), serviceCallback);
    }

    /**
     * GetMeasureMetadata.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getMetadataForAMeasureAsync(String instanceId, String measureName) {
        return getMetadataForAMeasureWithServiceResponseAsync(instanceId, measureName).map(new Func1<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetMeasureMetadata.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>> getMetadataForAMeasureWithServiceResponseAsync(String instanceId, String measureName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (measureName == null) {
            throw new IllegalArgumentException("Parameter measureName is required and cannot be null.");
        }
        final Boolean includeHistoricStats = null;
        final Integer historicStatsDays = null;
        return service.getMetadataForAMeasure(instanceId, measureName, includeHistoricStats, historicStatsDays)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders> clientResponse = getMetadataForAMeasureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * GetMeasureMetadata.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param includeHistoricStats Boolean for historical stats
     * @param historicStatsDays Format - int32. Number of lookback days
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getMetadataForAMeasure(String instanceId, String measureName, Boolean includeHistoricStats, Integer historicStatsDays) {
        return getMetadataForAMeasureWithServiceResponseAsync(instanceId, measureName, includeHistoricStats, historicStatsDays).toBlocking().single().body();
    }

    /**
     * GetMeasureMetadata.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param includeHistoricStats Boolean for historical stats
     * @param historicStatsDays Format - int32. Number of lookback days
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getMetadataForAMeasureAsync(String instanceId, String measureName, Boolean includeHistoricStats, Integer historicStatsDays, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getMetadataForAMeasureWithServiceResponseAsync(instanceId, measureName, includeHistoricStats, historicStatsDays), serviceCallback);
    }

    /**
     * GetMeasureMetadata.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param includeHistoricStats Boolean for historical stats
     * @param historicStatsDays Format - int32. Number of lookback days
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getMetadataForAMeasureAsync(String instanceId, String measureName, Boolean includeHistoricStats, Integer historicStatsDays) {
        return getMetadataForAMeasureWithServiceResponseAsync(instanceId, measureName, includeHistoricStats, historicStatsDays).map(new Func1<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetMeasureMetadata.
     * Retrieves the measure metadata for the provided instanceId and measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param includeHistoricStats Boolean for historical stats
     * @param historicStatsDays Format - int32. Number of lookback days
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>> getMetadataForAMeasureWithServiceResponseAsync(String instanceId, String measureName, Boolean includeHistoricStats, Integer historicStatsDays) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (measureName == null) {
            throw new IllegalArgumentException("Parameter measureName is required and cannot be null.");
        }
        return service.getMetadataForAMeasure(instanceId, measureName, includeHistoricStats, historicStatsDays)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders> clientResponse = getMetadataForAMeasureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetMetadataForAMeasureHeaders> getMetadataForAMeasureDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<MeasureMetadata>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetMetadataForAMeasureHeaders.class);
    }

    /**
     * UpdateMeasure.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateAMeasure(String instanceId, String measureName) {
        return updateAMeasureWithServiceResponseAsync(instanceId, measureName).toBlocking().single().body();
    }

    /**
     * UpdateMeasure.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAMeasureAsync(String instanceId, String measureName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateAMeasureWithServiceResponseAsync(instanceId, measureName), serviceCallback);
    }

    /**
     * UpdateMeasure.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAMeasureAsync(String instanceId, String measureName) {
        return updateAMeasureWithServiceResponseAsync(instanceId, measureName).map(new Func1<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateMeasure.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>> updateAMeasureWithServiceResponseAsync(String instanceId, String measureName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (measureName == null) {
            throw new IllegalArgumentException("Parameter measureName is required and cannot be null.");
        }
        final InstancesInstanceIdManageMeasuresMeasureNamePutRequest body = null;
        return service.updateAMeasure(instanceId, measureName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders> clientResponse = updateAMeasureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * UpdateMeasure.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param body Update measure metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateAMeasure(String instanceId, String measureName, InstancesInstanceIdManageMeasuresMeasureNamePutRequest body) {
        return updateAMeasureWithServiceResponseAsync(instanceId, measureName, body).toBlocking().single().body();
    }

    /**
     * UpdateMeasure.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param body Update measure metadata
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateAMeasureAsync(String instanceId, String measureName, InstancesInstanceIdManageMeasuresMeasureNamePutRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateAMeasureWithServiceResponseAsync(instanceId, measureName, body), serviceCallback);
    }

    /**
     * UpdateMeasure.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param body Update measure metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateAMeasureAsync(String instanceId, String measureName, InstancesInstanceIdManageMeasuresMeasureNamePutRequest body) {
        return updateAMeasureWithServiceResponseAsync(instanceId, measureName, body).map(new Func1<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateMeasure.
     * Updates measures metadata for the provided instanceId and measureMetadata.
     Existing measure is retrieved using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param body Update measure metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>> updateAMeasureWithServiceResponseAsync(String instanceId, String measureName, InstancesInstanceIdManageMeasuresMeasureNamePutRequest body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (measureName == null) {
            throw new IllegalArgumentException("Parameter measureName is required and cannot be null.");
        }
        Validator.validate(body);
        return service.updateAMeasure(instanceId, measureName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders> clientResponse = updateAMeasureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateAMeasureHeaders> updateAMeasureDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<MeasureMetadata>() { }.getType())
                .register(400, new TypeToken<ParsingError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, UpdateAMeasureHeaders.class);
    }

    /**
     * DeleteMeasure.
     * Deletes the measure metadata for the provided instanceId using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteAMeasure(String instanceId, String measureName) {
        return deleteAMeasureWithServiceResponseAsync(instanceId, measureName).toBlocking().single().body();
    }

    /**
     * DeleteMeasure.
     * Deletes the measure metadata for the provided instanceId using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteAMeasureAsync(String instanceId, String measureName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteAMeasureWithServiceResponseAsync(instanceId, measureName), serviceCallback);
    }

    /**
     * DeleteMeasure.
     * Deletes the measure metadata for the provided instanceId using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteAMeasureAsync(String instanceId, String measureName) {
        return deleteAMeasureWithServiceResponseAsync(instanceId, measureName).map(new Func1<ServiceResponseWithHeaders<Object, DeleteAMeasureHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DeleteAMeasureHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * DeleteMeasure.
     * Deletes the measure metadata for the provided instanceId using measureName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param measureName Name of the measure
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DeleteAMeasureHeaders>> deleteAMeasureWithServiceResponseAsync(String instanceId, String measureName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (measureName == null) {
            throw new IllegalArgumentException("Parameter measureName is required and cannot be null.");
        }
        return service.deleteAMeasure(instanceId, measureName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DeleteAMeasureHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DeleteAMeasureHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DeleteAMeasureHeaders> clientResponse = deleteAMeasureDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DeleteAMeasureHeaders> deleteAMeasureDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<DeletionResponse>() { }.getType())
                .register(400, new TypeToken<DeletionResponse>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, DeleteAMeasureHeaders.class);
    }

    /**
     * GetKeyRing.
     * Gets the KeyRing (collection of all alternate keys) for the given instance by alternate key.
     *
     * @param instanceId Format - uuid. Identifier for the instance
     * @param dataSourceName The name of the datasource that contains the given entity.
     * @param entityName The name of the entity that contains the given key.
     * @param key The value of the alternate key provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getKeyRing(String instanceId, String dataSourceName, String entityName, String key) {
        return getKeyRingWithServiceResponseAsync(instanceId, dataSourceName, entityName, key).toBlocking().single().body();
    }

    /**
     * GetKeyRing.
     * Gets the KeyRing (collection of all alternate keys) for the given instance by alternate key.
     *
     * @param instanceId Format - uuid. Identifier for the instance
     * @param dataSourceName The name of the datasource that contains the given entity.
     * @param entityName The name of the entity that contains the given key.
     * @param key The value of the alternate key provided.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getKeyRingAsync(String instanceId, String dataSourceName, String entityName, String key, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getKeyRingWithServiceResponseAsync(instanceId, dataSourceName, entityName, key), serviceCallback);
    }

    /**
     * GetKeyRing.
     * Gets the KeyRing (collection of all alternate keys) for the given instance by alternate key.
     *
     * @param instanceId Format - uuid. Identifier for the instance
     * @param dataSourceName The name of the datasource that contains the given entity.
     * @param entityName The name of the entity that contains the given key.
     * @param key The value of the alternate key provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getKeyRingAsync(String instanceId, String dataSourceName, String entityName, String key) {
        return getKeyRingWithServiceResponseAsync(instanceId, dataSourceName, entityName, key).map(new Func1<ServiceResponseWithHeaders<Object, GetKeyRingHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetKeyRingHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetKeyRing.
     * Gets the KeyRing (collection of all alternate keys) for the given instance by alternate key.
     *
     * @param instanceId Format - uuid. Identifier for the instance
     * @param dataSourceName The name of the datasource that contains the given entity.
     * @param entityName The name of the entity that contains the given key.
     * @param key The value of the alternate key provided.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetKeyRingHeaders>> getKeyRingWithServiceResponseAsync(String instanceId, String dataSourceName, String entityName, String key) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (dataSourceName == null) {
            throw new IllegalArgumentException("Parameter dataSourceName is required and cannot be null.");
        }
        if (entityName == null) {
            throw new IllegalArgumentException("Parameter entityName is required and cannot be null.");
        }
        if (key == null) {
            throw new IllegalArgumentException("Parameter key is required and cannot be null.");
        }
        return service.getKeyRing(instanceId, dataSourceName, entityName, key)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetKeyRingHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetKeyRingHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetKeyRingHeaders> clientResponse = getKeyRingDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetKeyRingHeaders> getKeyRingDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<KeyRingResponse>() { }.getType())
                .register(400, new TypeToken<ApiErrorResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetKeyRingHeaders.class);
    }

    /**
     * GetProfileStoreState.
     * Gets the profile store state infoformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getProfileStoreState(String instanceId) {
        return getProfileStoreStateWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * GetProfileStoreState.
     * Gets the profile store state infoformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getProfileStoreStateAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getProfileStoreStateWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * GetProfileStoreState.
     * Gets the profile store state infoformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getProfileStoreStateAsync(String instanceId) {
        return getProfileStoreStateWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetProfileStoreStateHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetProfileStoreStateHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetProfileStoreState.
     * Gets the profile store state infoformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetProfileStoreStateHeaders>> getProfileStoreStateWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getProfileStoreState(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetProfileStoreStateHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetProfileStoreStateHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetProfileStoreStateHeaders> clientResponse = getProfileStoreStateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetProfileStoreStateHeaders> getProfileStoreStateDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<ProfileStoreStateInfo>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, GetProfileStoreStateHeaders.class);
    }

    /**
     * ListAllRoles.
     * Get all role definitions.
     *
     * @param instanceId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RoleDefinition&gt; object if successful.
     */
    public List<RoleDefinition> getAllRoleDefinitions(String instanceId) {
        return getAllRoleDefinitionsWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * ListAllRoles.
     * Get all role definitions.
     *
     * @param instanceId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RoleDefinition>> getAllRoleDefinitionsAsync(String instanceId, final ServiceCallback<List<RoleDefinition>> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllRoleDefinitionsWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * ListAllRoles.
     * Get all role definitions.
     *
     * @param instanceId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleDefinition&gt; object
     */
    public Observable<List<RoleDefinition>> getAllRoleDefinitionsAsync(String instanceId) {
        return getAllRoleDefinitionsWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<List<RoleDefinition>, GetAllRoleDefinitionsHeaders>, List<RoleDefinition>>() {
            @Override
            public List<RoleDefinition> call(ServiceResponseWithHeaders<List<RoleDefinition>, GetAllRoleDefinitionsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ListAllRoles.
     * Get all role definitions.
     *
     * @param instanceId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleDefinition&gt; object
     */
    public Observable<ServiceResponseWithHeaders<List<RoleDefinition>, GetAllRoleDefinitionsHeaders>> getAllRoleDefinitionsWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getAllRoleDefinitions(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<List<RoleDefinition>, GetAllRoleDefinitionsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<List<RoleDefinition>, GetAllRoleDefinitionsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<List<RoleDefinition>, GetAllRoleDefinitionsHeaders> clientResponse = getAllRoleDefinitionsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<List<RoleDefinition>, GetAllRoleDefinitionsHeaders> getAllRoleDefinitionsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<RoleDefinition>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RoleDefinition>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAllRoleDefinitionsHeaders.class);
    }

    /**
     * GetCurrentUserRole.
     * Get role of current user.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the RoleAssignment object if successful.
     */
    public RoleAssignment getCurrentUserRole(String instanceId) {
        return getCurrentUserRoleWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * GetCurrentUserRole.
     * Get role of current user.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<RoleAssignment> getCurrentUserRoleAsync(String instanceId, final ServiceCallback<RoleAssignment> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getCurrentUserRoleWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * GetCurrentUserRole.
     * Get role of current user.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RoleAssignment object
     */
    public Observable<RoleAssignment> getCurrentUserRoleAsync(String instanceId) {
        return getCurrentUserRoleWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<RoleAssignment, GetCurrentUserRoleHeaders>, RoleAssignment>() {
            @Override
            public RoleAssignment call(ServiceResponseWithHeaders<RoleAssignment, GetCurrentUserRoleHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetCurrentUserRole.
     * Get role of current user.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the RoleAssignment object
     */
    public Observable<ServiceResponseWithHeaders<RoleAssignment, GetCurrentUserRoleHeaders>> getCurrentUserRoleWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getCurrentUserRole(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<RoleAssignment, GetCurrentUserRoleHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<RoleAssignment, GetCurrentUserRoleHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<RoleAssignment, GetCurrentUserRoleHeaders> clientResponse = getCurrentUserRoleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<RoleAssignment, GetCurrentUserRoleHeaders> getCurrentUserRoleDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<RoleAssignment, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RoleAssignment>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetCurrentUserRoleHeaders.class);
    }

    /**
     * UpdateRoleAssignment.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RoleAssignment&gt; object if successful.
     */
    public List<RoleAssignment> updateARoleAssignment(String instanceId, String principalId) {
        return updateARoleAssignmentWithServiceResponseAsync(instanceId, principalId).toBlocking().single().body();
    }

    /**
     * UpdateRoleAssignment.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RoleAssignment>> updateARoleAssignmentAsync(String instanceId, String principalId, final ServiceCallback<List<RoleAssignment>> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateARoleAssignmentWithServiceResponseAsync(instanceId, principalId), serviceCallback);
    }

    /**
     * UpdateRoleAssignment.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleAssignment&gt; object
     */
    public Observable<List<RoleAssignment>> updateARoleAssignmentAsync(String instanceId, String principalId) {
        return updateARoleAssignmentWithServiceResponseAsync(instanceId, principalId).map(new Func1<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>, List<RoleAssignment>>() {
            @Override
            public List<RoleAssignment> call(ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateRoleAssignment.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleAssignment&gt; object
     */
    public Observable<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>> updateARoleAssignmentWithServiceResponseAsync(String instanceId, String principalId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (principalId == null) {
            throw new IllegalArgumentException("Parameter principalId is required and cannot be null.");
        }
        final InstancesInstanceIdRbacPrincipalsPrincipalIdAssignmentPutRequest body = null;
        return service.updateARoleAssignment(instanceId, principalId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders> clientResponse = updateARoleAssignmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * UpdateRoleAssignment.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @param body The role assignment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RoleAssignment&gt; object if successful.
     */
    public List<RoleAssignment> updateARoleAssignment(String instanceId, String principalId, InstancesInstanceIdRbacPrincipalsPrincipalIdAssignmentPutRequest body) {
        return updateARoleAssignmentWithServiceResponseAsync(instanceId, principalId, body).toBlocking().single().body();
    }

    /**
     * UpdateRoleAssignment.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @param body The role assignment.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RoleAssignment>> updateARoleAssignmentAsync(String instanceId, String principalId, InstancesInstanceIdRbacPrincipalsPrincipalIdAssignmentPutRequest body, final ServiceCallback<List<RoleAssignment>> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateARoleAssignmentWithServiceResponseAsync(instanceId, principalId, body), serviceCallback);
    }

    /**
     * UpdateRoleAssignment.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @param body The role assignment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleAssignment&gt; object
     */
    public Observable<List<RoleAssignment>> updateARoleAssignmentAsync(String instanceId, String principalId, InstancesInstanceIdRbacPrincipalsPrincipalIdAssignmentPutRequest body) {
        return updateARoleAssignmentWithServiceResponseAsync(instanceId, principalId, body).map(new Func1<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>, List<RoleAssignment>>() {
            @Override
            public List<RoleAssignment> call(ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateRoleAssignment.
     * Adds or updates a role assignment for a principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @param body The role assignment.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleAssignment&gt; object
     */
    public Observable<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>> updateARoleAssignmentWithServiceResponseAsync(String instanceId, String principalId, InstancesInstanceIdRbacPrincipalsPrincipalIdAssignmentPutRequest body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (principalId == null) {
            throw new IllegalArgumentException("Parameter principalId is required and cannot be null.");
        }
        Validator.validate(body);
        return service.updateARoleAssignment(instanceId, principalId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders> clientResponse = updateARoleAssignmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<List<RoleAssignment>, UpdateARoleAssignmentHeaders> updateARoleAssignmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<RoleAssignment>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RoleAssignment>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, UpdateARoleAssignmentHeaders.class);
    }

    /**
     * DeleteRoleAssignment.
     * Deletes a role assignment for the principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     */
    public void deletesARoleAssignment(String instanceId, String principalId) {
        deletesARoleAssignmentWithServiceResponseAsync(instanceId, principalId).toBlocking().single().body();
    }

    /**
     * DeleteRoleAssignment.
     * Deletes a role assignment for the principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Void> deletesARoleAssignmentAsync(String instanceId, String principalId, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deletesARoleAssignmentWithServiceResponseAsync(instanceId, principalId), serviceCallback);
    }

    /**
     * DeleteRoleAssignment.
     * Deletes a role assignment for the principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<Void> deletesARoleAssignmentAsync(String instanceId, String principalId) {
        return deletesARoleAssignmentWithServiceResponseAsync(instanceId, principalId).map(new Func1<ServiceResponseWithHeaders<Void, DeletesARoleAssignmentHeaders>, Void>() {
            @Override
            public Void call(ServiceResponseWithHeaders<Void, DeletesARoleAssignmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * DeleteRoleAssignment.
     * Deletes a role assignment for the principal.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param principalId The principal id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceResponseWithHeaders} object if successful.
     */
    public Observable<ServiceResponseWithHeaders<Void, DeletesARoleAssignmentHeaders>> deletesARoleAssignmentWithServiceResponseAsync(String instanceId, String principalId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (principalId == null) {
            throw new IllegalArgumentException("Parameter principalId is required and cannot be null.");
        }
        return service.deletesARoleAssignment(instanceId, principalId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Void, DeletesARoleAssignmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Void, DeletesARoleAssignmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Void, DeletesARoleAssignmentHeaders> clientResponse = deletesARoleAssignmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Void, DeletesARoleAssignmentHeaders> deletesARoleAssignmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Void, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, DeletesARoleAssignmentHeaders.class);
    }

    /**
     * ListAllRoleAssignments.
     * Gets all role assignments for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the List&lt;RoleAssignment&gt; object if successful.
     */
    public List<RoleAssignment> getAllRoleAssignments(String instanceId) {
        return getAllRoleAssignmentsWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * ListAllRoleAssignments.
     * Gets all role assignments for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<List<RoleAssignment>> getAllRoleAssignmentsAsync(String instanceId, final ServiceCallback<List<RoleAssignment>> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllRoleAssignmentsWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * ListAllRoleAssignments.
     * Gets all role assignments for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleAssignment&gt; object
     */
    public Observable<List<RoleAssignment>> getAllRoleAssignmentsAsync(String instanceId) {
        return getAllRoleAssignmentsWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<List<RoleAssignment>, GetAllRoleAssignmentsHeaders>, List<RoleAssignment>>() {
            @Override
            public List<RoleAssignment> call(ServiceResponseWithHeaders<List<RoleAssignment>, GetAllRoleAssignmentsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ListAllRoleAssignments.
     * Gets all role assignments for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the List&lt;RoleAssignment&gt; object
     */
    public Observable<ServiceResponseWithHeaders<List<RoleAssignment>, GetAllRoleAssignmentsHeaders>> getAllRoleAssignmentsWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getAllRoleAssignments(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<List<RoleAssignment>, GetAllRoleAssignmentsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<List<RoleAssignment>, GetAllRoleAssignmentsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<List<RoleAssignment>, GetAllRoleAssignmentsHeaders> clientResponse = getAllRoleAssignmentsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<List<RoleAssignment>, GetAllRoleAssignmentsHeaders> getAllRoleAssignmentsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<List<RoleAssignment>, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RoleAssignment>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAllRoleAssignmentsHeaders.class);
    }

    /**
     * ListAllRelationships.
     * Gets all relationship metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllRelationships(String instanceId) {
        return getAllRelationshipsWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * ListAllRelationships.
     * Gets all relationship metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllRelationshipsAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllRelationshipsWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * ListAllRelationships.
     * Gets all relationship metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllRelationshipsAsync(String instanceId) {
        return getAllRelationshipsWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetAllRelationshipsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllRelationshipsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ListAllRelationships.
     * Gets all relationship metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllRelationshipsHeaders>> getAllRelationshipsWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getAllRelationships(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllRelationshipsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllRelationshipsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllRelationshipsHeaders> clientResponse = getAllRelationshipsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAllRelationshipsHeaders> getAllRelationshipsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<RelationshipMetadata>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, GetAllRelationshipsHeaders.class);
    }

    /**
     * CreateRelationship.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createARelationship(String instanceId) {
        return createARelationshipWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * CreateRelationship.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createARelationshipAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createARelationshipWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * CreateRelationship.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createARelationshipAsync(String instanceId) {
        return createARelationshipWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateARelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * CreateRelationship.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>> createARelationshipWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final InstancesInstanceIdManageRelationshipsPostRequest body = null;
        return service.createARelationship(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateARelationshipHeaders> clientResponse = createARelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * CreateRelationship.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body The updated relationship metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createARelationship(String instanceId, InstancesInstanceIdManageRelationshipsPostRequest body) {
        return createARelationshipWithServiceResponseAsync(instanceId, body).toBlocking().single().body();
    }

    /**
     * CreateRelationship.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body The updated relationship metadata
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createARelationshipAsync(String instanceId, InstancesInstanceIdManageRelationshipsPostRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createARelationshipWithServiceResponseAsync(instanceId, body), serviceCallback);
    }

    /**
     * CreateRelationship.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body The updated relationship metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createARelationshipAsync(String instanceId, InstancesInstanceIdManageRelationshipsPostRequest body) {
        return createARelationshipWithServiceResponseAsync(instanceId, body).map(new Func1<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateARelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * CreateRelationship.
     * Creates new relationship metadata for the provided instanceId, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body The updated relationship metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>> createARelationshipWithServiceResponseAsync(String instanceId, InstancesInstanceIdManageRelationshipsPostRequest body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        Validator.validate(body);
        return service.createARelationship(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateARelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateARelationshipHeaders> clientResponse = createARelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CreateARelationshipHeaders> createARelationshipDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RelationshipMetadata>() { }.getType())
                .register(400, new TypeToken<ApiError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, CreateARelationshipHeaders.class);
    }

    /**
     * GetRelationship.
     * Gets the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getARelationship(String instanceId, String relationshipName) {
        return getARelationshipWithServiceResponseAsync(instanceId, relationshipName).toBlocking().single().body();
    }

    /**
     * GetRelationship.
     * Gets the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getARelationshipAsync(String instanceId, String relationshipName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getARelationshipWithServiceResponseAsync(instanceId, relationshipName), serviceCallback);
    }

    /**
     * GetRelationship.
     * Gets the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getARelationshipAsync(String instanceId, String relationshipName) {
        return getARelationshipWithServiceResponseAsync(instanceId, relationshipName).map(new Func1<ServiceResponseWithHeaders<Object, GetARelationshipHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetARelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetRelationship.
     * Gets the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetARelationshipHeaders>> getARelationshipWithServiceResponseAsync(String instanceId, String relationshipName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (relationshipName == null) {
            throw new IllegalArgumentException("Parameter relationshipName is required and cannot be null.");
        }
        return service.getARelationship(instanceId, relationshipName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetARelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetARelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetARelationshipHeaders> clientResponse = getARelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetARelationshipHeaders> getARelationshipDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RelationshipMetadata>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, GetARelationshipHeaders.class);
    }

    /**
     * DeleteRelationship.
     * Deletes the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteARelationship(String instanceId, String relationshipName) {
        return deleteARelationshipWithServiceResponseAsync(instanceId, relationshipName).toBlocking().single().body();
    }

    /**
     * DeleteRelationship.
     * Deletes the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteARelationshipAsync(String instanceId, String relationshipName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteARelationshipWithServiceResponseAsync(instanceId, relationshipName), serviceCallback);
    }

    /**
     * DeleteRelationship.
     * Deletes the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteARelationshipAsync(String instanceId, String relationshipName) {
        return deleteARelationshipWithServiceResponseAsync(instanceId, relationshipName).map(new Func1<ServiceResponseWithHeaders<Object, DeleteARelationshipHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DeleteARelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * DeleteRelationship.
     * Deletes the relationship metadata for the provided instanceId and relationshipName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DeleteARelationshipHeaders>> deleteARelationshipWithServiceResponseAsync(String instanceId, String relationshipName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (relationshipName == null) {
            throw new IllegalArgumentException("Parameter relationshipName is required and cannot be null.");
        }
        return service.deleteARelationship(instanceId, relationshipName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DeleteARelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DeleteARelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DeleteARelationshipHeaders> clientResponse = deleteARelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DeleteARelationshipHeaders> deleteARelationshipDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<OkResult>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, DeleteARelationshipHeaders.class);
    }

    /**
     * UpdateRelationshhip.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateARelationship(String instanceId, String relationshipName) {
        return updateARelationshipWithServiceResponseAsync(instanceId, relationshipName).toBlocking().single().body();
    }

    /**
     * UpdateRelationshhip.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateARelationshipAsync(String instanceId, String relationshipName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateARelationshipWithServiceResponseAsync(instanceId, relationshipName), serviceCallback);
    }

    /**
     * UpdateRelationshhip.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateARelationshipAsync(String instanceId, String relationshipName) {
        return updateARelationshipWithServiceResponseAsync(instanceId, relationshipName).map(new Func1<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateRelationshhip.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>> updateARelationshipWithServiceResponseAsync(String instanceId, String relationshipName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (relationshipName == null) {
            throw new IllegalArgumentException("Parameter relationshipName is required and cannot be null.");
        }
        final InstancesInstanceIdManageRelationshipsRelationshipNamePutRequest body = null;
        return service.updateARelationship(instanceId, relationshipName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders> clientResponse = updateARelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * UpdateRelationshhip.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @param body The updated relationship metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateARelationship(String instanceId, String relationshipName, InstancesInstanceIdManageRelationshipsRelationshipNamePutRequest body) {
        return updateARelationshipWithServiceResponseAsync(instanceId, relationshipName, body).toBlocking().single().body();
    }

    /**
     * UpdateRelationshhip.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @param body The updated relationship metadata
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateARelationshipAsync(String instanceId, String relationshipName, InstancesInstanceIdManageRelationshipsRelationshipNamePutRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateARelationshipWithServiceResponseAsync(instanceId, relationshipName, body), serviceCallback);
    }

    /**
     * UpdateRelationshhip.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @param body The updated relationship metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateARelationshipAsync(String instanceId, String relationshipName, InstancesInstanceIdManageRelationshipsRelationshipNamePutRequest body) {
        return updateARelationshipWithServiceResponseAsync(instanceId, relationshipName, body).map(new Func1<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateRelationshhip.
     * Updates the relationship metadata for the provided instanceId and relationshipName, using input.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param relationshipName Relationship name
     * @param body The updated relationship metadata
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>> updateARelationshipWithServiceResponseAsync(String instanceId, String relationshipName, InstancesInstanceIdManageRelationshipsRelationshipNamePutRequest body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (relationshipName == null) {
            throw new IllegalArgumentException("Parameter relationshipName is required and cannot be null.");
        }
        Validator.validate(body);
        return service.updateARelationship(instanceId, relationshipName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders> clientResponse = updateARelationshipDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateARelationshipHeaders> updateARelationshipDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<RelationshipMetadata>() { }.getType())
                .register(400, new TypeToken<ApiError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, UpdateARelationshipHeaders.class);
    }

    /**
     * GetSearchConfiguration.
     * Gets the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSearchConfiguration(String instanceId) {
        return getSearchConfigurationWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * GetSearchConfiguration.
     * Gets the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSearchConfigurationAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getSearchConfigurationWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * GetSearchConfiguration.
     * Gets the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSearchConfigurationAsync(String instanceId) {
        return getSearchConfigurationWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetSearchConfigurationHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetSearchConfigurationHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetSearchConfiguration.
     * Gets the search configuration for the instance.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetSearchConfigurationHeaders>> getSearchConfigurationWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getSearchConfiguration(instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetSearchConfigurationHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetSearchConfigurationHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetSearchConfigurationHeaders> clientResponse = getSearchConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetSearchConfigurationHeaders> getSearchConfigurationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<InstanceSearchConfiguration>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, GetSearchConfigurationHeaders.class);
    }

    /**
     * UpdateSearchConfiguration.
     * UpdateSearchConfiguration.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateSearchConfiguration(String instanceId) {
        return updateSearchConfigurationWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * UpdateSearchConfiguration.
     * UpdateSearchConfiguration.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateSearchConfigurationAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateSearchConfigurationWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * UpdateSearchConfiguration.
     * UpdateSearchConfiguration.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateSearchConfigurationAsync(String instanceId) {
        return updateSearchConfigurationWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateSearchConfiguration.
     * UpdateSearchConfiguration.
     *
     * @param instanceId Format - uuid. The instance id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>> updateSearchConfigurationWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final InstancesInstanceIdManageSearchPutRequest body = null;
        return service.updateSearchConfiguration(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders> clientResponse = updateSearchConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * UpdateSearchConfiguration.
     * UpdateSearchConfiguration.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param body The search configuration for the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateSearchConfiguration(String instanceId, InstancesInstanceIdManageSearchPutRequest body) {
        return updateSearchConfigurationWithServiceResponseAsync(instanceId, body).toBlocking().single().body();
    }

    /**
     * UpdateSearchConfiguration.
     * UpdateSearchConfiguration.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param body The search configuration for the instance.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateSearchConfigurationAsync(String instanceId, InstancesInstanceIdManageSearchPutRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateSearchConfigurationWithServiceResponseAsync(instanceId, body), serviceCallback);
    }

    /**
     * UpdateSearchConfiguration.
     * UpdateSearchConfiguration.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param body The search configuration for the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateSearchConfigurationAsync(String instanceId, InstancesInstanceIdManageSearchPutRequest body) {
        return updateSearchConfigurationWithServiceResponseAsync(instanceId, body).map(new Func1<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateSearchConfiguration.
     * UpdateSearchConfiguration.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param body The search configuration for the instance.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>> updateSearchConfigurationWithServiceResponseAsync(String instanceId, InstancesInstanceIdManageSearchPutRequest body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        Validator.validate(body);
        return service.updateSearchConfiguration(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders> clientResponse = updateSearchConfigurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateSearchConfigurationHeaders> updateSearchConfigurationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<InstanceSearchConfiguration>() { }.getType())
                .register(400, new TypeToken<ApiError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<ApiError>() { }.getType())
                .buildWithHeaders(response, UpdateSearchConfigurationHeaders.class);
    }

    /**
     * ListAllSegments.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllSegments(String instanceId) {
        return getAllSegmentsWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * ListAllSegments.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllSegmentsAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllSegmentsWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * ListAllSegments.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllSegmentsAsync(String instanceId) {
        return getAllSegmentsWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ListAllSegments.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>> getAllSegmentsWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final Boolean includeHistoricStats = null;
        final Integer historicStatsDays = null;
        final Integer numberOfSegments = null;
        return service.getAllSegments(instanceId, includeHistoricStats, historicStatsDays, numberOfSegments)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders> clientResponse = getAllSegmentsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * ListAllSegments.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param includeHistoricStats Optional parameter to retrieve evaluation history of all the sgements in instanceId.
     * @param historicStatsDays Format - int32. Optional parameter to get number of days evaluation history.
     * @param numberOfSegments Format - int32. Optional parameter to limit the number of segments returned.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAllSegments(String instanceId, Boolean includeHistoricStats, Integer historicStatsDays, Integer numberOfSegments) {
        return getAllSegmentsWithServiceResponseAsync(instanceId, includeHistoricStats, historicStatsDays, numberOfSegments).toBlocking().single().body();
    }

    /**
     * ListAllSegments.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param includeHistoricStats Optional parameter to retrieve evaluation history of all the sgements in instanceId.
     * @param historicStatsDays Format - int32. Optional parameter to get number of days evaluation history.
     * @param numberOfSegments Format - int32. Optional parameter to limit the number of segments returned.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAllSegmentsAsync(String instanceId, Boolean includeHistoricStats, Integer historicStatsDays, Integer numberOfSegments, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAllSegmentsWithServiceResponseAsync(instanceId, includeHistoricStats, historicStatsDays, numberOfSegments), serviceCallback);
    }

    /**
     * ListAllSegments.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param includeHistoricStats Optional parameter to retrieve evaluation history of all the sgements in instanceId.
     * @param historicStatsDays Format - int32. Optional parameter to get number of days evaluation history.
     * @param numberOfSegments Format - int32. Optional parameter to limit the number of segments returned.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAllSegmentsAsync(String instanceId, Boolean includeHistoricStats, Integer historicStatsDays, Integer numberOfSegments) {
        return getAllSegmentsWithServiceResponseAsync(instanceId, includeHistoricStats, historicStatsDays, numberOfSegments).map(new Func1<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ListAllSegments.
     * Retrieves a list of segment metadata for the provided instanceId.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param includeHistoricStats Optional parameter to retrieve evaluation history of all the sgements in instanceId.
     * @param historicStatsDays Format - int32. Optional parameter to get number of days evaluation history.
     * @param numberOfSegments Format - int32. Optional parameter to limit the number of segments returned.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>> getAllSegmentsWithServiceResponseAsync(String instanceId, Boolean includeHistoricStats, Integer historicStatsDays, Integer numberOfSegments) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getAllSegments(instanceId, includeHistoricStats, historicStatsDays, numberOfSegments)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders> clientResponse = getAllSegmentsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAllSegmentsHeaders> getAllSegmentsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<SegmentMetadata>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAllSegmentsHeaders.class);
    }

    /**
     * CreateSegment.
     * CreateSegment.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createASegment(String instanceId) {
        return createASegmentWithServiceResponseAsync(instanceId).toBlocking().single().body();
    }

    /**
     * CreateSegment.
     * CreateSegment.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createASegmentAsync(String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createASegmentWithServiceResponseAsync(instanceId), serviceCallback);
    }

    /**
     * CreateSegment.
     * CreateSegment.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createASegmentAsync(String instanceId) {
        return createASegmentWithServiceResponseAsync(instanceId).map(new Func1<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateASegmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * CreateSegment.
     * CreateSegment.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>> createASegmentWithServiceResponseAsync(String instanceId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        final InstancesInstanceIdManageSegmentsPostRequest body = null;
        return service.createASegment(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateASegmentHeaders> clientResponse = createASegmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * CreateSegment.
     * CreateSegment.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Segment metadata to be created
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createASegment(String instanceId, InstancesInstanceIdManageSegmentsPostRequest body) {
        return createASegmentWithServiceResponseAsync(instanceId, body).toBlocking().single().body();
    }

    /**
     * CreateSegment.
     * CreateSegment.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Segment metadata to be created
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createASegmentAsync(String instanceId, InstancesInstanceIdManageSegmentsPostRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createASegmentWithServiceResponseAsync(instanceId, body), serviceCallback);
    }

    /**
     * CreateSegment.
     * CreateSegment.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Segment metadata to be created
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createASegmentAsync(String instanceId, InstancesInstanceIdManageSegmentsPostRequest body) {
        return createASegmentWithServiceResponseAsync(instanceId, body).map(new Func1<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateASegmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * CreateSegment.
     * CreateSegment.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param body New Segment metadata to be created
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>> createASegmentWithServiceResponseAsync(String instanceId, InstancesInstanceIdManageSegmentsPostRequest body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        Validator.validate(body);
        return service.createASegment(instanceId, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateASegmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateASegmentHeaders> clientResponse = createASegmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CreateASegmentHeaders> createASegmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(201, new TypeToken<SegmentMetadata>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, CreateASegmentHeaders.class);
    }

    /**
     * ActivateSegment.
     * Activate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object activateSegment(String instanceId, String segmentName) {
        return activateSegmentWithServiceResponseAsync(instanceId, segmentName).toBlocking().single().body();
    }

    /**
     * ActivateSegment.
     * Activate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> activateSegmentAsync(String instanceId, String segmentName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(activateSegmentWithServiceResponseAsync(instanceId, segmentName), serviceCallback);
    }

    /**
     * ActivateSegment.
     * Activate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> activateSegmentAsync(String instanceId, String segmentName) {
        return activateSegmentWithServiceResponseAsync(instanceId, segmentName).map(new Func1<ServiceResponseWithHeaders<Object, ActivateSegmentHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, ActivateSegmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ActivateSegment.
     * Activate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, ActivateSegmentHeaders>> activateSegmentWithServiceResponseAsync(String instanceId, String segmentName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (segmentName == null) {
            throw new IllegalArgumentException("Parameter segmentName is required and cannot be null.");
        }
        return service.activateSegment(instanceId, segmentName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, ActivateSegmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, ActivateSegmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, ActivateSegmentHeaders> clientResponse = activateSegmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, ActivateSegmentHeaders> activateSegmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Boolean>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, ActivateSegmentHeaders.class);
    }

    /**
     * DeactivateSegment.
     * Deactivate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deactivateSegment(String instanceId, String segmentName) {
        return deactivateSegmentWithServiceResponseAsync(instanceId, segmentName).toBlocking().single().body();
    }

    /**
     * DeactivateSegment.
     * Deactivate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deactivateSegmentAsync(String instanceId, String segmentName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deactivateSegmentWithServiceResponseAsync(instanceId, segmentName), serviceCallback);
    }

    /**
     * DeactivateSegment.
     * Deactivate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deactivateSegmentAsync(String instanceId, String segmentName) {
        return deactivateSegmentWithServiceResponseAsync(instanceId, segmentName).map(new Func1<ServiceResponseWithHeaders<Object, DeactivateSegmentHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DeactivateSegmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * DeactivateSegment.
     * Deactivate segment on instanceId with segmentName.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DeactivateSegmentHeaders>> deactivateSegmentWithServiceResponseAsync(String instanceId, String segmentName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (segmentName == null) {
            throw new IllegalArgumentException("Parameter segmentName is required and cannot be null.");
        }
        return service.deactivateSegment(instanceId, segmentName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DeactivateSegmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DeactivateSegmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DeactivateSegmentHeaders> clientResponse = deactivateSegmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DeactivateSegmentHeaders> deactivateSegmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<Boolean>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, DeactivateSegmentHeaders.class);
    }

    /**
     * UpdateSegments.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateASegment(String instanceId, String segmentName) {
        return updateASegmentWithServiceResponseAsync(instanceId, segmentName).toBlocking().single().body();
    }

    /**
     * UpdateSegments.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateASegmentAsync(String instanceId, String segmentName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateASegmentWithServiceResponseAsync(instanceId, segmentName), serviceCallback);
    }

    /**
     * UpdateSegments.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateASegmentAsync(String instanceId, String segmentName) {
        return updateASegmentWithServiceResponseAsync(instanceId, segmentName).map(new Func1<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateASegmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateSegments.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>> updateASegmentWithServiceResponseAsync(String instanceId, String segmentName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (segmentName == null) {
            throw new IllegalArgumentException("Parameter segmentName is required and cannot be null.");
        }
        final InstancesInstanceIdManageSegmentsSegmentNamePutRequest body = null;
        return service.updateASegment(instanceId, segmentName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateASegmentHeaders> clientResponse = updateASegmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * UpdateSegments.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param body New Segment metadata to be updated
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object updateASegment(String instanceId, String segmentName, InstancesInstanceIdManageSegmentsSegmentNamePutRequest body) {
        return updateASegmentWithServiceResponseAsync(instanceId, segmentName, body).toBlocking().single().body();
    }

    /**
     * UpdateSegments.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param body New Segment metadata to be updated
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> updateASegmentAsync(String instanceId, String segmentName, InstancesInstanceIdManageSegmentsSegmentNamePutRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateASegmentWithServiceResponseAsync(instanceId, segmentName, body), serviceCallback);
    }

    /**
     * UpdateSegments.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param body New Segment metadata to be updated
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> updateASegmentAsync(String instanceId, String segmentName, InstancesInstanceIdManageSegmentsSegmentNamePutRequest body) {
        return updateASegmentWithServiceResponseAsync(instanceId, segmentName, body).map(new Func1<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, UpdateASegmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * UpdateSegments.
     * Updates segment metadata for the provided instanceId and segmentName with segmentMetadata.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param body New Segment metadata to be updated
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>> updateASegmentWithServiceResponseAsync(String instanceId, String segmentName, InstancesInstanceIdManageSegmentsSegmentNamePutRequest body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (segmentName == null) {
            throw new IllegalArgumentException("Parameter segmentName is required and cannot be null.");
        }
        Validator.validate(body);
        return service.updateASegment(instanceId, segmentName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, UpdateASegmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, UpdateASegmentHeaders> clientResponse = updateASegmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, UpdateASegmentHeaders> updateASegmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<SegmentMetadata>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiError>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, UpdateASegmentHeaders.class);
    }

    /**
     * DeleteSegment.
     * DeleteSegment.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object deleteSegment(String instanceId, String segmentName) {
        return deleteSegmentWithServiceResponseAsync(instanceId, segmentName).toBlocking().single().body();
    }

    /**
     * DeleteSegment.
     * DeleteSegment.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> deleteSegmentAsync(String instanceId, String segmentName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(deleteSegmentWithServiceResponseAsync(instanceId, segmentName), serviceCallback);
    }

    /**
     * DeleteSegment.
     * DeleteSegment.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> deleteSegmentAsync(String instanceId, String segmentName) {
        return deleteSegmentWithServiceResponseAsync(instanceId, segmentName).map(new Func1<ServiceResponseWithHeaders<Object, DeleteSegmentHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DeleteSegmentHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * DeleteSegment.
     * DeleteSegment.
     *
     * @param instanceId Format - uuid. Customer Insights instance id
     * @param segmentName Unique name of a segment
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DeleteSegmentHeaders>> deleteSegmentWithServiceResponseAsync(String instanceId, String segmentName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (segmentName == null) {
            throw new IllegalArgumentException("Parameter segmentName is required and cannot be null.");
        }
        return service.deleteSegment(instanceId, segmentName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DeleteSegmentHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DeleteSegmentHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DeleteSegmentHeaders> clientResponse = deleteSegmentDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DeleteSegmentHeaders> deleteSegmentDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<OkResult>() { }.getType())
                .register(400, new TypeToken<ApiError>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, DeleteSegmentHeaders.class);
    }

    /**
     * GetWorkflowJobInformation.
     * GetWorkflowJobInformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAWorkflowJobInformation(String instanceId, String workflowName, String jobId) {
        return getAWorkflowJobInformationWithServiceResponseAsync(instanceId, workflowName, jobId).toBlocking().single().body();
    }

    /**
     * GetWorkflowJobInformation.
     * GetWorkflowJobInformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAWorkflowJobInformationAsync(String instanceId, String workflowName, String jobId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAWorkflowJobInformationWithServiceResponseAsync(instanceId, workflowName, jobId), serviceCallback);
    }

    /**
     * GetWorkflowJobInformation.
     * GetWorkflowJobInformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAWorkflowJobInformationAsync(String instanceId, String workflowName, String jobId) {
        return getAWorkflowJobInformationWithServiceResponseAsync(instanceId, workflowName, jobId).map(new Func1<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetWorkflowJobInformation.
     * GetWorkflowJobInformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>> getAWorkflowJobInformationWithServiceResponseAsync(String instanceId, String workflowName, String jobId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        if (jobId == null) {
            throw new IllegalArgumentException("Parameter jobId is required and cannot be null.");
        }
        final Boolean includeTasks = null;
        return service.getAWorkflowJobInformation(instanceId, workflowName, jobId, includeTasks)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders> clientResponse = getAWorkflowJobInformationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * GetWorkflowJobInformation.
     * GetWorkflowJobInformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @param includeTasks Flag to include tasks or not.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAWorkflowJobInformation(String instanceId, String workflowName, String jobId, Boolean includeTasks) {
        return getAWorkflowJobInformationWithServiceResponseAsync(instanceId, workflowName, jobId, includeTasks).toBlocking().single().body();
    }

    /**
     * GetWorkflowJobInformation.
     * GetWorkflowJobInformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @param includeTasks Flag to include tasks or not.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAWorkflowJobInformationAsync(String instanceId, String workflowName, String jobId, Boolean includeTasks, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAWorkflowJobInformationWithServiceResponseAsync(instanceId, workflowName, jobId, includeTasks), serviceCallback);
    }

    /**
     * GetWorkflowJobInformation.
     * GetWorkflowJobInformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @param includeTasks Flag to include tasks or not.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAWorkflowJobInformationAsync(String instanceId, String workflowName, String jobId, Boolean includeTasks) {
        return getAWorkflowJobInformationWithServiceResponseAsync(instanceId, workflowName, jobId, includeTasks).map(new Func1<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetWorkflowJobInformation.
     * GetWorkflowJobInformation.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @param includeTasks Flag to include tasks or not.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>> getAWorkflowJobInformationWithServiceResponseAsync(String instanceId, String workflowName, String jobId, Boolean includeTasks) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        if (jobId == null) {
            throw new IllegalArgumentException("Parameter jobId is required and cannot be null.");
        }
        return service.getAWorkflowJobInformation(instanceId, workflowName, jobId, includeTasks)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders> clientResponse = getAWorkflowJobInformationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAWorkflowJobInformationHeaders> getAWorkflowJobInformationDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<GraphJobInfo>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAWorkflowJobInformationHeaders.class);
    }

    /**
     * CancelWorkflowJob.
     * Cancel a job.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object cancelAWorkflowJob(String instanceId, String workflowName, String jobId) {
        return cancelAWorkflowJobWithServiceResponseAsync(instanceId, workflowName, jobId).toBlocking().single().body();
    }

    /**
     * CancelWorkflowJob.
     * Cancel a job.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> cancelAWorkflowJobAsync(String instanceId, String workflowName, String jobId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(cancelAWorkflowJobWithServiceResponseAsync(instanceId, workflowName, jobId), serviceCallback);
    }

    /**
     * CancelWorkflowJob.
     * Cancel a job.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> cancelAWorkflowJobAsync(String instanceId, String workflowName, String jobId) {
        return cancelAWorkflowJobWithServiceResponseAsync(instanceId, workflowName, jobId).map(new Func1<ServiceResponseWithHeaders<Object, CancelAWorkflowJobHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CancelAWorkflowJobHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * CancelWorkflowJob.
     * Cancel a job.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param jobId Format - uuid. The job id.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CancelAWorkflowJobHeaders>> cancelAWorkflowJobWithServiceResponseAsync(String instanceId, String workflowName, String jobId) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        if (jobId == null) {
            throw new IllegalArgumentException("Parameter jobId is required and cannot be null.");
        }
        return service.cancelAWorkflowJob(instanceId, workflowName, jobId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CancelAWorkflowJobHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CancelAWorkflowJobHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CancelAWorkflowJobHeaders> clientResponse = cancelAWorkflowJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CancelAWorkflowJobHeaders> cancelAWorkflowJobDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<GraphJobInfo>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, CancelAWorkflowJobHeaders.class);
    }

    /**
     * ListWorkFlowJobs.
     * Retrieves a list of recent job information.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getListOfRecentWorkflowJobs(String instanceId, String workflowName) {
        return getListOfRecentWorkflowJobsWithServiceResponseAsync(instanceId, workflowName).toBlocking().single().body();
    }

    /**
     * ListWorkFlowJobs.
     * Retrieves a list of recent job information.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getListOfRecentWorkflowJobsAsync(String instanceId, String workflowName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getListOfRecentWorkflowJobsWithServiceResponseAsync(instanceId, workflowName), serviceCallback);
    }

    /**
     * ListWorkFlowJobs.
     * Retrieves a list of recent job information.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getListOfRecentWorkflowJobsAsync(String instanceId, String workflowName) {
        return getListOfRecentWorkflowJobsWithServiceResponseAsync(instanceId, workflowName).map(new Func1<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ListWorkFlowJobs.
     * Retrieves a list of recent job information.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>> getListOfRecentWorkflowJobsWithServiceResponseAsync(String instanceId, String workflowName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        final Integer top = null;
        final Boolean includeTasks = null;
        return service.getListOfRecentWorkflowJobs(instanceId, workflowName, top, includeTasks)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders> clientResponse = getListOfRecentWorkflowJobsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * ListWorkFlowJobs.
     * Retrieves a list of recent job information.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of job informations to retrieve.
     * @param includeTasks Flag to include tasks or not.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getListOfRecentWorkflowJobs(String instanceId, String workflowName, Integer top, Boolean includeTasks) {
        return getListOfRecentWorkflowJobsWithServiceResponseAsync(instanceId, workflowName, top, includeTasks).toBlocking().single().body();
    }

    /**
     * ListWorkFlowJobs.
     * Retrieves a list of recent job information.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of job informations to retrieve.
     * @param includeTasks Flag to include tasks or not.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getListOfRecentWorkflowJobsAsync(String instanceId, String workflowName, Integer top, Boolean includeTasks, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getListOfRecentWorkflowJobsWithServiceResponseAsync(instanceId, workflowName, top, includeTasks), serviceCallback);
    }

    /**
     * ListWorkFlowJobs.
     * Retrieves a list of recent job information.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of job informations to retrieve.
     * @param includeTasks Flag to include tasks or not.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getListOfRecentWorkflowJobsAsync(String instanceId, String workflowName, Integer top, Boolean includeTasks) {
        return getListOfRecentWorkflowJobsWithServiceResponseAsync(instanceId, workflowName, top, includeTasks).map(new Func1<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ListWorkFlowJobs.
     * Retrieves a list of recent job information.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of job informations to retrieve.
     * @param includeTasks Flag to include tasks or not.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>> getListOfRecentWorkflowJobsWithServiceResponseAsync(String instanceId, String workflowName, Integer top, Boolean includeTasks) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        return service.getListOfRecentWorkflowJobs(instanceId, workflowName, top, includeTasks)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders> clientResponse = getListOfRecentWorkflowJobsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetListOfRecentWorkflowJobsHeaders> getListOfRecentWorkflowJobsDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GraphJobInfo>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetListOfRecentWorkflowJobsHeaders.class);
    }

    /**
     * SubmitWorkflowJob.
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run.
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object submitAWorkflowJob(String instanceId, String workflowName) {
        return submitAWorkflowJobWithServiceResponseAsync(instanceId, workflowName).toBlocking().single().body();
    }

    /**
     * SubmitWorkflowJob.
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run.
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> submitAWorkflowJobAsync(String instanceId, String workflowName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(submitAWorkflowJobWithServiceResponseAsync(instanceId, workflowName), serviceCallback);
    }

    /**
     * SubmitWorkflowJob.
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run.
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> submitAWorkflowJobAsync(String instanceId, String workflowName) {
        return submitAWorkflowJobWithServiceResponseAsync(instanceId, workflowName).map(new Func1<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * SubmitWorkflowJob.
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run.
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>> submitAWorkflowJobWithServiceResponseAsync(String instanceId, String workflowName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        final InstancesInstanceIdWorkflowsWorkflowNameJobsPostRequest body = null;
        final String operationType = null;
        final List<String> identifiers = null;
        final Boolean forceRunRequested = null;
        String identifiersConverted = this.serializerAdapter().serializeList(identifiers, CollectionFormat.CSV);
        return service.submitAWorkflowJob(instanceId, workflowName, body, operationType, identifiersConverted, forceRunRequested)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders> clientResponse = submitAWorkflowJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * SubmitWorkflowJob.
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run.
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @param body Job Creation Request.
     * @param operationType The workflow operation type.
     * @param identifiers A list of workflow identifiers.
     * @param forceRunRequested Whether to request a force run.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object submitAWorkflowJob(String instanceId, String workflowName, InstancesInstanceIdWorkflowsWorkflowNameJobsPostRequest body, String operationType, List<String> identifiers, Boolean forceRunRequested) {
        return submitAWorkflowJobWithServiceResponseAsync(instanceId, workflowName, body, operationType, identifiers, forceRunRequested).toBlocking().single().body();
    }

    /**
     * SubmitWorkflowJob.
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run.
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @param body Job Creation Request.
     * @param operationType The workflow operation type.
     * @param identifiers A list of workflow identifiers.
     * @param forceRunRequested Whether to request a force run.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> submitAWorkflowJobAsync(String instanceId, String workflowName, InstancesInstanceIdWorkflowsWorkflowNameJobsPostRequest body, String operationType, List<String> identifiers, Boolean forceRunRequested, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(submitAWorkflowJobWithServiceResponseAsync(instanceId, workflowName, body, operationType, identifiers, forceRunRequested), serviceCallback);
    }

    /**
     * SubmitWorkflowJob.
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run.
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @param body Job Creation Request.
     * @param operationType The workflow operation type.
     * @param identifiers A list of workflow identifiers.
     * @param forceRunRequested Whether to request a force run.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> submitAWorkflowJobAsync(String instanceId, String workflowName, InstancesInstanceIdWorkflowsWorkflowNameJobsPostRequest body, String operationType, List<String> identifiers, Boolean forceRunRequested) {
        return submitAWorkflowJobWithServiceResponseAsync(instanceId, workflowName, body, operationType, identifiers, forceRunRequested).map(new Func1<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * SubmitWorkflowJob.
     * Submits a workflow of OperationTypeoperationType for the instance specified in instanceId.
     Optionally takes a list of identifiers, only if operationType is not OperationType.All and a flag
     forceRunRequested indicating whether to force run.
     *
     * @param instanceId Format - uuid. The Customer Insights instance id.
     * @param workflowName The workflow name.
     * @param body Job Creation Request.
     * @param operationType The workflow operation type.
     * @param identifiers A list of workflow identifiers.
     * @param forceRunRequested Whether to request a force run.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>> submitAWorkflowJobWithServiceResponseAsync(String instanceId, String workflowName, InstancesInstanceIdWorkflowsWorkflowNameJobsPostRequest body, String operationType, List<String> identifiers, Boolean forceRunRequested) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        Validator.validate(body);
        Validator.validate(identifiers);
        String identifiersConverted = this.serializerAdapter().serializeList(identifiers, CollectionFormat.CSV);
        return service.submitAWorkflowJob(instanceId, workflowName, body, operationType, identifiersConverted, forceRunRequested)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders> clientResponse = submitAWorkflowJobDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, SubmitAWorkflowJobHeaders> submitAWorkflowJobDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<GraphJobInfo>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, SubmitAWorkflowJobHeaders.class);
    }

    /**
     * ListWorkflowHistory.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getListOfWorkflowTaskInformationHistory(String instanceId, String workflowName) {
        return getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(instanceId, workflowName).toBlocking().single().body();
    }

    /**
     * ListWorkflowHistory.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getListOfWorkflowTaskInformationHistoryAsync(String instanceId, String workflowName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(instanceId, workflowName), serviceCallback);
    }

    /**
     * ListWorkflowHistory.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getListOfWorkflowTaskInformationHistoryAsync(String instanceId, String workflowName) {
        return getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(instanceId, workflowName).map(new Func1<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ListWorkflowHistory.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>> getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(String instanceId, String workflowName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        final Integer top = null;
        return service.getListOfWorkflowTaskInformationHistory(instanceId, workflowName, top)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders> clientResponse = getListOfWorkflowTaskInformationHistoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * ListWorkflowHistory.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of task informations to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getListOfWorkflowTaskInformationHistory(String instanceId, String workflowName, Integer top) {
        return getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(instanceId, workflowName, top).toBlocking().single().body();
    }

    /**
     * ListWorkflowHistory.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of task informations to retrieve.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getListOfWorkflowTaskInformationHistoryAsync(String instanceId, String workflowName, Integer top, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(instanceId, workflowName, top), serviceCallback);
    }

    /**
     * ListWorkflowHistory.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of task informations to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getListOfWorkflowTaskInformationHistoryAsync(String instanceId, String workflowName, Integer top) {
        return getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(instanceId, workflowName, top).map(new Func1<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ListWorkflowHistory.
     * Retrieves a list of historic task information for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The name of the workflow.
     * @param top Format - int32. The number of task informations to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>> getListOfWorkflowTaskInformationHistoryWithServiceResponseAsync(String instanceId, String workflowName, Integer top) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        return service.getListOfWorkflowTaskInformationHistory(instanceId, workflowName, top)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders> clientResponse = getListOfWorkflowTaskInformationHistoryDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetListOfWorkflowTaskInformationHistoryHeaders> getListOfWorkflowTaskInformationHistoryDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GraphTaskInfo>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetListOfWorkflowTaskInformationHistoryHeaders.class);
    }

    /**
     * GetWorkflowStatus.
     * Gets the current status for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getWorkflowStatus(String instanceId, String workflowName) {
        return getWorkflowStatusWithServiceResponseAsync(instanceId, workflowName).toBlocking().single().body();
    }

    /**
     * GetWorkflowStatus.
     * Gets the current status for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The workflow name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getWorkflowStatusAsync(String instanceId, String workflowName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getWorkflowStatusWithServiceResponseAsync(instanceId, workflowName), serviceCallback);
    }

    /**
     * GetWorkflowStatus.
     * Gets the current status for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getWorkflowStatusAsync(String instanceId, String workflowName) {
        return getWorkflowStatusWithServiceResponseAsync(instanceId, workflowName).map(new Func1<ServiceResponseWithHeaders<Object, GetWorkflowStatusHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetWorkflowStatusHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetWorkflowStatus.
     * Gets the current status for a workflow.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName The workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetWorkflowStatusHeaders>> getWorkflowStatusWithServiceResponseAsync(String instanceId, String workflowName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        return service.getWorkflowStatus(instanceId, workflowName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetWorkflowStatusHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetWorkflowStatusHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetWorkflowStatusHeaders> clientResponse = getWorkflowStatusDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetWorkflowStatusHeaders> getWorkflowStatusDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<GraphNodeInfo>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetWorkflowStatusHeaders.class);
    }

    /**
     * ListSupportedTimezones.
     * Gets a list of supported timezones for creating workflow schedules.
     *
     * @param workflowName Any workflow name.
     * @param instanceId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getSupportedTimezones(String workflowName, String instanceId) {
        return getSupportedTimezonesWithServiceResponseAsync(workflowName, instanceId).toBlocking().single().body();
    }

    /**
     * ListSupportedTimezones.
     * Gets a list of supported timezones for creating workflow schedules.
     *
     * @param workflowName Any workflow name.
     * @param instanceId the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getSupportedTimezonesAsync(String workflowName, String instanceId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getSupportedTimezonesWithServiceResponseAsync(workflowName, instanceId), serviceCallback);
    }

    /**
     * ListSupportedTimezones.
     * Gets a list of supported timezones for creating workflow schedules.
     *
     * @param workflowName Any workflow name.
     * @param instanceId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getSupportedTimezonesAsync(String workflowName, String instanceId) {
        return getSupportedTimezonesWithServiceResponseAsync(workflowName, instanceId).map(new Func1<ServiceResponseWithHeaders<Object, GetSupportedTimezonesHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetSupportedTimezonesHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ListSupportedTimezones.
     * Gets a list of supported timezones for creating workflow schedules.
     *
     * @param workflowName Any workflow name.
     * @param instanceId the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetSupportedTimezonesHeaders>> getSupportedTimezonesWithServiceResponseAsync(String workflowName, String instanceId) {
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        return service.getSupportedTimezones(workflowName, instanceId)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetSupportedTimezonesHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetSupportedTimezonesHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetSupportedTimezonesHeaders> clientResponse = getSupportedTimezonesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetSupportedTimezonesHeaders> getSupportedTimezonesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<TimezoneDetail>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetSupportedTimezonesHeaders.class);
    }

    /**
     * ListAllWorkflowSchedules.
     * ListAllWorkflowSchedules.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getWorkflowSchedules(String instanceId, String workflowName) {
        return getWorkflowSchedulesWithServiceResponseAsync(instanceId, workflowName).toBlocking().single().body();
    }

    /**
     * ListAllWorkflowSchedules.
     * ListAllWorkflowSchedules.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getWorkflowSchedulesAsync(String instanceId, String workflowName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getWorkflowSchedulesWithServiceResponseAsync(instanceId, workflowName), serviceCallback);
    }

    /**
     * ListAllWorkflowSchedules.
     * ListAllWorkflowSchedules.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getWorkflowSchedulesAsync(String instanceId, String workflowName) {
        return getWorkflowSchedulesWithServiceResponseAsync(instanceId, workflowName).map(new Func1<ServiceResponseWithHeaders<Object, GetWorkflowSchedulesHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetWorkflowSchedulesHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * ListAllWorkflowSchedules.
     * ListAllWorkflowSchedules.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetWorkflowSchedulesHeaders>> getWorkflowSchedulesWithServiceResponseAsync(String instanceId, String workflowName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        return service.getWorkflowSchedules(instanceId, workflowName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetWorkflowSchedulesHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetWorkflowSchedulesHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetWorkflowSchedulesHeaders> clientResponse = getWorkflowSchedulesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetWorkflowSchedulesHeaders> getWorkflowSchedulesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<List<WorkflowRefreshSchedule>>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetWorkflowSchedulesHeaders.class);
    }

    /**
     * CreateWorkflowRefreshSchedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createWorkflowRefreshSchedule(String instanceId, String workflowName) {
        return createWorkflowRefreshScheduleWithServiceResponseAsync(instanceId, workflowName).toBlocking().single().body();
    }

    /**
     * CreateWorkflowRefreshSchedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createWorkflowRefreshScheduleAsync(String instanceId, String workflowName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createWorkflowRefreshScheduleWithServiceResponseAsync(instanceId, workflowName), serviceCallback);
    }

    /**
     * CreateWorkflowRefreshSchedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createWorkflowRefreshScheduleAsync(String instanceId, String workflowName) {
        return createWorkflowRefreshScheduleWithServiceResponseAsync(instanceId, workflowName).map(new Func1<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * CreateWorkflowRefreshSchedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>> createWorkflowRefreshScheduleWithServiceResponseAsync(String instanceId, String workflowName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        final InstancesInstanceIdWorkflowsWorkflowNameSchedulesPostRequest body = null;
        return service.createWorkflowRefreshSchedule(instanceId, workflowName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders> clientResponse = createWorkflowRefreshScheduleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * CreateWorkflowRefreshSchedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @param body A schedule object to create.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object createWorkflowRefreshSchedule(String instanceId, String workflowName, InstancesInstanceIdWorkflowsWorkflowNameSchedulesPostRequest body) {
        return createWorkflowRefreshScheduleWithServiceResponseAsync(instanceId, workflowName, body).toBlocking().single().body();
    }

    /**
     * CreateWorkflowRefreshSchedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @param body A schedule object to create.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> createWorkflowRefreshScheduleAsync(String instanceId, String workflowName, InstancesInstanceIdWorkflowsWorkflowNameSchedulesPostRequest body, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(createWorkflowRefreshScheduleWithServiceResponseAsync(instanceId, workflowName, body), serviceCallback);
    }

    /**
     * CreateWorkflowRefreshSchedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @param body A schedule object to create.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> createWorkflowRefreshScheduleAsync(String instanceId, String workflowName, InstancesInstanceIdWorkflowsWorkflowNameSchedulesPostRequest body) {
        return createWorkflowRefreshScheduleWithServiceResponseAsync(instanceId, workflowName, body).map(new Func1<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * CreateWorkflowRefreshSchedule.
     * Create a workflow refresh schedule.
     *
     * @param instanceId Format - uuid. The instance id.
     * @param workflowName Any workflow name.
     * @param body A schedule object to create.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>> createWorkflowRefreshScheduleWithServiceResponseAsync(String instanceId, String workflowName, InstancesInstanceIdWorkflowsWorkflowNameSchedulesPostRequest body) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (workflowName == null) {
            throw new IllegalArgumentException("Parameter workflowName is required and cannot be null.");
        }
        Validator.validate(body);
        return service.createWorkflowRefreshSchedule(instanceId, workflowName, body)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders> clientResponse = createWorkflowRefreshScheduleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, CreateWorkflowRefreshScheduleHeaders> createWorkflowRefreshScheduleDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<WorkflowRefreshSchedule>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(500, new TypeToken<ApiErrorResult>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, CreateWorkflowRefreshScheduleHeaders.class);
    }

    /**
     * GetEntityProfile.
     * Gets the entityProfile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getAnEntityProfile(String instanceId, String qualifiedEntityName) {
        return getAnEntityProfileWithServiceResponseAsync(instanceId, qualifiedEntityName).toBlocking().single().body();
    }

    /**
     * GetEntityProfile.
     * Gets the entityProfile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getAnEntityProfileAsync(String instanceId, String qualifiedEntityName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getAnEntityProfileWithServiceResponseAsync(instanceId, qualifiedEntityName), serviceCallback);
    }

    /**
     * GetEntityProfile.
     * Gets the entityProfile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getAnEntityProfileAsync(String instanceId, String qualifiedEntityName) {
        return getAnEntityProfileWithServiceResponseAsync(instanceId, qualifiedEntityName).map(new Func1<ServiceResponseWithHeaders<Object, GetAnEntityProfileHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, GetAnEntityProfileHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * GetEntityProfile.
     * Gets the entityProfile for the entity.
     *
     * @param instanceId Format - uuid. Customer Insights instance id.
     * @param qualifiedEntityName Qualified Entity Name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, GetAnEntityProfileHeaders>> getAnEntityProfileWithServiceResponseAsync(String instanceId, String qualifiedEntityName) {
        if (instanceId == null) {
            throw new IllegalArgumentException("Parameter instanceId is required and cannot be null.");
        }
        if (qualifiedEntityName == null) {
            throw new IllegalArgumentException("Parameter qualifiedEntityName is required and cannot be null.");
        }
        return service.getAnEntityProfile(instanceId, qualifiedEntityName)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, GetAnEntityProfileHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, GetAnEntityProfileHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, GetAnEntityProfileHeaders> clientResponse = getAnEntityProfileDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, GetAnEntityProfileHeaders> getAnEntityProfileDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.serializerAdapter())
                .register(200, new TypeToken<EntityDataProfile>() { }.getType())
                .register(401, new TypeToken<Void>() { }.getType())
                .register(404, new TypeToken<ApiErrorResult>() { }.getType())
                .register(500, new TypeToken<Void>() { }.getType())
                .register(503, new TypeToken<Void>() { }.getType())
                .buildWithHeaders(response, GetAnEntityProfileHeaders.class);
    }

}
