/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import { ServiceClient, ServiceClientOptions, ServiceCallback, HttpOperationResponse } from 'ms-rest';
import * as models from "./models";

export default class CustomerInsights extends ServiceClient {
  /**
   * @class
   * Initializes a new instance of the CustomerInsights class.
   * @constructor
   *
   * @param {string} [baseUri] - The base URI of the service.
   *
   * @param {object} [options] - The parameter options
   *
   * @param {Array} [options.filters] - Filters to be added to the request pipeline
   *
   * @param {object} [options.requestOptions] - Options for the underlying request object
   * {@link https://github.com/request/request#requestoptions-callback Options doc}
   *
   * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
   *
   */
  constructor(baseUri?: string, options?: ServiceClientOptions);


  /**
   * @summary GetAttributeProfile
   *
   * Gets the specific attribute profile for the entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} qualifiedEntityName Qualified Entity Name.
   *
   * @param {string} attributeName Attribute Name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAnAttributeProfileWithHttpOperationResponse(instanceId: string, qualifiedEntityName: string, attributeName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetAttributeProfile
   *
   * Gets the specific attribute profile for the entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} qualifiedEntityName Qualified Entity Name.
   *
   * @param {string} attributeName Attribute Name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAnAttributeProfile(instanceId: string, qualifiedEntityName: string, attributeName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAnAttributeProfile(instanceId: string, qualifiedEntityName: string, attributeName: string, callback: ServiceCallback<any>): void;
  getAnAttributeProfile(instanceId: string, qualifiedEntityName: string, attributeName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetAllDataSources
   *
   * Returns a collections of DataSourceInfo configured for the given Customer
   * Insights instance
   *
   * @param {string} instanceId Format - uuid. The instance id for which to fetch
   * data source info.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllDataSourcesWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetAllDataSources
   *
   * Returns a collections of DataSourceInfo configured for the given Customer
   * Insights instance
   *
   * @param {string} instanceId Format - uuid. The instance id for which to fetch
   * data source info.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllDataSources(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAllDataSources(instanceId: string, callback: ServiceCallback<any>): void;
  getAllDataSources(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetDataSource
   *
   * Fetches a DataSourceInfo matching the dataSourceId configured for the
   * Customer Insights instance.
   *
   * @param {string} instanceId Format - uuid. The instance id to fetch data
   * source info for.
   *
   * @param {string} dataSourceId Format - uuid. The data source id to fetch info
   * for.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getDataSourceWithHttpOperationResponse(instanceId: string, dataSourceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetDataSource
   *
   * Fetches a DataSourceInfo matching the dataSourceId configured for the
   * Customer Insights instance.
   *
   * @param {string} instanceId Format - uuid. The instance id to fetch data
   * source info for.
   *
   * @param {string} dataSourceId Format - uuid. The data source id to fetch info
   * for.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getDataSource(instanceId: string, dataSourceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getDataSource(instanceId: string, dataSourceId: string, callback: ServiceCallback<any>): void;
  getDataSource(instanceId: string, dataSourceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary DeleteDataSource
   *
   * Deletes a data source from the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} dataSourceId Format - uuid. The data source id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteADataSourceWithHttpOperationResponse(instanceId: string, dataSourceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary DeleteDataSource
   *
   * Deletes a data source from the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} dataSourceId Format - uuid. The data source id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteADataSource(instanceId: string, dataSourceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  deleteADataSource(instanceId: string, dataSourceId: string, callback: ServiceCallback<any>): void;
  deleteADataSource(instanceId: string, dataSourceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary CreateEntity (Preview)
   *
   * Writes an entity instance into the store, g. an activity entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance Id.
   *
   * @param {string} entityName Fully qualified entity name, consisting of
   * 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.body] JSON document representing the entity. The
   * schema must be consistent with the entity metadata. Use GET action of this
   * resource to obtain an example.
   *
   * @param {string} [options.validUntil] Format - date-time (as date-time in
   * RFC3339). Expiration time of the change; ISO8601; optional. The value can be
   * maximum 30 days in the future. If the datasource for this entity doesn't
   * contain the changes after this time, the update disappears from the store.
   *
   * @param {string} [options.caller] String to identify the caller; optional.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createAnEntityWithHttpOperationResponse(instanceId: string, entityName: string, options?: { body? : string, validUntil? : string, caller? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary CreateEntity (Preview)
   *
   * Writes an entity instance into the store, g. an activity entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance Id.
   *
   * @param {string} entityName Fully qualified entity name, consisting of
   * 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.body] JSON document representing the entity. The
   * schema must be consistent with the entity metadata. Use GET action of this
   * resource to obtain an example.
   *
   * @param {string} [options.validUntil] Format - date-time (as date-time in
   * RFC3339). Expiration time of the change; ISO8601; optional. The value can be
   * maximum 30 days in the future. If the datasource for this entity doesn't
   * contain the changes after this time, the update disappears from the store.
   *
   * @param {string} [options.caller] String to identify the caller; optional.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createAnEntity(instanceId: string, entityName: string, options?: { body? : string, validUntil? : string, caller? : string, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  createAnEntity(instanceId: string, entityName: string, callback: ServiceCallback<any>): void;
  createAnEntity(instanceId: string, entityName: string, options: { body? : string, validUntil? : string, caller? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary UpdateEntity (Preview)
   *
   * Updates an entity instance in the store, g. Customer entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance Id.
   *
   * @param {string} entityName Fully qualified entity name, e.g. 'Customer'.
   *
   * @param {string} entityId Id of the entity to update, e.g. 'CustomerId' of a
   * Customer entity.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.body] JSON document with set of changes to apply on
   * the entity. Each change must be consistent with the entity metadata. Use GET
   * action of this resource to obtain an example.
   *
   * @param {string} [options.validUntil] Format - date-time (as date-time in
   * RFC3339). Expiration time of the change; ISO8601; optional. The value can be
   * maximum 30 days in the future. If the datasource for this entity doesn't
   * contain the changes after this time, the update disappears from the store.
   *
   * @param {string} [options.caller] String to identify the caller; optional.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateAnEntityWithHttpOperationResponse(instanceId: string, entityName: string, entityId: string, options?: { body? : string, validUntil? : string, caller? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary UpdateEntity (Preview)
   *
   * Updates an entity instance in the store, g. Customer entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance Id.
   *
   * @param {string} entityName Fully qualified entity name, e.g. 'Customer'.
   *
   * @param {string} entityId Id of the entity to update, e.g. 'CustomerId' of a
   * Customer entity.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.body] JSON document with set of changes to apply on
   * the entity. Each change must be consistent with the entity metadata. Use GET
   * action of this resource to obtain an example.
   *
   * @param {string} [options.validUntil] Format - date-time (as date-time in
   * RFC3339). Expiration time of the change; ISO8601; optional. The value can be
   * maximum 30 days in the future. If the datasource for this entity doesn't
   * contain the changes after this time, the update disappears from the store.
   *
   * @param {string} [options.caller] String to identify the caller; optional.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateAnEntity(instanceId: string, entityName: string, entityId: string, options?: { body? : string, validUntil? : string, caller? : string, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  updateAnEntity(instanceId: string, entityName: string, entityId: string, callback: ServiceCallback<any>): void;
  updateAnEntity(instanceId: string, entityName: string, entityId: string, options: { body? : string, validUntil? : string, caller? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetEntityByODataQuery
   *
   * Submits an OData request to the service.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} relativePath Relative OData path. See
   * https://www.odata.org/getting-started/basic-tutorial/ for info.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceSearch] Whether force use search to support
   * the query.
   *
   * @param {boolean} [options.proxy] Whether or not we are requesting data by
   * proxy.
   *
   * @param {string} [options.search] Search OData parameter.
   *
   * @param {string} [options.select] Select OData parameter.
   *
   * @param {string} [options.skip] Skip OData parameter.
   *
   * @param {string} [options.skiptoken] SkipToken OData parameter.
   *
   * @param {string} [options.filter] Filter OData parameter.
   *
   * @param {string} [options.orderby] OrderBy OData parameter.
   *
   * @param {string} [options.expand] Expand OData parameter.
   *
   * @param {string} [options.top] Top OData parameter.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getEntitiesWithODataPathWithHttpOperationResponse(instanceId: string, relativePath: string, options?: { forceSearch? : boolean, proxy? : boolean, search? : string, select? : string, skip? : string, skiptoken? : string, filter? : string, orderby? : string, expand? : string, top? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetEntityByODataQuery
   *
   * Submits an OData request to the service.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} relativePath Relative OData path. See
   * https://www.odata.org/getting-started/basic-tutorial/ for info.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceSearch] Whether force use search to support
   * the query.
   *
   * @param {boolean} [options.proxy] Whether or not we are requesting data by
   * proxy.
   *
   * @param {string} [options.search] Search OData parameter.
   *
   * @param {string} [options.select] Select OData parameter.
   *
   * @param {string} [options.skip] Skip OData parameter.
   *
   * @param {string} [options.skiptoken] SkipToken OData parameter.
   *
   * @param {string} [options.filter] Filter OData parameter.
   *
   * @param {string} [options.orderby] OrderBy OData parameter.
   *
   * @param {string} [options.expand] Expand OData parameter.
   *
   * @param {string} [options.top] Top OData parameter.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntitiesWithODataPath(instanceId: string, relativePath: string, options?: { forceSearch? : boolean, proxy? : boolean, search? : string, select? : string, skip? : string, skiptoken? : string, filter? : string, orderby? : string, expand? : string, top? : string, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getEntitiesWithODataPath(instanceId: string, relativePath: string, callback: ServiceCallback<any>): void;
  getEntitiesWithODataPath(instanceId: string, relativePath: string, options: { forceSearch? : boolean, proxy? : boolean, search? : string, select? : string, skip? : string, skiptoken? : string, filter? : string, orderby? : string, expand? : string, top? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetAllEntitiesMetadata
   *
   * Retrieves the flattened entity model for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.attributesAnnotations] Indicates if extra
   * annotations like 'ReadOnly' or 'Mandatory' should be included.
   *
   * @param {boolean} [options.includeQuarantined] Indicates if corrupt entities
   * should be included in the output entity model.
   *
   * @param {boolean} [options.includeSelfConflatedEntity] Indicates if
   * self-conflated entities should be included in the output entity model.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllEntityMetadataWithHttpOperationResponse(instanceId: string, options?: { attributesAnnotations? : boolean, includeQuarantined? : boolean, includeSelfConflatedEntity? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetAllEntitiesMetadata
   *
   * Retrieves the flattened entity model for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.attributesAnnotations] Indicates if extra
   * annotations like 'ReadOnly' or 'Mandatory' should be included.
   *
   * @param {boolean} [options.includeQuarantined] Indicates if corrupt entities
   * should be included in the output entity model.
   *
   * @param {boolean} [options.includeSelfConflatedEntity] Indicates if
   * self-conflated entities should be included in the output entity model.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllEntityMetadata(instanceId: string, options?: { attributesAnnotations? : boolean, includeQuarantined? : boolean, includeSelfConflatedEntity? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAllEntityMetadata(instanceId: string, callback: ServiceCallback<any>): void;
  getAllEntityMetadata(instanceId: string, options: { attributesAnnotations? : boolean, includeQuarantined? : boolean, includeSelfConflatedEntity? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetEntityMetadata
   *
   * Retrieves the entity metadata for the provided instanceId and entityName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} entityName Entity name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.attributesAnnotations] Indicates if extra
   * annotations like 'ReadOnly' or 'Mandatory' should be included.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getEntityMetadataWithHttpOperationResponse(instanceId: string, entityName: string, options?: { attributesAnnotations? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetEntityMetadata
   *
   * Retrieves the entity metadata for the provided instanceId and entityName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} entityName Entity name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.attributesAnnotations] Indicates if extra
   * annotations like 'ReadOnly' or 'Mandatory' should be included.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntityMetadata(instanceId: string, entityName: string, options?: { attributesAnnotations? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getEntityMetadata(instanceId: string, entityName: string, callback: ServiceCallback<any>): void;
  getEntityMetadata(instanceId: string, entityName: string, options: { attributesAnnotations? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetEntitySize
   *
   * Retrieves the entity size for the provided instanceId and entityName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} entityName Entity name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getEntitySizeWithHttpOperationResponse(instanceId: string, entityName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetEntitySize
   *
   * Retrieves the entity size for the provided instanceId and entityName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} entityName Entity name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntitySize(instanceId: string, entityName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getEntitySize(instanceId: string, entityName: string, callback: ServiceCallback<any>): void;
  getEntitySize(instanceId: string, entityName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary ResetInstance
   *
   * Reset scopes in the given instance. Provide optional management operation
   * scope to reset only that scope.
   *
   * @param {string} instanceId Format - uuid. The instance Id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.instanceManagementOperationScope] The management
   * operation scope for reset.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  resetAnInstanceWithHttpOperationResponse(instanceId: string, options?: { instanceManagementOperationScope? : string, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary ResetInstance
   *
   * Reset scopes in the given instance. Provide optional management operation
   * scope to reset only that scope.
   *
   * @param {string} instanceId Format - uuid. The instance Id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.instanceManagementOperationScope] The management
   * operation scope for reset.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  resetAnInstance(instanceId: string, options?: { instanceManagementOperationScope? : string, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  resetAnInstance(instanceId: string, callback: ServiceCallback<any>): void;
  resetAnInstance(instanceId: string, options: { instanceManagementOperationScope? : string, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary ListAllInstances
   *
   * Retrieves all instances of the current user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllInstancesWithHttpOperationResponse(options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary ListAllInstances
   *
   * Retrieves all instances of the current user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllInstances(options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAllInstances(callback: ServiceCallback<any>): void;
  getAllInstances(options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetInstance
   *
   * Retrieves metadata for a Customer Insights instance based on its instanceId.
   *
   * @param {string} instanceId Format - uuid. Unique id for the Customer
   * Insights instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getInstanceMetadataWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetInstance
   *
   * Retrieves metadata for a Customer Insights instance based on its instanceId.
   *
   * @param {string} instanceId Format - uuid. Unique id for the Customer
   * Insights instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getInstanceMetadata(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getInstanceMetadata(instanceId: string, callback: ServiceCallback<any>): void;
  getInstanceMetadata(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary DeleteInstance
   *
   * Delete an instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteAnInstanceWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary DeleteInstance
   *
   * Delete an instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteAnInstance(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  deleteAnInstance(instanceId: string, callback: ServiceCallback<any>): void;
  deleteAnInstance(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary CreateInstance
   *
   * Creates a new instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The instance creation request.
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress', 'updating',
   * 'quickUpdate', 'deactivated'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production', 'pitchDemo', 'pov'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {boolean} [options.body.instanceMetadata.refreshSchedule.isActive]
   * Gets a value indicating whether the schedule is active.
   *
   * @param {string} [options.body.instanceMetadata.refreshSchedule.timezoneId]
   * Gets the ID of the timezone
   *
   * @param {array} [options.body.instanceMetadata.refreshSchedule.cronSchedules]
   * Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.scheduleId]
   * Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.instanceId]
   * Customer Insights instance id associated with this object.
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.location] Gets
   * region location of Cds Organization
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.environmentSku]
   * Gets SKU of Cds Organization
   *
   * @param {date} [options.body.instanceMetadata.cdsOrgInfo.expirationTime] Gets
   * the expiration time of CDS Organization if the SKU is Trial
   *
   * @param {date}
   * [options.body.instanceMetadata.cdsOrgInfo.maxAllowedExpirationTime] Gets the
   * max allowed expiration time of CDS Organization if the SKU is Trial
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * datalake folder Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds datalake folder unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {boolean} [options.body.instanceMetadata.isRefreshCredentialRequired]
   * Gets a value indicating if credential  is required to refresh any of the
   * datasources
   *
   * @param {array} [options.body.instanceMetadata.trialExtensionDetails] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {number} [options.body.instanceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.instanceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.instanceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.instanceMetadata.createdBy] Email address of
   * the user who created this record.
   *
   * @param {date} [options.body.instanceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.instanceMetadata.instanceId] Customer Insights
   * instance id associated with this object.
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'firstPartyADConnection', 'adlsGen2', 'd365Sales', 'd365Marketing',
   * 'attachCds', 'ftp', 'facebookAds', 'activeCampaign', 'autopilot',
   * 'amlWorkspace', 'mlStudioWebservice', 'adRoll', 'rollWorks',
   * 'constantContact', 'campaignMonitor', 'http', 'dotDigital', 'mailchimp',
   * 'linkedIn', 'googleAds', 'marketo', 'microsoftAds', 'omnisend', 'sendGrid',
   * 'sendinblue', 'snapchat', 'powerBI', 'azureSql', 'synapse'
   *
   * @param {uuid} [options.body.cdsResourceMetadata.resourceId] Gets the Id of
   * the resource.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.operationId] Gets the Id of
   * the operation being performed on the resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.name] Gets the Name of the
   * resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.description] Gets the
   * Description of the resource.
   *
   * @param {number} [options.body.cdsResourceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.cdsResourceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.cdsResourceMetadata.createdBy] Email address
   * of the user who created this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.instanceId] Customer
   * Insights instance id associated with this object.
   *
   * @param {object} [options.body.byoPbiProvisioningInfo]
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageSubscriptionId]
   * Storage account subscriptionId.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageResourceGroup]
   * Storage account Resource Group.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageResourceRegion]
   * Storage account Region.
   *
   * @param {string}
   * [options.body.byoPbiProvisioningInfo.storageResourceTenantId] Storage
   * account tenant.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.capacityId] Pbi
   * Capacity Id.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.delegationToken] PBI
   * delegation token captured from the user.
   *
   * @param {boolean} [options.body.isCdsMdlStorageEnabled]
   *
   * @param {boolean} [options.body.isCiToByosaMigrationEnabled]
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {boolean} [options.body.isPbiProvisioningRequired]
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createAnInstanceWithHttpOperationResponse(options?: { body? : models.InstancesV2PostRequest, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary CreateInstance
   *
   * Creates a new instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The instance creation request.
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress', 'updating',
   * 'quickUpdate', 'deactivated'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production', 'pitchDemo', 'pov'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {boolean} [options.body.instanceMetadata.refreshSchedule.isActive]
   * Gets a value indicating whether the schedule is active.
   *
   * @param {string} [options.body.instanceMetadata.refreshSchedule.timezoneId]
   * Gets the ID of the timezone
   *
   * @param {array} [options.body.instanceMetadata.refreshSchedule.cronSchedules]
   * Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.scheduleId]
   * Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.instanceId]
   * Customer Insights instance id associated with this object.
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.location] Gets
   * region location of Cds Organization
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.environmentSku]
   * Gets SKU of Cds Organization
   *
   * @param {date} [options.body.instanceMetadata.cdsOrgInfo.expirationTime] Gets
   * the expiration time of CDS Organization if the SKU is Trial
   *
   * @param {date}
   * [options.body.instanceMetadata.cdsOrgInfo.maxAllowedExpirationTime] Gets the
   * max allowed expiration time of CDS Organization if the SKU is Trial
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * datalake folder Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds datalake folder unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {boolean} [options.body.instanceMetadata.isRefreshCredentialRequired]
   * Gets a value indicating if credential  is required to refresh any of the
   * datasources
   *
   * @param {array} [options.body.instanceMetadata.trialExtensionDetails] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {number} [options.body.instanceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.instanceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.instanceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.instanceMetadata.createdBy] Email address of
   * the user who created this record.
   *
   * @param {date} [options.body.instanceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.instanceMetadata.instanceId] Customer Insights
   * instance id associated with this object.
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'firstPartyADConnection', 'adlsGen2', 'd365Sales', 'd365Marketing',
   * 'attachCds', 'ftp', 'facebookAds', 'activeCampaign', 'autopilot',
   * 'amlWorkspace', 'mlStudioWebservice', 'adRoll', 'rollWorks',
   * 'constantContact', 'campaignMonitor', 'http', 'dotDigital', 'mailchimp',
   * 'linkedIn', 'googleAds', 'marketo', 'microsoftAds', 'omnisend', 'sendGrid',
   * 'sendinblue', 'snapchat', 'powerBI', 'azureSql', 'synapse'
   *
   * @param {uuid} [options.body.cdsResourceMetadata.resourceId] Gets the Id of
   * the resource.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.operationId] Gets the Id of
   * the operation being performed on the resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.name] Gets the Name of the
   * resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.description] Gets the
   * Description of the resource.
   *
   * @param {number} [options.body.cdsResourceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.cdsResourceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.cdsResourceMetadata.createdBy] Email address
   * of the user who created this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.instanceId] Customer
   * Insights instance id associated with this object.
   *
   * @param {object} [options.body.byoPbiProvisioningInfo]
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageSubscriptionId]
   * Storage account subscriptionId.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageResourceGroup]
   * Storage account Resource Group.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageResourceRegion]
   * Storage account Region.
   *
   * @param {string}
   * [options.body.byoPbiProvisioningInfo.storageResourceTenantId] Storage
   * account tenant.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.capacityId] Pbi
   * Capacity Id.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.delegationToken] PBI
   * delegation token captured from the user.
   *
   * @param {boolean} [options.body.isCdsMdlStorageEnabled]
   *
   * @param {boolean} [options.body.isCiToByosaMigrationEnabled]
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {boolean} [options.body.isPbiProvisioningRequired]
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createAnInstance(options?: { body? : models.InstancesV2PostRequest, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  createAnInstance(callback: ServiceCallback<any>): void;
  createAnInstance(options: { body? : models.InstancesV2PostRequest, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary UpdateInstance.
   *
   * Patches the Market Verticals, Display name, Domain Name, CDS environment and
   * BYOSA secret to the instance. It would trigger a full refresh during CI to
   * CDS MDL migration.
   *
   * @param {string} instanceId Format - uuid.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body]
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress', 'updating',
   * 'quickUpdate', 'deactivated'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production', 'pitchDemo', 'pov'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {boolean} [options.body.instanceMetadata.refreshSchedule.isActive]
   * Gets a value indicating whether the schedule is active.
   *
   * @param {string} [options.body.instanceMetadata.refreshSchedule.timezoneId]
   * Gets the ID of the timezone
   *
   * @param {array} [options.body.instanceMetadata.refreshSchedule.cronSchedules]
   * Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.scheduleId]
   * Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.instanceId]
   * Customer Insights instance id associated with this object.
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.location] Gets
   * region location of Cds Organization
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.environmentSku]
   * Gets SKU of Cds Organization
   *
   * @param {date} [options.body.instanceMetadata.cdsOrgInfo.expirationTime] Gets
   * the expiration time of CDS Organization if the SKU is Trial
   *
   * @param {date}
   * [options.body.instanceMetadata.cdsOrgInfo.maxAllowedExpirationTime] Gets the
   * max allowed expiration time of CDS Organization if the SKU is Trial
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * datalake folder Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds datalake folder unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {boolean} [options.body.instanceMetadata.isRefreshCredentialRequired]
   * Gets a value indicating if credential  is required to refresh any of the
   * datasources
   *
   * @param {array} [options.body.instanceMetadata.trialExtensionDetails] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {number} [options.body.instanceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.instanceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.instanceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.instanceMetadata.createdBy] Email address of
   * the user who created this record.
   *
   * @param {date} [options.body.instanceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.instanceMetadata.instanceId] Customer Insights
   * instance id associated with this object.
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'firstPartyADConnection', 'adlsGen2', 'd365Sales', 'd365Marketing',
   * 'attachCds', 'ftp', 'facebookAds', 'activeCampaign', 'autopilot',
   * 'amlWorkspace', 'mlStudioWebservice', 'adRoll', 'rollWorks',
   * 'constantContact', 'campaignMonitor', 'http', 'dotDigital', 'mailchimp',
   * 'linkedIn', 'googleAds', 'marketo', 'microsoftAds', 'omnisend', 'sendGrid',
   * 'sendinblue', 'snapchat', 'powerBI', 'azureSql', 'synapse'
   *
   * @param {uuid} [options.body.cdsResourceMetadata.resourceId] Gets the Id of
   * the resource.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.operationId] Gets the Id of
   * the operation being performed on the resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.name] Gets the Name of the
   * resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.description] Gets the
   * Description of the resource.
   *
   * @param {number} [options.body.cdsResourceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.cdsResourceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.cdsResourceMetadata.createdBy] Email address
   * of the user who created this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.instanceId] Customer
   * Insights instance id associated with this object.
   *
   * @param {object} [options.body.byoPbiProvisioningInfo]
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageSubscriptionId]
   * Storage account subscriptionId.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageResourceGroup]
   * Storage account Resource Group.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageResourceRegion]
   * Storage account Region.
   *
   * @param {string}
   * [options.body.byoPbiProvisioningInfo.storageResourceTenantId] Storage
   * account tenant.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.capacityId] Pbi
   * Capacity Id.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.delegationToken] PBI
   * delegation token captured from the user.
   *
   * @param {boolean} [options.body.isCdsMdlStorageEnabled]
   *
   * @param {boolean} [options.body.isCiToByosaMigrationEnabled]
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {boolean} [options.body.isPbiProvisioningRequired]
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateAnInstanceWithHttpOperationResponse(instanceId: string, options?: { body? : models.InstancesInstanceIdV2PatchRequest, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary UpdateInstance.
   *
   * Patches the Market Verticals, Display name, Domain Name, CDS environment and
   * BYOSA secret to the instance. It would trigger a full refresh during CI to
   * CDS MDL migration.
   *
   * @param {string} instanceId Format - uuid.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body]
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress', 'updating',
   * 'quickUpdate', 'deactivated'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production', 'pitchDemo', 'pov'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {boolean} [options.body.instanceMetadata.refreshSchedule.isActive]
   * Gets a value indicating whether the schedule is active.
   *
   * @param {string} [options.body.instanceMetadata.refreshSchedule.timezoneId]
   * Gets the ID of the timezone
   *
   * @param {array} [options.body.instanceMetadata.refreshSchedule.cronSchedules]
   * Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.scheduleId]
   * Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.instanceId]
   * Customer Insights instance id associated with this object.
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.location] Gets
   * region location of Cds Organization
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.environmentSku]
   * Gets SKU of Cds Organization
   *
   * @param {date} [options.body.instanceMetadata.cdsOrgInfo.expirationTime] Gets
   * the expiration time of CDS Organization if the SKU is Trial
   *
   * @param {date}
   * [options.body.instanceMetadata.cdsOrgInfo.maxAllowedExpirationTime] Gets the
   * max allowed expiration time of CDS Organization if the SKU is Trial
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * datalake folder Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds datalake folder unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {boolean} [options.body.instanceMetadata.isRefreshCredentialRequired]
   * Gets a value indicating if credential  is required to refresh any of the
   * datasources
   *
   * @param {array} [options.body.instanceMetadata.trialExtensionDetails] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {number} [options.body.instanceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.instanceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.instanceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.instanceMetadata.createdBy] Email address of
   * the user who created this record.
   *
   * @param {date} [options.body.instanceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.instanceMetadata.instanceId] Customer Insights
   * instance id associated with this object.
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'firstPartyADConnection', 'adlsGen2', 'd365Sales', 'd365Marketing',
   * 'attachCds', 'ftp', 'facebookAds', 'activeCampaign', 'autopilot',
   * 'amlWorkspace', 'mlStudioWebservice', 'adRoll', 'rollWorks',
   * 'constantContact', 'campaignMonitor', 'http', 'dotDigital', 'mailchimp',
   * 'linkedIn', 'googleAds', 'marketo', 'microsoftAds', 'omnisend', 'sendGrid',
   * 'sendinblue', 'snapchat', 'powerBI', 'azureSql', 'synapse'
   *
   * @param {uuid} [options.body.cdsResourceMetadata.resourceId] Gets the Id of
   * the resource.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.operationId] Gets the Id of
   * the operation being performed on the resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.name] Gets the Name of the
   * resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.description] Gets the
   * Description of the resource.
   *
   * @param {number} [options.body.cdsResourceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.cdsResourceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.cdsResourceMetadata.createdBy] Email address
   * of the user who created this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.instanceId] Customer
   * Insights instance id associated with this object.
   *
   * @param {object} [options.body.byoPbiProvisioningInfo]
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageSubscriptionId]
   * Storage account subscriptionId.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageResourceGroup]
   * Storage account Resource Group.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageResourceRegion]
   * Storage account Region.
   *
   * @param {string}
   * [options.body.byoPbiProvisioningInfo.storageResourceTenantId] Storage
   * account tenant.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.capacityId] Pbi
   * Capacity Id.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.delegationToken] PBI
   * delegation token captured from the user.
   *
   * @param {boolean} [options.body.isCdsMdlStorageEnabled]
   *
   * @param {boolean} [options.body.isCiToByosaMigrationEnabled]
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {boolean} [options.body.isPbiProvisioningRequired]
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateAnInstance(instanceId: string, options?: { body? : models.InstancesInstanceIdV2PatchRequest, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  updateAnInstance(instanceId: string, callback: ServiceCallback<any>): void;
  updateAnInstance(instanceId: string, options: { body? : models.InstancesInstanceIdV2PatchRequest, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary CopyInstance
   *
   * Create a new instance and copy metadata from an existing instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The metadata to use to create the new
   * instance.
   *
   * @param {uuid} [options.body.instanceIdToCopy]
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress', 'updating',
   * 'quickUpdate', 'deactivated'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production', 'pitchDemo', 'pov'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {boolean} [options.body.instanceMetadata.refreshSchedule.isActive]
   * Gets a value indicating whether the schedule is active.
   *
   * @param {string} [options.body.instanceMetadata.refreshSchedule.timezoneId]
   * Gets the ID of the timezone
   *
   * @param {array} [options.body.instanceMetadata.refreshSchedule.cronSchedules]
   * Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.scheduleId]
   * Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.instanceId]
   * Customer Insights instance id associated with this object.
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.location] Gets
   * region location of Cds Organization
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.environmentSku]
   * Gets SKU of Cds Organization
   *
   * @param {date} [options.body.instanceMetadata.cdsOrgInfo.expirationTime] Gets
   * the expiration time of CDS Organization if the SKU is Trial
   *
   * @param {date}
   * [options.body.instanceMetadata.cdsOrgInfo.maxAllowedExpirationTime] Gets the
   * max allowed expiration time of CDS Organization if the SKU is Trial
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * datalake folder Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds datalake folder unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {boolean} [options.body.instanceMetadata.isRefreshCredentialRequired]
   * Gets a value indicating if credential  is required to refresh any of the
   * datasources
   *
   * @param {array} [options.body.instanceMetadata.trialExtensionDetails] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {number} [options.body.instanceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.instanceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.instanceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.instanceMetadata.createdBy] Email address of
   * the user who created this record.
   *
   * @param {date} [options.body.instanceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.instanceMetadata.instanceId] Customer Insights
   * instance id associated with this object.
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'firstPartyADConnection', 'adlsGen2', 'd365Sales', 'd365Marketing',
   * 'attachCds', 'ftp', 'facebookAds', 'activeCampaign', 'autopilot',
   * 'amlWorkspace', 'mlStudioWebservice', 'adRoll', 'rollWorks',
   * 'constantContact', 'campaignMonitor', 'http', 'dotDigital', 'mailchimp',
   * 'linkedIn', 'googleAds', 'marketo', 'microsoftAds', 'omnisend', 'sendGrid',
   * 'sendinblue', 'snapchat', 'powerBI', 'azureSql', 'synapse'
   *
   * @param {uuid} [options.body.cdsResourceMetadata.resourceId] Gets the Id of
   * the resource.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.operationId] Gets the Id of
   * the operation being performed on the resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.name] Gets the Name of the
   * resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.description] Gets the
   * Description of the resource.
   *
   * @param {number} [options.body.cdsResourceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.cdsResourceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.cdsResourceMetadata.createdBy] Email address
   * of the user who created this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.instanceId] Customer
   * Insights instance id associated with this object.
   *
   * @param {object} [options.body.byoPbiProvisioningInfo]
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageSubscriptionId]
   * Storage account subscriptionId.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageResourceGroup]
   * Storage account Resource Group.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageResourceRegion]
   * Storage account Region.
   *
   * @param {string}
   * [options.body.byoPbiProvisioningInfo.storageResourceTenantId] Storage
   * account tenant.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.capacityId] Pbi
   * Capacity Id.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.delegationToken] PBI
   * delegation token captured from the user.
   *
   * @param {boolean} [options.body.isCdsMdlStorageEnabled]
   *
   * @param {boolean} [options.body.isCiToByosaMigrationEnabled]
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {boolean} [options.body.isPbiProvisioningRequired]
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  copyAnInstanceWithHttpOperationResponse(options?: { body? : models.InstancesCopyPostRequest, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary CopyInstance
   *
   * Create a new instance and copy metadata from an existing instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The metadata to use to create the new
   * instance.
   *
   * @param {uuid} [options.body.instanceIdToCopy]
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress', 'updating',
   * 'quickUpdate', 'deactivated'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production', 'pitchDemo', 'pov'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {boolean} [options.body.instanceMetadata.refreshSchedule.isActive]
   * Gets a value indicating whether the schedule is active.
   *
   * @param {string} [options.body.instanceMetadata.refreshSchedule.timezoneId]
   * Gets the ID of the timezone
   *
   * @param {array} [options.body.instanceMetadata.refreshSchedule.cronSchedules]
   * Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.scheduleId]
   * Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.instanceId]
   * Customer Insights instance id associated with this object.
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.location] Gets
   * region location of Cds Organization
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.environmentSku]
   * Gets SKU of Cds Organization
   *
   * @param {date} [options.body.instanceMetadata.cdsOrgInfo.expirationTime] Gets
   * the expiration time of CDS Organization if the SKU is Trial
   *
   * @param {date}
   * [options.body.instanceMetadata.cdsOrgInfo.maxAllowedExpirationTime] Gets the
   * max allowed expiration time of CDS Organization if the SKU is Trial
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * datalake folder Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds datalake folder unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {boolean} [options.body.instanceMetadata.isRefreshCredentialRequired]
   * Gets a value indicating if credential  is required to refresh any of the
   * datasources
   *
   * @param {array} [options.body.instanceMetadata.trialExtensionDetails] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {number} [options.body.instanceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.instanceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.instanceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.instanceMetadata.createdBy] Email address of
   * the user who created this record.
   *
   * @param {date} [options.body.instanceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.instanceMetadata.instanceId] Customer Insights
   * instance id associated with this object.
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'firstPartyADConnection', 'adlsGen2', 'd365Sales', 'd365Marketing',
   * 'attachCds', 'ftp', 'facebookAds', 'activeCampaign', 'autopilot',
   * 'amlWorkspace', 'mlStudioWebservice', 'adRoll', 'rollWorks',
   * 'constantContact', 'campaignMonitor', 'http', 'dotDigital', 'mailchimp',
   * 'linkedIn', 'googleAds', 'marketo', 'microsoftAds', 'omnisend', 'sendGrid',
   * 'sendinblue', 'snapchat', 'powerBI', 'azureSql', 'synapse'
   *
   * @param {uuid} [options.body.cdsResourceMetadata.resourceId] Gets the Id of
   * the resource.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.operationId] Gets the Id of
   * the operation being performed on the resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.name] Gets the Name of the
   * resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.description] Gets the
   * Description of the resource.
   *
   * @param {number} [options.body.cdsResourceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.cdsResourceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.cdsResourceMetadata.createdBy] Email address
   * of the user who created this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.instanceId] Customer
   * Insights instance id associated with this object.
   *
   * @param {object} [options.body.byoPbiProvisioningInfo]
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageSubscriptionId]
   * Storage account subscriptionId.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageResourceGroup]
   * Storage account Resource Group.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.storageResourceRegion]
   * Storage account Region.
   *
   * @param {string}
   * [options.body.byoPbiProvisioningInfo.storageResourceTenantId] Storage
   * account tenant.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.capacityId] Pbi
   * Capacity Id.
   *
   * @param {string} [options.body.byoPbiProvisioningInfo.delegationToken] PBI
   * delegation token captured from the user.
   *
   * @param {boolean} [options.body.isCdsMdlStorageEnabled]
   *
   * @param {boolean} [options.body.isCiToByosaMigrationEnabled]
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {boolean} [options.body.isPbiProvisioningRequired]
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  copyAnInstance(options?: { body? : models.InstancesCopyPostRequest, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  copyAnInstance(callback: ServiceCallback<any>): void;
  copyAnInstance(options: { body? : models.InstancesCopyPostRequest, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary ListAllMeasuresMetadata
   *
   * ListAllMeasuresMetadata
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.templateSummaryIncluded] whether templated
   * measures are to be included in measure results
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAListOfMeasuresMetadataWithHttpOperationResponse(instanceId: string, options?: { templateSummaryIncluded? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary ListAllMeasuresMetadata
   *
   * ListAllMeasuresMetadata
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.templateSummaryIncluded] whether templated
   * measures are to be included in measure results
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAListOfMeasuresMetadata(instanceId: string, options?: { templateSummaryIncluded? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAListOfMeasuresMetadata(instanceId: string, callback: ServiceCallback<any>): void;
  getAListOfMeasuresMetadata(instanceId: string, options: { templateSummaryIncluded? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary CreateMeasure
   *
   * CreateMeasure
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Measure metadata to be created
   *
   * @param {string} [options.body.displayName]
   *
   * @param {string} [options.body.name] Unique name of the measure
   *
   * @param {string} [options.body.description] Description of the measure.
   *
   * @param {object} [options.body.definition]
   *
   * @param {string} [options.body.definition.kind] Possible values include:
   * 'entity', 'attribute'
   *
   * @param {boolean} [options.body.definition.isScalar] Gets a value indicating
   * whether the current measure is a scalar measure e doesn't have any
   * dimensions
   *
   * @param {array} [options.body.definition.linkedEntities] Gets list of linked
   * entities associated with the measure.
   *
   * @param {array} [options.body.definition.variables] Gets list of variables
   * (computed columns) for the measure.
   *
   * @param {object} [options.body.definition.filters]
   *
   * @param {string} [options.body.definition.filters.kind] Possible values
   * include: 'constant', 'property', 'memberAccess', 'functionCall', 'and',
   * 'or', 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo',
   * 'lessThan', 'lessThanOrEqualTo', 'contains', 'startsWith', 'endsWith',
   * 'isNull', 'isNotNull', 'negate', 'add', 'subtract', 'multiply', 'divide',
   * 'modulo', 'exponent', 'today', 'now'
   *
   * @param {object} [options.body.definition.filteringCriteria]
   *
   * @param {string} [options.body.definition.filteringCriteria.kind] Possible
   * values include: 'default', 'engagement'
   *
   * @param {string} [options.body.definition.filteringCriteria.logicalOperator]
   * Possible values include: 'and', 'or'
   *
   * @param {string} [options.body.definition.filteringCriteria.attribute] Gets
   * the Attribute of the entity used in segment criteria.
   *
   * @param {string}
   * [options.body.definition.filteringCriteria.comparisonOperator] Possible
   * values include: 'equals', 'notEquals', 'greaterThan',
   * 'greaterThanOrEqualTo', 'lessThan', 'lessThanOrEqualTo', 'any', 'contains',
   * 'startsWith', 'endsWith', 'isNull', 'isNotNull', 'all', 'isIn',
   * 'isWithinLast', 'isBetween', 'isNotBetween', 'yearToDate', 'dayOf',
   * 'monthOf', 'yearOf', 'dayOfWeek', 'timeAt'
   *
   * @param {array} [options.body.definition.filteringCriteria.childCriterias]
   * Gets the list of Child criteria of segment.
   *
   * @param {string} [options.body.definition.filteringCriteria.value] Gets the
   * Value in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.ignoreCase] Gets
   * a value indicating whether case is ignored for this criteria.
   *
   * @param {array} [options.body.definition.filteringCriteria.listOfValues] Gets
   * the list of values in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.isTime] flag set
   * to true if entries are of time format
   *
   * @param {array} [options.body.definition.dimensions] Gets list of dimensions
   * with the measure.
   *
   * @param {array} [options.body.definition.aggregates] Gets list of aggregates
   * of the measure.
   *
   * @param {boolean} [options.body.definition.isProfile] Gets a value indicating
   * whether the current measure is a profile measure
   *
   * @param {string} [options.body.definition.measureQuerySql] Gets the user
   * specified custom SQL query.
   *
   * @param {string} [options.body.definition.type] Possible values include:
   * 'structured', 'manual'
   *
   * @param {boolean} [options.body.definition.isManualQueryScalar] Gets the
   * indicating whether the Business Measure is Scalar or not.
   *
   * @param {array} [options.body.definition.dependencies] Gets the list of
   * measures that this measure depends on.
   *
   * @param {object} [options.body.latestEvaluation]
   *
   * @param {uuid} [options.body.latestEvaluation.lastSuccessfulRunId]
   *
   * @param {string} [options.body.latestEvaluation.state] Possible values
   * include: 'none', 'running', 'failed', 'completed'
   *
   * @param {date} [options.body.latestEvaluation.endTime] Evaluation completion
   * time.
   *
   * @param {string} [options.body.latestEvaluation.error] Error Information (if
   * any) that occured during the measure evaluation.
   *
   * @param {object} [options.body.output]
   *
   * @param {object} [options.body.output.values] Output folder path for the
   * evaluation.
   *
   * @param {string} [options.body.output.measureName]
   *
   * @param {date} [options.body.output.evaluationTime] Gets the evaluation start
   * time.
   *
   * @param {object} [options.body.evaluationStats]
   *
   * @param {date} [options.body.evaluationStats.lastSuccessful] Last successful
   * evaluation
   *
   * @param {number} [options.body.evaluationStats.consecutiveFailureCount]
   * Represents Number of consecutive failures
   *
   * @param {object} [options.body.errorDescription]
   *
   * @param {string} [options.body.errorDescription.value]
   *
   * @param {string} [options.body.errorDescription.key] Possible values include:
   * 'activityMappingDuplicateMappingOnEntity', 'activityMappingEmptyInput',
   * 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.errorDescription.args]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationHistory] Evaluation history for the
   * measure. (not persisted in store)
   *
   * @param {array} [options.body.outputHistory] Output history for the measure.
   * (not persisted in store)
   *
   * @param {boolean} [options.body.isTemplate] Check if measure metadata is a
   * template
   *
   * @param {uuid} [options.body.templateId] Gets the template ID for templates
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createAMeasureWithHttpOperationResponse(instanceId: string, options?: { body? : models.InstancesInstanceIdManageMeasuresPostRequest, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary CreateMeasure
   *
   * CreateMeasure
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Measure metadata to be created
   *
   * @param {string} [options.body.displayName]
   *
   * @param {string} [options.body.name] Unique name of the measure
   *
   * @param {string} [options.body.description] Description of the measure.
   *
   * @param {object} [options.body.definition]
   *
   * @param {string} [options.body.definition.kind] Possible values include:
   * 'entity', 'attribute'
   *
   * @param {boolean} [options.body.definition.isScalar] Gets a value indicating
   * whether the current measure is a scalar measure e doesn't have any
   * dimensions
   *
   * @param {array} [options.body.definition.linkedEntities] Gets list of linked
   * entities associated with the measure.
   *
   * @param {array} [options.body.definition.variables] Gets list of variables
   * (computed columns) for the measure.
   *
   * @param {object} [options.body.definition.filters]
   *
   * @param {string} [options.body.definition.filters.kind] Possible values
   * include: 'constant', 'property', 'memberAccess', 'functionCall', 'and',
   * 'or', 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo',
   * 'lessThan', 'lessThanOrEqualTo', 'contains', 'startsWith', 'endsWith',
   * 'isNull', 'isNotNull', 'negate', 'add', 'subtract', 'multiply', 'divide',
   * 'modulo', 'exponent', 'today', 'now'
   *
   * @param {object} [options.body.definition.filteringCriteria]
   *
   * @param {string} [options.body.definition.filteringCriteria.kind] Possible
   * values include: 'default', 'engagement'
   *
   * @param {string} [options.body.definition.filteringCriteria.logicalOperator]
   * Possible values include: 'and', 'or'
   *
   * @param {string} [options.body.definition.filteringCriteria.attribute] Gets
   * the Attribute of the entity used in segment criteria.
   *
   * @param {string}
   * [options.body.definition.filteringCriteria.comparisonOperator] Possible
   * values include: 'equals', 'notEquals', 'greaterThan',
   * 'greaterThanOrEqualTo', 'lessThan', 'lessThanOrEqualTo', 'any', 'contains',
   * 'startsWith', 'endsWith', 'isNull', 'isNotNull', 'all', 'isIn',
   * 'isWithinLast', 'isBetween', 'isNotBetween', 'yearToDate', 'dayOf',
   * 'monthOf', 'yearOf', 'dayOfWeek', 'timeAt'
   *
   * @param {array} [options.body.definition.filteringCriteria.childCriterias]
   * Gets the list of Child criteria of segment.
   *
   * @param {string} [options.body.definition.filteringCriteria.value] Gets the
   * Value in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.ignoreCase] Gets
   * a value indicating whether case is ignored for this criteria.
   *
   * @param {array} [options.body.definition.filteringCriteria.listOfValues] Gets
   * the list of values in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.isTime] flag set
   * to true if entries are of time format
   *
   * @param {array} [options.body.definition.dimensions] Gets list of dimensions
   * with the measure.
   *
   * @param {array} [options.body.definition.aggregates] Gets list of aggregates
   * of the measure.
   *
   * @param {boolean} [options.body.definition.isProfile] Gets a value indicating
   * whether the current measure is a profile measure
   *
   * @param {string} [options.body.definition.measureQuerySql] Gets the user
   * specified custom SQL query.
   *
   * @param {string} [options.body.definition.type] Possible values include:
   * 'structured', 'manual'
   *
   * @param {boolean} [options.body.definition.isManualQueryScalar] Gets the
   * indicating whether the Business Measure is Scalar or not.
   *
   * @param {array} [options.body.definition.dependencies] Gets the list of
   * measures that this measure depends on.
   *
   * @param {object} [options.body.latestEvaluation]
   *
   * @param {uuid} [options.body.latestEvaluation.lastSuccessfulRunId]
   *
   * @param {string} [options.body.latestEvaluation.state] Possible values
   * include: 'none', 'running', 'failed', 'completed'
   *
   * @param {date} [options.body.latestEvaluation.endTime] Evaluation completion
   * time.
   *
   * @param {string} [options.body.latestEvaluation.error] Error Information (if
   * any) that occured during the measure evaluation.
   *
   * @param {object} [options.body.output]
   *
   * @param {object} [options.body.output.values] Output folder path for the
   * evaluation.
   *
   * @param {string} [options.body.output.measureName]
   *
   * @param {date} [options.body.output.evaluationTime] Gets the evaluation start
   * time.
   *
   * @param {object} [options.body.evaluationStats]
   *
   * @param {date} [options.body.evaluationStats.lastSuccessful] Last successful
   * evaluation
   *
   * @param {number} [options.body.evaluationStats.consecutiveFailureCount]
   * Represents Number of consecutive failures
   *
   * @param {object} [options.body.errorDescription]
   *
   * @param {string} [options.body.errorDescription.value]
   *
   * @param {string} [options.body.errorDescription.key] Possible values include:
   * 'activityMappingDuplicateMappingOnEntity', 'activityMappingEmptyInput',
   * 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.errorDescription.args]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationHistory] Evaluation history for the
   * measure. (not persisted in store)
   *
   * @param {array} [options.body.outputHistory] Output history for the measure.
   * (not persisted in store)
   *
   * @param {boolean} [options.body.isTemplate] Check if measure metadata is a
   * template
   *
   * @param {uuid} [options.body.templateId] Gets the template ID for templates
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createAMeasure(instanceId: string, options?: { body? : models.InstancesInstanceIdManageMeasuresPostRequest, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  createAMeasure(instanceId: string, callback: ServiceCallback<any>): void;
  createAMeasure(instanceId: string, options: { body? : models.InstancesInstanceIdManageMeasuresPostRequest, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetMeasureMetadata
   *
   * Retrieves the measure metadata for the provided instanceId and measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeHistoricStats] Boolean for historical stats
   *
   * @param {number} [options.historicStatsDays] Format - int32. Number of
   * lookback days
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getMetadataForAMeasureWithHttpOperationResponse(instanceId: string, measureName: string, options?: { includeHistoricStats? : boolean, historicStatsDays? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetMeasureMetadata
   *
   * Retrieves the measure metadata for the provided instanceId and measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeHistoricStats] Boolean for historical stats
   *
   * @param {number} [options.historicStatsDays] Format - int32. Number of
   * lookback days
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getMetadataForAMeasure(instanceId: string, measureName: string, options?: { includeHistoricStats? : boolean, historicStatsDays? : number, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getMetadataForAMeasure(instanceId: string, measureName: string, callback: ServiceCallback<any>): void;
  getMetadataForAMeasure(instanceId: string, measureName: string, options: { includeHistoricStats? : boolean, historicStatsDays? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary UpdateMeasure
   *
   * Updates measures metadata for the provided instanceId and measureMetadata.
   * Existing measure is retrieved using measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] Update measure metadata
   *
   * @param {string} [options.body.displayName]
   *
   * @param {string} [options.body.name] Unique name of the measure
   *
   * @param {string} [options.body.description] Description of the measure.
   *
   * @param {object} [options.body.definition]
   *
   * @param {string} [options.body.definition.kind] Possible values include:
   * 'entity', 'attribute'
   *
   * @param {boolean} [options.body.definition.isScalar] Gets a value indicating
   * whether the current measure is a scalar measure e doesn't have any
   * dimensions
   *
   * @param {array} [options.body.definition.linkedEntities] Gets list of linked
   * entities associated with the measure.
   *
   * @param {array} [options.body.definition.variables] Gets list of variables
   * (computed columns) for the measure.
   *
   * @param {object} [options.body.definition.filters]
   *
   * @param {string} [options.body.definition.filters.kind] Possible values
   * include: 'constant', 'property', 'memberAccess', 'functionCall', 'and',
   * 'or', 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo',
   * 'lessThan', 'lessThanOrEqualTo', 'contains', 'startsWith', 'endsWith',
   * 'isNull', 'isNotNull', 'negate', 'add', 'subtract', 'multiply', 'divide',
   * 'modulo', 'exponent', 'today', 'now'
   *
   * @param {object} [options.body.definition.filteringCriteria]
   *
   * @param {string} [options.body.definition.filteringCriteria.kind] Possible
   * values include: 'default', 'engagement'
   *
   * @param {string} [options.body.definition.filteringCriteria.logicalOperator]
   * Possible values include: 'and', 'or'
   *
   * @param {string} [options.body.definition.filteringCriteria.attribute] Gets
   * the Attribute of the entity used in segment criteria.
   *
   * @param {string}
   * [options.body.definition.filteringCriteria.comparisonOperator] Possible
   * values include: 'equals', 'notEquals', 'greaterThan',
   * 'greaterThanOrEqualTo', 'lessThan', 'lessThanOrEqualTo', 'any', 'contains',
   * 'startsWith', 'endsWith', 'isNull', 'isNotNull', 'all', 'isIn',
   * 'isWithinLast', 'isBetween', 'isNotBetween', 'yearToDate', 'dayOf',
   * 'monthOf', 'yearOf', 'dayOfWeek', 'timeAt'
   *
   * @param {array} [options.body.definition.filteringCriteria.childCriterias]
   * Gets the list of Child criteria of segment.
   *
   * @param {string} [options.body.definition.filteringCriteria.value] Gets the
   * Value in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.ignoreCase] Gets
   * a value indicating whether case is ignored for this criteria.
   *
   * @param {array} [options.body.definition.filteringCriteria.listOfValues] Gets
   * the list of values in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.isTime] flag set
   * to true if entries are of time format
   *
   * @param {array} [options.body.definition.dimensions] Gets list of dimensions
   * with the measure.
   *
   * @param {array} [options.body.definition.aggregates] Gets list of aggregates
   * of the measure.
   *
   * @param {boolean} [options.body.definition.isProfile] Gets a value indicating
   * whether the current measure is a profile measure
   *
   * @param {string} [options.body.definition.measureQuerySql] Gets the user
   * specified custom SQL query.
   *
   * @param {string} [options.body.definition.type] Possible values include:
   * 'structured', 'manual'
   *
   * @param {boolean} [options.body.definition.isManualQueryScalar] Gets the
   * indicating whether the Business Measure is Scalar or not.
   *
   * @param {array} [options.body.definition.dependencies] Gets the list of
   * measures that this measure depends on.
   *
   * @param {object} [options.body.latestEvaluation]
   *
   * @param {uuid} [options.body.latestEvaluation.lastSuccessfulRunId]
   *
   * @param {string} [options.body.latestEvaluation.state] Possible values
   * include: 'none', 'running', 'failed', 'completed'
   *
   * @param {date} [options.body.latestEvaluation.endTime] Evaluation completion
   * time.
   *
   * @param {string} [options.body.latestEvaluation.error] Error Information (if
   * any) that occured during the measure evaluation.
   *
   * @param {object} [options.body.output]
   *
   * @param {object} [options.body.output.values] Output folder path for the
   * evaluation.
   *
   * @param {string} [options.body.output.measureName]
   *
   * @param {date} [options.body.output.evaluationTime] Gets the evaluation start
   * time.
   *
   * @param {object} [options.body.evaluationStats]
   *
   * @param {date} [options.body.evaluationStats.lastSuccessful] Last successful
   * evaluation
   *
   * @param {number} [options.body.evaluationStats.consecutiveFailureCount]
   * Represents Number of consecutive failures
   *
   * @param {object} [options.body.errorDescription]
   *
   * @param {string} [options.body.errorDescription.value]
   *
   * @param {string} [options.body.errorDescription.key] Possible values include:
   * 'activityMappingDuplicateMappingOnEntity', 'activityMappingEmptyInput',
   * 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.errorDescription.args]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationHistory] Evaluation history for the
   * measure. (not persisted in store)
   *
   * @param {array} [options.body.outputHistory] Output history for the measure.
   * (not persisted in store)
   *
   * @param {boolean} [options.body.isTemplate] Check if measure metadata is a
   * template
   *
   * @param {uuid} [options.body.templateId] Gets the template ID for templates
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateAMeasureWithHttpOperationResponse(instanceId: string, measureName: string, options?: { body? : models.InstancesInstanceIdManageMeasuresMeasureNamePutRequest, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary UpdateMeasure
   *
   * Updates measures metadata for the provided instanceId and measureMetadata.
   * Existing measure is retrieved using measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] Update measure metadata
   *
   * @param {string} [options.body.displayName]
   *
   * @param {string} [options.body.name] Unique name of the measure
   *
   * @param {string} [options.body.description] Description of the measure.
   *
   * @param {object} [options.body.definition]
   *
   * @param {string} [options.body.definition.kind] Possible values include:
   * 'entity', 'attribute'
   *
   * @param {boolean} [options.body.definition.isScalar] Gets a value indicating
   * whether the current measure is a scalar measure e doesn't have any
   * dimensions
   *
   * @param {array} [options.body.definition.linkedEntities] Gets list of linked
   * entities associated with the measure.
   *
   * @param {array} [options.body.definition.variables] Gets list of variables
   * (computed columns) for the measure.
   *
   * @param {object} [options.body.definition.filters]
   *
   * @param {string} [options.body.definition.filters.kind] Possible values
   * include: 'constant', 'property', 'memberAccess', 'functionCall', 'and',
   * 'or', 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo',
   * 'lessThan', 'lessThanOrEqualTo', 'contains', 'startsWith', 'endsWith',
   * 'isNull', 'isNotNull', 'negate', 'add', 'subtract', 'multiply', 'divide',
   * 'modulo', 'exponent', 'today', 'now'
   *
   * @param {object} [options.body.definition.filteringCriteria]
   *
   * @param {string} [options.body.definition.filteringCriteria.kind] Possible
   * values include: 'default', 'engagement'
   *
   * @param {string} [options.body.definition.filteringCriteria.logicalOperator]
   * Possible values include: 'and', 'or'
   *
   * @param {string} [options.body.definition.filteringCriteria.attribute] Gets
   * the Attribute of the entity used in segment criteria.
   *
   * @param {string}
   * [options.body.definition.filteringCriteria.comparisonOperator] Possible
   * values include: 'equals', 'notEquals', 'greaterThan',
   * 'greaterThanOrEqualTo', 'lessThan', 'lessThanOrEqualTo', 'any', 'contains',
   * 'startsWith', 'endsWith', 'isNull', 'isNotNull', 'all', 'isIn',
   * 'isWithinLast', 'isBetween', 'isNotBetween', 'yearToDate', 'dayOf',
   * 'monthOf', 'yearOf', 'dayOfWeek', 'timeAt'
   *
   * @param {array} [options.body.definition.filteringCriteria.childCriterias]
   * Gets the list of Child criteria of segment.
   *
   * @param {string} [options.body.definition.filteringCriteria.value] Gets the
   * Value in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.ignoreCase] Gets
   * a value indicating whether case is ignored for this criteria.
   *
   * @param {array} [options.body.definition.filteringCriteria.listOfValues] Gets
   * the list of values in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.isTime] flag set
   * to true if entries are of time format
   *
   * @param {array} [options.body.definition.dimensions] Gets list of dimensions
   * with the measure.
   *
   * @param {array} [options.body.definition.aggregates] Gets list of aggregates
   * of the measure.
   *
   * @param {boolean} [options.body.definition.isProfile] Gets a value indicating
   * whether the current measure is a profile measure
   *
   * @param {string} [options.body.definition.measureQuerySql] Gets the user
   * specified custom SQL query.
   *
   * @param {string} [options.body.definition.type] Possible values include:
   * 'structured', 'manual'
   *
   * @param {boolean} [options.body.definition.isManualQueryScalar] Gets the
   * indicating whether the Business Measure is Scalar or not.
   *
   * @param {array} [options.body.definition.dependencies] Gets the list of
   * measures that this measure depends on.
   *
   * @param {object} [options.body.latestEvaluation]
   *
   * @param {uuid} [options.body.latestEvaluation.lastSuccessfulRunId]
   *
   * @param {string} [options.body.latestEvaluation.state] Possible values
   * include: 'none', 'running', 'failed', 'completed'
   *
   * @param {date} [options.body.latestEvaluation.endTime] Evaluation completion
   * time.
   *
   * @param {string} [options.body.latestEvaluation.error] Error Information (if
   * any) that occured during the measure evaluation.
   *
   * @param {object} [options.body.output]
   *
   * @param {object} [options.body.output.values] Output folder path for the
   * evaluation.
   *
   * @param {string} [options.body.output.measureName]
   *
   * @param {date} [options.body.output.evaluationTime] Gets the evaluation start
   * time.
   *
   * @param {object} [options.body.evaluationStats]
   *
   * @param {date} [options.body.evaluationStats.lastSuccessful] Last successful
   * evaluation
   *
   * @param {number} [options.body.evaluationStats.consecutiveFailureCount]
   * Represents Number of consecutive failures
   *
   * @param {object} [options.body.errorDescription]
   *
   * @param {string} [options.body.errorDescription.value]
   *
   * @param {string} [options.body.errorDescription.key] Possible values include:
   * 'activityMappingDuplicateMappingOnEntity', 'activityMappingEmptyInput',
   * 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.errorDescription.args]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationHistory] Evaluation history for the
   * measure. (not persisted in store)
   *
   * @param {array} [options.body.outputHistory] Output history for the measure.
   * (not persisted in store)
   *
   * @param {boolean} [options.body.isTemplate] Check if measure metadata is a
   * template
   *
   * @param {uuid} [options.body.templateId] Gets the template ID for templates
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateAMeasure(instanceId: string, measureName: string, options?: { body? : models.InstancesInstanceIdManageMeasuresMeasureNamePutRequest, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  updateAMeasure(instanceId: string, measureName: string, callback: ServiceCallback<any>): void;
  updateAMeasure(instanceId: string, measureName: string, options: { body? : models.InstancesInstanceIdManageMeasuresMeasureNamePutRequest, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary DeleteMeasure
   *
   * Deletes the measure metadata for the provided instanceId using measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteAMeasureWithHttpOperationResponse(instanceId: string, measureName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary DeleteMeasure
   *
   * Deletes the measure metadata for the provided instanceId using measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteAMeasure(instanceId: string, measureName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  deleteAMeasure(instanceId: string, measureName: string, callback: ServiceCallback<any>): void;
  deleteAMeasure(instanceId: string, measureName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetKeyRing
   *
   * Gets the KeyRing (collection of all alternate keys) for the given instance
   * by alternate key.
   *
   * @param {string} instanceId Format - uuid. Identifier for the instance
   *
   * @param {string} dataSourceName The name of the datasource that contains the
   * given entity.
   *
   * @param {string} entityName The name of the entity that contains the given
   * key.
   *
   * @param {string} key The value of the alternate key provided.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getKeyRingWithHttpOperationResponse(instanceId: string, dataSourceName: string, entityName: string, key: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetKeyRing
   *
   * Gets the KeyRing (collection of all alternate keys) for the given instance
   * by alternate key.
   *
   * @param {string} instanceId Format - uuid. Identifier for the instance
   *
   * @param {string} dataSourceName The name of the datasource that contains the
   * given entity.
   *
   * @param {string} entityName The name of the entity that contains the given
   * key.
   *
   * @param {string} key The value of the alternate key provided.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getKeyRing(instanceId: string, dataSourceName: string, entityName: string, key: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getKeyRing(instanceId: string, dataSourceName: string, entityName: string, key: string, callback: ServiceCallback<any>): void;
  getKeyRing(instanceId: string, dataSourceName: string, entityName: string, key: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetProfileStoreState
   *
   * Gets the profile store state infoformation.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getProfileStoreStateWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetProfileStoreState
   *
   * Gets the profile store state infoformation.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getProfileStoreState(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getProfileStoreState(instanceId: string, callback: ServiceCallback<any>): void;
  getProfileStoreState(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary ListAllRoles
   *
   * Get all role definitions.
   *
   * @param {string} instanceId
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllRoleDefinitionsWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.RoleDefinition[]>>;

  /**
   * @summary ListAllRoles
   *
   * Get all role definitions.
   *
   * @param {string} instanceId
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllRoleDefinitions(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.RoleDefinition[]>;
  getAllRoleDefinitions(instanceId: string, callback: ServiceCallback<models.RoleDefinition[]>): void;
  getAllRoleDefinitions(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.RoleDefinition[]>): void;


  /**
   * @summary GetCurrentUserRole
   *
   * Get role of current user.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RoleAssignment>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getCurrentUserRoleWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.RoleAssignment>>;

  /**
   * @summary GetCurrentUserRole
   *
   * Get role of current user.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {RoleAssignment} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {RoleAssignment} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RoleAssignment} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getCurrentUserRole(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.RoleAssignment>;
  getCurrentUserRole(instanceId: string, callback: ServiceCallback<models.RoleAssignment>): void;
  getCurrentUserRole(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.RoleAssignment>): void;


  /**
   * @summary UpdateRoleAssignment
   *
   * Adds or updates a role assignment for a principal.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} principalId The principal id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The role assignment.
   *
   * @param {string} [options.body.principalId] Gets the Id of the principal.
   *
   * @param {string} [options.body.principalType] Possible values include:
   * 'user', 'group', 'app'
   *
   * @param {array} [options.body.roles] Gets the roles the principal belongs to.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateARoleAssignmentWithHttpOperationResponse(instanceId: string, principalId: string, options?: { body? : models.InstancesInstanceIdRbacPrincipalsPrincipalIdAssignmentPutRequest, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.RoleAssignment[]>>;

  /**
   * @summary UpdateRoleAssignment
   *
   * Adds or updates a role assignment for a principal.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} principalId The principal id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The role assignment.
   *
   * @param {string} [options.body.principalId] Gets the Id of the principal.
   *
   * @param {string} [options.body.principalType] Possible values include:
   * 'user', 'group', 'app'
   *
   * @param {array} [options.body.roles] Gets the roles the principal belongs to.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateARoleAssignment(instanceId: string, principalId: string, options?: { body? : models.InstancesInstanceIdRbacPrincipalsPrincipalIdAssignmentPutRequest, customHeaders? : { [headerName: string]: string; } }): Promise<models.RoleAssignment[]>;
  updateARoleAssignment(instanceId: string, principalId: string, callback: ServiceCallback<models.RoleAssignment[]>): void;
  updateARoleAssignment(instanceId: string, principalId: string, options: { body? : models.InstancesInstanceIdRbacPrincipalsPrincipalIdAssignmentPutRequest, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.RoleAssignment[]>): void;


  /**
   * @summary DeleteRoleAssignment
   *
   * Deletes a role assignment for the principal.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} principalId The principal id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deletesARoleAssignmentWithHttpOperationResponse(instanceId: string, principalId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary DeleteRoleAssignment
   *
   * Deletes a role assignment for the principal.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} principalId The principal id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deletesARoleAssignment(instanceId: string, principalId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  deletesARoleAssignment(instanceId: string, principalId: string, callback: ServiceCallback<void>): void;
  deletesARoleAssignment(instanceId: string, principalId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary ListAllRoleAssignments
   *
   * Gets all role assignments for the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllRoleAssignmentsWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.RoleAssignment[]>>;

  /**
   * @summary ListAllRoleAssignments
   *
   * Gets all role assignments for the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllRoleAssignments(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.RoleAssignment[]>;
  getAllRoleAssignments(instanceId: string, callback: ServiceCallback<models.RoleAssignment[]>): void;
  getAllRoleAssignments(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.RoleAssignment[]>): void;


  /**
   * @summary ListAllRelationships
   *
   * Gets all relationship metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllRelationshipsWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary ListAllRelationships
   *
   * Gets all relationship metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllRelationships(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAllRelationships(instanceId: string, callback: ServiceCallback<any>): void;
  getAllRelationships(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary CreateRelationship
   *
   * Creates new relationship metadata for the provided instanceId, using input.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The updated relationship metadata
   *
   * @param {string} [options.body.friendlyName] Gets the friendly name of the
   * relationship.
   *
   * @param {string} [options.body.name] Gets the unique name for relationship
   *
   * @param {string} [options.body.description] Gets the description for
   * relationship
   *
   * @param {string} [options.body.relationshipType] Possible values include:
   * 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
   * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
   *
   * @param {string} [options.body.fromAttributeName] Gets the name of the
   * foreign key reference attribute that this relationship originates from.
   *
   * @param {string} [options.body.fromEntityName] Gets the name of the entity
   * this relationship originates from.
   *
   * @param {string} [options.body.toAttributeName] Gets the name of the foreign
   * key attribute that this relationship points to.
   *
   * @param {string} [options.body.toEntityName] Gets the name of the entity this
   * relationship points to.
   *
   * @param {string} [options.body.cardinality] Possible values include:
   * 'oneToMany', 'oneToOne', 'manyToOne'
   *
   * @param {string} [options.body.source] Possible values include: 'user',
   * 'system', 'inferred'
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createARelationshipWithHttpOperationResponse(instanceId: string, options?: { body? : models.InstancesInstanceIdManageRelationshipsPostRequest, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary CreateRelationship
   *
   * Creates new relationship metadata for the provided instanceId, using input.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The updated relationship metadata
   *
   * @param {string} [options.body.friendlyName] Gets the friendly name of the
   * relationship.
   *
   * @param {string} [options.body.name] Gets the unique name for relationship
   *
   * @param {string} [options.body.description] Gets the description for
   * relationship
   *
   * @param {string} [options.body.relationshipType] Possible values include:
   * 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
   * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
   *
   * @param {string} [options.body.fromAttributeName] Gets the name of the
   * foreign key reference attribute that this relationship originates from.
   *
   * @param {string} [options.body.fromEntityName] Gets the name of the entity
   * this relationship originates from.
   *
   * @param {string} [options.body.toAttributeName] Gets the name of the foreign
   * key attribute that this relationship points to.
   *
   * @param {string} [options.body.toEntityName] Gets the name of the entity this
   * relationship points to.
   *
   * @param {string} [options.body.cardinality] Possible values include:
   * 'oneToMany', 'oneToOne', 'manyToOne'
   *
   * @param {string} [options.body.source] Possible values include: 'user',
   * 'system', 'inferred'
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createARelationship(instanceId: string, options?: { body? : models.InstancesInstanceIdManageRelationshipsPostRequest, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  createARelationship(instanceId: string, callback: ServiceCallback<any>): void;
  createARelationship(instanceId: string, options: { body? : models.InstancesInstanceIdManageRelationshipsPostRequest, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetRelationship
   *
   * Gets the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getARelationshipWithHttpOperationResponse(instanceId: string, relationshipName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetRelationship
   *
   * Gets the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getARelationship(instanceId: string, relationshipName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getARelationship(instanceId: string, relationshipName: string, callback: ServiceCallback<any>): void;
  getARelationship(instanceId: string, relationshipName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary DeleteRelationship
   *
   * Deletes the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteARelationshipWithHttpOperationResponse(instanceId: string, relationshipName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary DeleteRelationship
   *
   * Deletes the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteARelationship(instanceId: string, relationshipName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  deleteARelationship(instanceId: string, relationshipName: string, callback: ServiceCallback<any>): void;
  deleteARelationship(instanceId: string, relationshipName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary UpdateRelationshhip
   *
   * Updates the relationship metadata for the provided instanceId and
   * relationshipName, using input.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The updated relationship metadata
   *
   * @param {string} [options.body.friendlyName] Gets the friendly name of the
   * relationship.
   *
   * @param {string} [options.body.name] Gets the unique name for relationship
   *
   * @param {string} [options.body.description] Gets the description for
   * relationship
   *
   * @param {string} [options.body.relationshipType] Possible values include:
   * 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
   * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
   *
   * @param {string} [options.body.fromAttributeName] Gets the name of the
   * foreign key reference attribute that this relationship originates from.
   *
   * @param {string} [options.body.fromEntityName] Gets the name of the entity
   * this relationship originates from.
   *
   * @param {string} [options.body.toAttributeName] Gets the name of the foreign
   * key attribute that this relationship points to.
   *
   * @param {string} [options.body.toEntityName] Gets the name of the entity this
   * relationship points to.
   *
   * @param {string} [options.body.cardinality] Possible values include:
   * 'oneToMany', 'oneToOne', 'manyToOne'
   *
   * @param {string} [options.body.source] Possible values include: 'user',
   * 'system', 'inferred'
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateARelationshipWithHttpOperationResponse(instanceId: string, relationshipName: string, options?: { body? : models.InstancesInstanceIdManageRelationshipsRelationshipNamePutRequest, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary UpdateRelationshhip
   *
   * Updates the relationship metadata for the provided instanceId and
   * relationshipName, using input.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The updated relationship metadata
   *
   * @param {string} [options.body.friendlyName] Gets the friendly name of the
   * relationship.
   *
   * @param {string} [options.body.name] Gets the unique name for relationship
   *
   * @param {string} [options.body.description] Gets the description for
   * relationship
   *
   * @param {string} [options.body.relationshipType] Possible values include:
   * 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
   * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
   *
   * @param {string} [options.body.fromAttributeName] Gets the name of the
   * foreign key reference attribute that this relationship originates from.
   *
   * @param {string} [options.body.fromEntityName] Gets the name of the entity
   * this relationship originates from.
   *
   * @param {string} [options.body.toAttributeName] Gets the name of the foreign
   * key attribute that this relationship points to.
   *
   * @param {string} [options.body.toEntityName] Gets the name of the entity this
   * relationship points to.
   *
   * @param {string} [options.body.cardinality] Possible values include:
   * 'oneToMany', 'oneToOne', 'manyToOne'
   *
   * @param {string} [options.body.source] Possible values include: 'user',
   * 'system', 'inferred'
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateARelationship(instanceId: string, relationshipName: string, options?: { body? : models.InstancesInstanceIdManageRelationshipsRelationshipNamePutRequest, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  updateARelationship(instanceId: string, relationshipName: string, callback: ServiceCallback<any>): void;
  updateARelationship(instanceId: string, relationshipName: string, options: { body? : models.InstancesInstanceIdManageRelationshipsRelationshipNamePutRequest, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetSearchConfiguration
   *
   * Gets the search configuration for the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getSearchConfigurationWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetSearchConfiguration
   *
   * Gets the search configuration for the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getSearchConfiguration(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getSearchConfiguration(instanceId: string, callback: ServiceCallback<any>): void;
  getSearchConfiguration(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary UpdateSearchConfiguration
   *
   * UpdateSearchConfiguration
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The search configuration for the instance.
   *
   * @param {array} [options.body.entityConfig] Gets search configurations for
   * entities
   *
   * @param {boolean} [options.body.isSystemGenerated] Gets a value indicating
   * whether the configuration was system generated
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateSearchConfigurationWithHttpOperationResponse(instanceId: string, options?: { body? : models.InstancesInstanceIdManageSearchPutRequest, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary UpdateSearchConfiguration
   *
   * UpdateSearchConfiguration
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The search configuration for the instance.
   *
   * @param {array} [options.body.entityConfig] Gets search configurations for
   * entities
   *
   * @param {boolean} [options.body.isSystemGenerated] Gets a value indicating
   * whether the configuration was system generated
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateSearchConfiguration(instanceId: string, options?: { body? : models.InstancesInstanceIdManageSearchPutRequest, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  updateSearchConfiguration(instanceId: string, callback: ServiceCallback<any>): void;
  updateSearchConfiguration(instanceId: string, options: { body? : models.InstancesInstanceIdManageSearchPutRequest, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary ListAllSegments
   *
   * Retrieves a list of segment metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeHistoricStats] Optional parameter to
   * retrieve evaluation history of all the sgements in instanceId.
   *
   * @param {number} [options.historicStatsDays] Format - int32. Optional
   * parameter to get number of days evaluation history.
   *
   * @param {number} [options.numberOfSegments] Format - int32. Optional
   * parameter to limit the number of segments returned.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllSegmentsWithHttpOperationResponse(instanceId: string, options?: { includeHistoricStats? : boolean, historicStatsDays? : number, numberOfSegments? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary ListAllSegments
   *
   * Retrieves a list of segment metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeHistoricStats] Optional parameter to
   * retrieve evaluation history of all the sgements in instanceId.
   *
   * @param {number} [options.historicStatsDays] Format - int32. Optional
   * parameter to get number of days evaluation history.
   *
   * @param {number} [options.numberOfSegments] Format - int32. Optional
   * parameter to limit the number of segments returned.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllSegments(instanceId: string, options?: { includeHistoricStats? : boolean, historicStatsDays? : number, numberOfSegments? : number, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAllSegments(instanceId: string, callback: ServiceCallback<any>): void;
  getAllSegments(instanceId: string, options: { includeHistoricStats? : boolean, historicStatsDays? : number, numberOfSegments? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary CreateSegment
   *
   * CreateSegment
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Segment metadata to be created
   *
   * @param {string} [options.body.kind] Possible values include: 'default',
   * 'engagement'
   *
   * @param {string} [options.body.name] Gets the unique name of the segment
   *
   * @param {string} [options.body.friendlyName] Gets the friendlyName of the
   * segment.
   *
   * @param {string} [options.body.description] Gets the description of the
   * segment.
   *
   * @param {object} [options.body.segmentQueryExpression]
   *
   * @param {string} [options.body.segmentQueryExpression.type] Possible values
   * include: 'structured', 'manual'
   *
   * @param {array} [options.body.segmentQueryExpression.projections] Gets list
   * of attributes to be projected in segment. (DEPRECATED)
   *
   * @param {array} [options.body.segmentQueryExpression.projectedAttributes]
   * Gets list of attributes to be projected in segment.
   *
   * @param {array} [options.body.segmentQueryExpression.rowsets] Gets list of
   * rowsets of segment.
   *
   * @param {string} [options.body.segmentQueryExpression.segmentationQuerySql]
   * Gets the user specified custom SQL query.
   *
   * @param {string} [options.body.state] Possible values include: 'inactive',
   * 'active', 'validating', 'validated', 'invalid', 'validationError'
   *
   * @param {string} [options.body.errorDescription] Gets the error description
   * when the segment metadata has some issues after refresh.
   *
   * @param {date} [options.body.endDate] Gets the end date of the segment.
   *
   * @param {object} [options.body.evaluationStatus]
   *
   * @param {string} [options.body.evaluationStatus.jobStatus] Possible values
   * include: 'None', 'Queued', 'Running', 'CompletedSuccess',
   * 'CompletedFailure', 'Cancelled', 'Interrupted', 'NotQualified'
   *
   * @param {date} [options.body.evaluationStatus.evaluationDate]
   *
   * @param {number} [options.body.evaluationStatus.entityCount]
   *
   * @param {object} [options.body.evaluationStatus.error]
   *
   * @param {string} [options.body.evaluationStatus.error.value]
   *
   * @param {string} [options.body.evaluationStatus.error.key] Possible values
   * include: 'activityMappingDuplicateMappingOnEntity',
   * 'activityMappingEmptyInput', 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.evaluationStatus.error.args]
   *
   * @param {uuid} [options.body.evaluationStatus.lastSuccessfulRunId]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationStatusHistory] Gets the segment
   * evaluation status history. (not persisted in store)
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createASegmentWithHttpOperationResponse(instanceId: string, options?: { body? : models.InstancesInstanceIdManageSegmentsPostRequest, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary CreateSegment
   *
   * CreateSegment
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Segment metadata to be created
   *
   * @param {string} [options.body.kind] Possible values include: 'default',
   * 'engagement'
   *
   * @param {string} [options.body.name] Gets the unique name of the segment
   *
   * @param {string} [options.body.friendlyName] Gets the friendlyName of the
   * segment.
   *
   * @param {string} [options.body.description] Gets the description of the
   * segment.
   *
   * @param {object} [options.body.segmentQueryExpression]
   *
   * @param {string} [options.body.segmentQueryExpression.type] Possible values
   * include: 'structured', 'manual'
   *
   * @param {array} [options.body.segmentQueryExpression.projections] Gets list
   * of attributes to be projected in segment. (DEPRECATED)
   *
   * @param {array} [options.body.segmentQueryExpression.projectedAttributes]
   * Gets list of attributes to be projected in segment.
   *
   * @param {array} [options.body.segmentQueryExpression.rowsets] Gets list of
   * rowsets of segment.
   *
   * @param {string} [options.body.segmentQueryExpression.segmentationQuerySql]
   * Gets the user specified custom SQL query.
   *
   * @param {string} [options.body.state] Possible values include: 'inactive',
   * 'active', 'validating', 'validated', 'invalid', 'validationError'
   *
   * @param {string} [options.body.errorDescription] Gets the error description
   * when the segment metadata has some issues after refresh.
   *
   * @param {date} [options.body.endDate] Gets the end date of the segment.
   *
   * @param {object} [options.body.evaluationStatus]
   *
   * @param {string} [options.body.evaluationStatus.jobStatus] Possible values
   * include: 'None', 'Queued', 'Running', 'CompletedSuccess',
   * 'CompletedFailure', 'Cancelled', 'Interrupted', 'NotQualified'
   *
   * @param {date} [options.body.evaluationStatus.evaluationDate]
   *
   * @param {number} [options.body.evaluationStatus.entityCount]
   *
   * @param {object} [options.body.evaluationStatus.error]
   *
   * @param {string} [options.body.evaluationStatus.error.value]
   *
   * @param {string} [options.body.evaluationStatus.error.key] Possible values
   * include: 'activityMappingDuplicateMappingOnEntity',
   * 'activityMappingEmptyInput', 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.evaluationStatus.error.args]
   *
   * @param {uuid} [options.body.evaluationStatus.lastSuccessfulRunId]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationStatusHistory] Gets the segment
   * evaluation status history. (not persisted in store)
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createASegment(instanceId: string, options?: { body? : models.InstancesInstanceIdManageSegmentsPostRequest, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  createASegment(instanceId: string, callback: ServiceCallback<any>): void;
  createASegment(instanceId: string, options: { body? : models.InstancesInstanceIdManageSegmentsPostRequest, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary ActivateSegment
   *
   * Activate segment on instanceId with segmentName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  activateSegmentWithHttpOperationResponse(instanceId: string, segmentName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary ActivateSegment
   *
   * Activate segment on instanceId with segmentName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  activateSegment(instanceId: string, segmentName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  activateSegment(instanceId: string, segmentName: string, callback: ServiceCallback<any>): void;
  activateSegment(instanceId: string, segmentName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary DeactivateSegment
   *
   * Deactivate segment on instanceId with segmentName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deactivateSegmentWithHttpOperationResponse(instanceId: string, segmentName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary DeactivateSegment
   *
   * Deactivate segment on instanceId with segmentName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deactivateSegment(instanceId: string, segmentName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  deactivateSegment(instanceId: string, segmentName: string, callback: ServiceCallback<any>): void;
  deactivateSegment(instanceId: string, segmentName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary UpdateSegments
   *
   * Updates segment metadata for the provided instanceId and segmentName with
   * segmentMetadata.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Segment metadata to be updated
   *
   * @param {string} [options.body.kind] Possible values include: 'default',
   * 'engagement'
   *
   * @param {string} [options.body.name] Gets the unique name of the segment
   *
   * @param {string} [options.body.friendlyName] Gets the friendlyName of the
   * segment.
   *
   * @param {string} [options.body.description] Gets the description of the
   * segment.
   *
   * @param {object} [options.body.segmentQueryExpression]
   *
   * @param {string} [options.body.segmentQueryExpression.type] Possible values
   * include: 'structured', 'manual'
   *
   * @param {array} [options.body.segmentQueryExpression.projections] Gets list
   * of attributes to be projected in segment. (DEPRECATED)
   *
   * @param {array} [options.body.segmentQueryExpression.projectedAttributes]
   * Gets list of attributes to be projected in segment.
   *
   * @param {array} [options.body.segmentQueryExpression.rowsets] Gets list of
   * rowsets of segment.
   *
   * @param {string} [options.body.segmentQueryExpression.segmentationQuerySql]
   * Gets the user specified custom SQL query.
   *
   * @param {string} [options.body.state] Possible values include: 'inactive',
   * 'active', 'validating', 'validated', 'invalid', 'validationError'
   *
   * @param {string} [options.body.errorDescription] Gets the error description
   * when the segment metadata has some issues after refresh.
   *
   * @param {date} [options.body.endDate] Gets the end date of the segment.
   *
   * @param {object} [options.body.evaluationStatus]
   *
   * @param {string} [options.body.evaluationStatus.jobStatus] Possible values
   * include: 'None', 'Queued', 'Running', 'CompletedSuccess',
   * 'CompletedFailure', 'Cancelled', 'Interrupted', 'NotQualified'
   *
   * @param {date} [options.body.evaluationStatus.evaluationDate]
   *
   * @param {number} [options.body.evaluationStatus.entityCount]
   *
   * @param {object} [options.body.evaluationStatus.error]
   *
   * @param {string} [options.body.evaluationStatus.error.value]
   *
   * @param {string} [options.body.evaluationStatus.error.key] Possible values
   * include: 'activityMappingDuplicateMappingOnEntity',
   * 'activityMappingEmptyInput', 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.evaluationStatus.error.args]
   *
   * @param {uuid} [options.body.evaluationStatus.lastSuccessfulRunId]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationStatusHistory] Gets the segment
   * evaluation status history. (not persisted in store)
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  updateASegmentWithHttpOperationResponse(instanceId: string, segmentName: string, options?: { body? : models.InstancesInstanceIdManageSegmentsSegmentNamePutRequest, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary UpdateSegments
   *
   * Updates segment metadata for the provided instanceId and segmentName with
   * segmentMetadata.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Segment metadata to be updated
   *
   * @param {string} [options.body.kind] Possible values include: 'default',
   * 'engagement'
   *
   * @param {string} [options.body.name] Gets the unique name of the segment
   *
   * @param {string} [options.body.friendlyName] Gets the friendlyName of the
   * segment.
   *
   * @param {string} [options.body.description] Gets the description of the
   * segment.
   *
   * @param {object} [options.body.segmentQueryExpression]
   *
   * @param {string} [options.body.segmentQueryExpression.type] Possible values
   * include: 'structured', 'manual'
   *
   * @param {array} [options.body.segmentQueryExpression.projections] Gets list
   * of attributes to be projected in segment. (DEPRECATED)
   *
   * @param {array} [options.body.segmentQueryExpression.projectedAttributes]
   * Gets list of attributes to be projected in segment.
   *
   * @param {array} [options.body.segmentQueryExpression.rowsets] Gets list of
   * rowsets of segment.
   *
   * @param {string} [options.body.segmentQueryExpression.segmentationQuerySql]
   * Gets the user specified custom SQL query.
   *
   * @param {string} [options.body.state] Possible values include: 'inactive',
   * 'active', 'validating', 'validated', 'invalid', 'validationError'
   *
   * @param {string} [options.body.errorDescription] Gets the error description
   * when the segment metadata has some issues after refresh.
   *
   * @param {date} [options.body.endDate] Gets the end date of the segment.
   *
   * @param {object} [options.body.evaluationStatus]
   *
   * @param {string} [options.body.evaluationStatus.jobStatus] Possible values
   * include: 'None', 'Queued', 'Running', 'CompletedSuccess',
   * 'CompletedFailure', 'Cancelled', 'Interrupted', 'NotQualified'
   *
   * @param {date} [options.body.evaluationStatus.evaluationDate]
   *
   * @param {number} [options.body.evaluationStatus.entityCount]
   *
   * @param {object} [options.body.evaluationStatus.error]
   *
   * @param {string} [options.body.evaluationStatus.error.value]
   *
   * @param {string} [options.body.evaluationStatus.error.key] Possible values
   * include: 'activityMappingDuplicateMappingOnEntity',
   * 'activityMappingEmptyInput', 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.evaluationStatus.error.args]
   *
   * @param {uuid} [options.body.evaluationStatus.lastSuccessfulRunId]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationStatusHistory] Gets the segment
   * evaluation status history. (not persisted in store)
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  updateASegment(instanceId: string, segmentName: string, options?: { body? : models.InstancesInstanceIdManageSegmentsSegmentNamePutRequest, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  updateASegment(instanceId: string, segmentName: string, callback: ServiceCallback<any>): void;
  updateASegment(instanceId: string, segmentName: string, options: { body? : models.InstancesInstanceIdManageSegmentsSegmentNamePutRequest, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary DeleteSegment
   *
   * DeleteSegment
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteSegmentWithHttpOperationResponse(instanceId: string, segmentName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary DeleteSegment
   *
   * DeleteSegment
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteSegment(instanceId: string, segmentName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  deleteSegment(instanceId: string, segmentName: string, callback: ServiceCallback<any>): void;
  deleteSegment(instanceId: string, segmentName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetWorkflowJobInformation
   *
   * GetWorkflowJobInformation
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {string} jobId Format - uuid. The job id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeTasks] Flag to include tasks or not.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAWorkflowJobInformationWithHttpOperationResponse(instanceId: string, workflowName: string, jobId: string, options?: { includeTasks? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetWorkflowJobInformation
   *
   * GetWorkflowJobInformation
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {string} jobId Format - uuid. The job id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeTasks] Flag to include tasks or not.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAWorkflowJobInformation(instanceId: string, workflowName: string, jobId: string, options?: { includeTasks? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAWorkflowJobInformation(instanceId: string, workflowName: string, jobId: string, callback: ServiceCallback<any>): void;
  getAWorkflowJobInformation(instanceId: string, workflowName: string, jobId: string, options: { includeTasks? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary CancelWorkflowJob
   *
   * Cancel a job.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {string} jobId Format - uuid. The job id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  cancelAWorkflowJobWithHttpOperationResponse(instanceId: string, workflowName: string, jobId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary CancelWorkflowJob
   *
   * Cancel a job.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {string} jobId Format - uuid. The job id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  cancelAWorkflowJob(instanceId: string, workflowName: string, jobId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  cancelAWorkflowJob(instanceId: string, workflowName: string, jobId: string, callback: ServiceCallback<any>): void;
  cancelAWorkflowJob(instanceId: string, workflowName: string, jobId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary ListWorkFlowJobs
   *
   * Retrieves a list of recent job information.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.top] Format - int32. The number of job informations
   * to retrieve.
   *
   * @param {boolean} [options.includeTasks] Flag to include tasks or not.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getListOfRecentWorkflowJobsWithHttpOperationResponse(instanceId: string, workflowName: string, options?: { top? : number, includeTasks? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary ListWorkFlowJobs
   *
   * Retrieves a list of recent job information.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.top] Format - int32. The number of job informations
   * to retrieve.
   *
   * @param {boolean} [options.includeTasks] Flag to include tasks or not.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getListOfRecentWorkflowJobs(instanceId: string, workflowName: string, options?: { top? : number, includeTasks? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getListOfRecentWorkflowJobs(instanceId: string, workflowName: string, callback: ServiceCallback<any>): void;
  getListOfRecentWorkflowJobs(instanceId: string, workflowName: string, options: { top? : number, includeTasks? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary SubmitWorkflowJob
   *
   * Submits a workflow of OperationTypeoperationType for the instance specified
   * in instanceId.
   * Optionally takes a list of identifiers, only if operationType is not
   * OperationType.All and a flag
   * forceRunRequested indicating whether to force run.
   *
   * @param {string} instanceId Format - uuid. The Customer Insights instance id.
   *
   * @param {string} workflowName The workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] Job Creation Request.
   *
   * @param {string} [options.body.graphName]
   *
   * @param {string} [options.body.operationType] Possible values include:
   * 'none', 'ingestion', 'derivedEntity', 'hierarchy', 'dataPreparation', 'map',
   * 'realtimeM3Search', 'match', 'merge', 'profileStore', 'search', 'activity',
   * 'attributeMeasures', 'entityMeasures', 'measures', 'segmentation',
   * 'segmentMembership', 'enrichment', 'intelligence', 'aiBuilder', 'insights',
   * 'export', 'modelManagement', 'relationship', 'roleAssignment', 'analysis',
   * 'all'
   *
   * @param {string} [options.body.submissionKind] Possible values include:
   * 'onDemand', 'scheduled'
   *
   * @param {string} [options.body.jobType] Possible values include: 'full',
   * 'incremental'
   *
   * @param {array} [options.body.identifiers]
   *
   * @param {boolean} [options.body.forceRunRequested]
   *
   * @param {string} [options.body.inputRefreshMode] Possible values include:
   * 'FailedOrModifiedRecursive', 'FailedRecursive', 'FailedOrModified',
   * 'Failed', 'None'
   *
   * @param {object} [options.body.options]
   *
   * @param {boolean} [options.body.options.runDownstreamAfterMerge]
   *
   * @param {string} [options.operationType] The workflow operation type.
   *
   * @param {array} [options.identifiers] A list of workflow identifiers.
   *
   * @param {boolean} [options.forceRunRequested] Whether to request a force run.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  submitAWorkflowJobWithHttpOperationResponse(instanceId: string, workflowName: string, options?: { body? : models.InstancesInstanceIdWorkflowsWorkflowNameJobsPostRequest, operationType? : string, identifiers? : string[], forceRunRequested? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary SubmitWorkflowJob
   *
   * Submits a workflow of OperationTypeoperationType for the instance specified
   * in instanceId.
   * Optionally takes a list of identifiers, only if operationType is not
   * OperationType.All and a flag
   * forceRunRequested indicating whether to force run.
   *
   * @param {string} instanceId Format - uuid. The Customer Insights instance id.
   *
   * @param {string} workflowName The workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] Job Creation Request.
   *
   * @param {string} [options.body.graphName]
   *
   * @param {string} [options.body.operationType] Possible values include:
   * 'none', 'ingestion', 'derivedEntity', 'hierarchy', 'dataPreparation', 'map',
   * 'realtimeM3Search', 'match', 'merge', 'profileStore', 'search', 'activity',
   * 'attributeMeasures', 'entityMeasures', 'measures', 'segmentation',
   * 'segmentMembership', 'enrichment', 'intelligence', 'aiBuilder', 'insights',
   * 'export', 'modelManagement', 'relationship', 'roleAssignment', 'analysis',
   * 'all'
   *
   * @param {string} [options.body.submissionKind] Possible values include:
   * 'onDemand', 'scheduled'
   *
   * @param {string} [options.body.jobType] Possible values include: 'full',
   * 'incremental'
   *
   * @param {array} [options.body.identifiers]
   *
   * @param {boolean} [options.body.forceRunRequested]
   *
   * @param {string} [options.body.inputRefreshMode] Possible values include:
   * 'FailedOrModifiedRecursive', 'FailedRecursive', 'FailedOrModified',
   * 'Failed', 'None'
   *
   * @param {object} [options.body.options]
   *
   * @param {boolean} [options.body.options.runDownstreamAfterMerge]
   *
   * @param {string} [options.operationType] The workflow operation type.
   *
   * @param {array} [options.identifiers] A list of workflow identifiers.
   *
   * @param {boolean} [options.forceRunRequested] Whether to request a force run.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  submitAWorkflowJob(instanceId: string, workflowName: string, options?: { body? : models.InstancesInstanceIdWorkflowsWorkflowNameJobsPostRequest, operationType? : string, identifiers? : string[], forceRunRequested? : boolean, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  submitAWorkflowJob(instanceId: string, workflowName: string, callback: ServiceCallback<any>): void;
  submitAWorkflowJob(instanceId: string, workflowName: string, options: { body? : models.InstancesInstanceIdWorkflowsWorkflowNameJobsPostRequest, operationType? : string, identifiers? : string[], forceRunRequested? : boolean, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary ListWorkflowHistory
   *
   * Retrieves a list of historic task information for a workflow.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.top] Format - int32. The number of task
   * informations to retrieve.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getListOfWorkflowTaskInformationHistoryWithHttpOperationResponse(instanceId: string, workflowName: string, options?: { top? : number, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary ListWorkflowHistory
   *
   * Retrieves a list of historic task information for a workflow.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.top] Format - int32. The number of task
   * informations to retrieve.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getListOfWorkflowTaskInformationHistory(instanceId: string, workflowName: string, options?: { top? : number, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getListOfWorkflowTaskInformationHistory(instanceId: string, workflowName: string, callback: ServiceCallback<any>): void;
  getListOfWorkflowTaskInformationHistory(instanceId: string, workflowName: string, options: { top? : number, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetWorkflowStatus
   *
   * Gets the current status for a workflow.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getWorkflowStatusWithHttpOperationResponse(instanceId: string, workflowName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetWorkflowStatus
   *
   * Gets the current status for a workflow.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getWorkflowStatus(instanceId: string, workflowName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getWorkflowStatus(instanceId: string, workflowName: string, callback: ServiceCallback<any>): void;
  getWorkflowStatus(instanceId: string, workflowName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary ListSupportedTimezones
   *
   * Gets a list of supported timezones for creating workflow schedules.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {string} instanceId
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getSupportedTimezonesWithHttpOperationResponse(workflowName: string, instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary ListSupportedTimezones
   *
   * Gets a list of supported timezones for creating workflow schedules.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {string} instanceId
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getSupportedTimezones(workflowName: string, instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getSupportedTimezones(workflowName: string, instanceId: string, callback: ServiceCallback<any>): void;
  getSupportedTimezones(workflowName: string, instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary ListAllWorkflowSchedules
   *
   * ListAllWorkflowSchedules
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getWorkflowSchedulesWithHttpOperationResponse(instanceId: string, workflowName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary ListAllWorkflowSchedules
   *
   * ListAllWorkflowSchedules
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getWorkflowSchedules(instanceId: string, workflowName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getWorkflowSchedules(instanceId: string, workflowName: string, callback: ServiceCallback<any>): void;
  getWorkflowSchedules(instanceId: string, workflowName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary CreateWorkflowRefreshSchedule
   *
   * Create a workflow refresh schedule.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] A schedule object to create.
   *
   * @param {string} [options.body.operationType] Possible values include:
   * 'none', 'ingestion', 'derivedEntity', 'hierarchy', 'dataPreparation', 'map',
   * 'realtimeM3Search', 'match', 'merge', 'profileStore', 'search', 'activity',
   * 'attributeMeasures', 'entityMeasures', 'measures', 'segmentation',
   * 'segmentMembership', 'enrichment', 'intelligence', 'aiBuilder', 'insights',
   * 'export', 'modelManagement', 'relationship', 'roleAssignment', 'analysis',
   * 'all'
   *
   * @param {string} [options.body.subType] Possible values include: 'noSubType',
   * 'templatedMeasures', 'createAnalysisModel', 'linkAnalysisModel',
   * 'singleActivityMapping', 'powerPlatform'
   *
   * @param {array} [options.body.identifiers] Gets the identifiers of the
   * schedule
   *
   * @param {string} [options.body.jobType] Possible values include: 'full',
   * 'incremental'
   *
   * @param {boolean} [options.body.isActive] Gets a value indicating whether the
   * schedule is active.
   *
   * @param {string} [options.body.timezoneId] Gets the ID of the timezone
   *
   * @param {array} [options.body.cronSchedules] Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.scheduleId] Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createWorkflowRefreshScheduleWithHttpOperationResponse(instanceId: string, workflowName: string, options?: { body? : models.InstancesInstanceIdWorkflowsWorkflowNameSchedulesPostRequest, customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary CreateWorkflowRefreshSchedule
   *
   * Create a workflow refresh schedule.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] A schedule object to create.
   *
   * @param {string} [options.body.operationType] Possible values include:
   * 'none', 'ingestion', 'derivedEntity', 'hierarchy', 'dataPreparation', 'map',
   * 'realtimeM3Search', 'match', 'merge', 'profileStore', 'search', 'activity',
   * 'attributeMeasures', 'entityMeasures', 'measures', 'segmentation',
   * 'segmentMembership', 'enrichment', 'intelligence', 'aiBuilder', 'insights',
   * 'export', 'modelManagement', 'relationship', 'roleAssignment', 'analysis',
   * 'all'
   *
   * @param {string} [options.body.subType] Possible values include: 'noSubType',
   * 'templatedMeasures', 'createAnalysisModel', 'linkAnalysisModel',
   * 'singleActivityMapping', 'powerPlatform'
   *
   * @param {array} [options.body.identifiers] Gets the identifiers of the
   * schedule
   *
   * @param {string} [options.body.jobType] Possible values include: 'full',
   * 'incremental'
   *
   * @param {boolean} [options.body.isActive] Gets a value indicating whether the
   * schedule is active.
   *
   * @param {string} [options.body.timezoneId] Gets the ID of the timezone
   *
   * @param {array} [options.body.cronSchedules] Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.scheduleId] Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createWorkflowRefreshSchedule(instanceId: string, workflowName: string, options?: { body? : models.InstancesInstanceIdWorkflowsWorkflowNameSchedulesPostRequest, customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  createWorkflowRefreshSchedule(instanceId: string, workflowName: string, callback: ServiceCallback<any>): void;
  createWorkflowRefreshSchedule(instanceId: string, workflowName: string, options: { body? : models.InstancesInstanceIdWorkflowsWorkflowNameSchedulesPostRequest, customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetEntityProfile
   *
   * Gets the entityProfile for the entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} qualifiedEntityName Qualified Entity Name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAnEntityProfileWithHttpOperationResponse(instanceId: string, qualifiedEntityName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetEntityProfile
   *
   * Gets the entityProfile for the entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} qualifiedEntityName Qualified Entity Name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAnEntityProfile(instanceId: string, qualifiedEntityName: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAnEntityProfile(instanceId: string, qualifiedEntityName: string, callback: ServiceCallback<any>): void;
  getAnEntityProfile(instanceId: string, qualifiedEntityName: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary Gets the metadata information (including total Activity record
   * count and Activity Types) for a given customer id.
   *
   * Gets the metadata information (including total Activity record count and
   * Activity Types) for a given customer id.
   *
   * @param {string} instanceId Format - uuid. the identifier for the instance.
   *
   * @param {string} customerId The identifier for the customer.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getActivityTypesAndCountsWithHttpOperationResponse(instanceId: string, customerId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary Gets the metadata information (including total Activity record
   * count and Activity Types) for a given customer id.
   *
   * Gets the metadata information (including total Activity record count and
   * Activity Types) for a given customer id.
   *
   * @param {string} instanceId Format - uuid. the identifier for the instance.
   *
   * @param {string} customerId The identifier for the customer.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getActivityTypesAndCounts(instanceId: string, customerId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getActivityTypesAndCounts(instanceId: string, customerId: string, callback: ServiceCallback<any>): void;
  getActivityTypesAndCounts(instanceId: string, customerId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary GetAllSystemRelationships
   *
   * Gets all system created relationship metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getAllSystemCreatedRelationshipsWithHttpOperationResponse(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary GetAllSystemRelationships
   *
   * Gets all system created relationship metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllSystemCreatedRelationships(instanceId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  getAllSystemCreatedRelationships(instanceId: string, callback: ServiceCallback<any>): void;
  getAllSystemCreatedRelationships(instanceId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;


  /**
   * @summary CreateWorkflowRefreshSchedulesBatch
   *
   * Create a batch of workflow refresh schedules.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {array} [options.body] A list of schedule objects to create.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  createABatchOfWorkflowRefreshSchedulesWithHttpOperationResponse(instanceId: string, workflowName: string, options?: { body? : models.WorkflowRefreshSchedule[], customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<any>>;

  /**
   * @summary CreateWorkflowRefreshSchedulesBatch
   *
   * Create a batch of workflow refresh schedules.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {array} [options.body] A list of schedule objects to create.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {Object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  createABatchOfWorkflowRefreshSchedules(instanceId: string, workflowName: string, options?: { body? : models.WorkflowRefreshSchedule[], customHeaders? : { [headerName: string]: string; } }): Promise<any>;
  createABatchOfWorkflowRefreshSchedules(instanceId: string, workflowName: string, callback: ServiceCallback<any>): void;
  createABatchOfWorkflowRefreshSchedules(instanceId: string, workflowName: string, options: { body? : models.WorkflowRefreshSchedule[], customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<any>): void;
}

export { CustomerInsights, models as CustomerInsightsModels };
