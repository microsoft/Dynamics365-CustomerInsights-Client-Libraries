/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

/* jshint latedef:false */
/* jshint forin:false */
/* jshint noempty:false */

'use strict';

const msRest = require('ms-rest');
const ServiceClient = msRest.ServiceClient;
const WebResource = msRest.WebResource;

const models = require('./models');


/**
 * @summary GetAttributeProfile
 *
 * Gets the specific attribute profile for the entity.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id.
 *
 * @param {string} qualifiedEntityName Qualified Entity Name.
 *
 * @param {string} attributeName Attribute Name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAnAttributeProfile(instanceId, qualifiedEntityName, attributeName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (qualifiedEntityName === null || qualifiedEntityName === undefined || typeof qualifiedEntityName.valueOf() !== 'string') {
      throw new Error('qualifiedEntityName cannot be null or undefined and it must be of type string.');
    }
    if (attributeName === null || attributeName === undefined || typeof attributeName.valueOf() !== 'string') {
      throw new Error('attributeName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/dataprofile/{qualifiedEntityName}/{attributeName}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{qualifiedEntityName}', encodeURIComponent(qualifiedEntityName));
  requestUrl = requestUrl.replace('{attributeName}', encodeURIComponent(attributeName));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['AttributeDataProfile']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetAllDataSources
 *
 * Returns a collections of DataSourceInfo configured for the given Customer
 * Insights instance
 *
 * @param {string} instanceId Format - uuid. The instance id for which to fetch
 * data source info.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllDataSources(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/datasources';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'DataSourceInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'DataSourceInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetDataSource
 *
 * Fetches a DataSourceInfo matching the dataSourceId configured for the
 * Customer Insights instance.
 *
 * @param {string} instanceId Format - uuid. The instance id to fetch data
 * source info for.
 *
 * @param {string} dataSourceId Format - uuid. The data source id to fetch info
 * for.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getDataSource(instanceId, dataSourceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (dataSourceId === null || dataSourceId === undefined || typeof dataSourceId.valueOf() !== 'string') {
      throw new Error('dataSourceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/datasources/{dataSourceId}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{dataSourceId}', encodeURIComponent(dataSourceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DataSourceInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary DeleteDataSource
 *
 * Deletes a data source from the instance.
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {string} dataSourceId Format - uuid. The data source id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteADataSource(instanceId, dataSourceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (dataSourceId === null || dataSourceId === undefined || typeof dataSourceId.valueOf() !== 'string') {
      throw new Error('dataSourceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/datasources/{dataSourceId}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{dataSourceId}', encodeURIComponent(dataSourceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['OkResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary CreateEntity (Preview)
 *
 * Writes an entity instance into the store, g. an activity entity.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance Id.
 *
 * @param {string} entityName Fully qualified entity name, consisting of
 * 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.body] JSON document representing the entity. The
 * schema must be consistent with the entity metadata. Use GET action of this
 * resource to obtain an example.
 *
 * @param {string} [options.validUntil] Format - date-time (as date-time in
 * RFC3339). Expiration time of the change; ISO8601; optional. The value can be
 * maximum 30 days in the future. If the datasource for this entity doesn't
 * contain the changes after this time, the update disappears from the store.
 *
 * @param {string} [options.caller] String to identify the caller; optional.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createAnEntity(instanceId, entityName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;
  let validUntil = (options && options.validUntil !== undefined) ? options.validUntil : undefined;
  let caller = (options && options.caller !== undefined) ? options.caller : undefined;
  // Validate
  try {
    if (body !== null && body !== undefined && typeof body.valueOf() !== 'string') {
      throw new Error('body must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (validUntil !== null && validUntil !== undefined && typeof validUntil.valueOf() !== 'string') {
      throw new Error('validUntil must be of type string.');
    }
    if (caller !== null && caller !== undefined && typeof caller.valueOf() !== 'string') {
      throw new Error('caller must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/data/{entityName}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  let queryParameters = [];
  if (validUntil !== null && validUntil !== undefined) {
    queryParameters.push('validUntil=' + encodeURIComponent(validUntil));
  }
  if (caller !== null && caller !== undefined) {
    queryParameters.push('caller=' + encodeURIComponent(caller));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = {
        required: false,
        serializedName: 'body',
        type: {
          name: 'String'
        }
      };
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 202 && statusCode !== 400 && statusCode !== 401 && statusCode !== 409 && statusCode !== 429 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CreatedResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 202) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['AcceptedResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ODataError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }
    // Deserialize Response
    if (statusCode === 409) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ODataError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError3 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError3.request = msRest.stripRequest(httpRequest);
        deserializationError3.response = msRest.stripResponse(response);
        return callback(deserializationError3);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary UpdateEntity (Preview)
 *
 * Updates an entity instance in the store, g. Customer entity.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance Id.
 *
 * @param {string} entityName Fully qualified entity name, e.g. 'Customer'.
 *
 * @param {string} entityId Id of the entity to update, e.g. 'CustomerId' of a
 * Customer entity.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.body] JSON document with set of changes to apply on
 * the entity. Each change must be consistent with the entity metadata. Use GET
 * action of this resource to obtain an example.
 *
 * @param {string} [options.validUntil] Format - date-time (as date-time in
 * RFC3339). Expiration time of the change; ISO8601; optional. The value can be
 * maximum 30 days in the future. If the datasource for this entity doesn't
 * contain the changes after this time, the update disappears from the store.
 *
 * @param {string} [options.caller] String to identify the caller; optional.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateAnEntity(instanceId, entityName, entityId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;
  let validUntil = (options && options.validUntil !== undefined) ? options.validUntil : undefined;
  let caller = (options && options.caller !== undefined) ? options.caller : undefined;
  // Validate
  try {
    if (body !== null && body !== undefined && typeof body.valueOf() !== 'string') {
      throw new Error('body must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (entityId === null || entityId === undefined || typeof entityId.valueOf() !== 'string') {
      throw new Error('entityId cannot be null or undefined and it must be of type string.');
    }
    if (validUntil !== null && validUntil !== undefined && typeof validUntil.valueOf() !== 'string') {
      throw new Error('validUntil must be of type string.');
    }
    if (caller !== null && caller !== undefined && typeof caller.valueOf() !== 'string') {
      throw new Error('caller must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/data/{entityName}/{entityId}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  requestUrl = requestUrl.replace('{entityId}', encodeURIComponent(entityId));
  let queryParameters = [];
  if (validUntil !== null && validUntil !== undefined) {
    queryParameters.push('validUntil=' + encodeURIComponent(validUntil));
  }
  if (caller !== null && caller !== undefined) {
    queryParameters.push('caller=' + encodeURIComponent(caller));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = {
        required: false,
        serializedName: 'body',
        type: {
          name: 'String'
        }
      };
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 204 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 429 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 204) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['NoContentResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ODataError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ODataError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetEntityByODataQuery
 *
 * Submits an OData request to the service.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id.
 *
 * @param {string} relativePath Relative OData path. See
 * https://www.odata.org/getting-started/basic-tutorial/ for info.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.forceSearch] Whether force use search to support
 * the query.
 *
 * @param {boolean} [options.proxy] Whether or not we are requesting data by
 * proxy.
 *
 * @param {string} [options.search] Search OData parameter.
 *
 * @param {string} [options.select] Select OData parameter.
 *
 * @param {string} [options.skip] Skip OData parameter.
 *
 * @param {string} [options.skiptoken] SkipToken OData parameter.
 *
 * @param {string} [options.filter] Filter OData parameter.
 *
 * @param {string} [options.orderby] OrderBy OData parameter.
 *
 * @param {string} [options.expand] Expand OData parameter.
 *
 * @param {string} [options.top] Top OData parameter.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getEntitiesWithODataPath(instanceId, relativePath, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let forceSearch = (options && options.forceSearch !== undefined) ? options.forceSearch : undefined;
  let proxy = (options && options.proxy !== undefined) ? options.proxy : undefined;
  let search = (options && options.search !== undefined) ? options.search : undefined;
  let select = (options && options.select !== undefined) ? options.select : undefined;
  let skip = (options && options.skip !== undefined) ? options.skip : undefined;
  let skiptoken = (options && options.skiptoken !== undefined) ? options.skiptoken : undefined;
  let filter = (options && options.filter !== undefined) ? options.filter : undefined;
  let orderby = (options && options.orderby !== undefined) ? options.orderby : undefined;
  let expand = (options && options.expand !== undefined) ? options.expand : undefined;
  let top = (options && options.top !== undefined) ? options.top : undefined;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (relativePath === null || relativePath === undefined || typeof relativePath.valueOf() !== 'string') {
      throw new Error('relativePath cannot be null or undefined and it must be of type string.');
    }
    if (forceSearch !== null && forceSearch !== undefined && typeof forceSearch !== 'boolean') {
      throw new Error('forceSearch must be of type boolean.');
    }
    if (proxy !== null && proxy !== undefined && typeof proxy !== 'boolean') {
      throw new Error('proxy must be of type boolean.');
    }
    if (search !== null && search !== undefined && typeof search.valueOf() !== 'string') {
      throw new Error('search must be of type string.');
    }
    if (select !== null && select !== undefined && typeof select.valueOf() !== 'string') {
      throw new Error('select must be of type string.');
    }
    if (skip !== null && skip !== undefined && typeof skip.valueOf() !== 'string') {
      throw new Error('skip must be of type string.');
    }
    if (skiptoken !== null && skiptoken !== undefined && typeof skiptoken.valueOf() !== 'string') {
      throw new Error('skiptoken must be of type string.');
    }
    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (orderby !== null && orderby !== undefined && typeof orderby.valueOf() !== 'string') {
      throw new Error('orderby must be of type string.');
    }
    if (expand !== null && expand !== undefined && typeof expand.valueOf() !== 'string') {
      throw new Error('expand must be of type string.');
    }
    if (top !== null && top !== undefined && typeof top.valueOf() !== 'string') {
      throw new Error('top must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/data/{relativePath}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{relativePath}', encodeURIComponent(relativePath));
  let queryParameters = [];
  if (forceSearch !== null && forceSearch !== undefined) {
    queryParameters.push('forceSearch=' + encodeURIComponent(forceSearch.toString()));
  }
  if (proxy !== null && proxy !== undefined) {
    queryParameters.push('proxy=' + encodeURIComponent(proxy.toString()));
  }
  if (search !== null && search !== undefined) {
    queryParameters.push('$search=' + encodeURIComponent(search));
  }
  if (select !== null && select !== undefined) {
    queryParameters.push('$select=' + encodeURIComponent(select));
  }
  if (skip !== null && skip !== undefined) {
    queryParameters.push('$skip=' + encodeURIComponent(skip));
  }
  if (skiptoken !== null && skiptoken !== undefined) {
    queryParameters.push('$skiptoken=' + encodeURIComponent(skiptoken));
  }
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (orderby !== null && orderby !== undefined) {
    queryParameters.push('$orderby=' + encodeURIComponent(orderby));
  }
  if (expand !== null && expand !== undefined) {
    queryParameters.push('$expand=' + encodeURIComponent(expand));
  }
  if (top !== null && top !== undefined) {
    queryParameters.push('$top=' + encodeURIComponent(top));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 406 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ODataEntityPayload']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ODataError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ODataError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }
    // Deserialize Response
    if (statusCode === 406) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ODataError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError3 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError3.request = msRest.stripRequest(httpRequest);
        deserializationError3.response = msRest.stripResponse(response);
        return callback(deserializationError3);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ODataError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError4 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError4.request = msRest.stripRequest(httpRequest);
        deserializationError4.response = msRest.stripResponse(response);
        return callback(deserializationError4);
      }
    }
    // Deserialize Response
    if (statusCode === 503) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ODataError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError5 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError5.request = msRest.stripRequest(httpRequest);
        deserializationError5.response = msRest.stripResponse(response);
        return callback(deserializationError5);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetAllEntitiesMetadata
 *
 * Retrieves the flattened entity model for the provided instanceId.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.attributesAnnotations] Indicates if extra
 * annotations like 'ReadOnly' or 'Mandatory' should be included.
 *
 * @param {boolean} [options.includeQuarantined] Indicates if quarantined
 * entities should be included in the output entity model.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllEntityMetadata(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let attributesAnnotations = (options && options.attributesAnnotations !== undefined) ? options.attributesAnnotations : false;
  let includeQuarantined = (options && options.includeQuarantined !== undefined) ? options.includeQuarantined : false;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (attributesAnnotations !== null && attributesAnnotations !== undefined && typeof attributesAnnotations !== 'boolean') {
      throw new Error('attributesAnnotations must be of type boolean.');
    }
    if (includeQuarantined !== null && includeQuarantined !== undefined && typeof includeQuarantined !== 'boolean') {
      throw new Error('includeQuarantined must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/entities';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  let queryParameters = [];
  if (attributesAnnotations !== null && attributesAnnotations !== undefined) {
    queryParameters.push('attributesAnnotations=' + encodeURIComponent(attributesAnnotations.toString()));
  }
  if (includeQuarantined !== null && includeQuarantined !== undefined) {
    queryParameters.push('includeQuarantined=' + encodeURIComponent(includeQuarantined.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['IC360EntityModel']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }
    // Deserialize Response
    if (statusCode === 503) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError3 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError3.request = msRest.stripRequest(httpRequest);
        deserializationError3.response = msRest.stripResponse(response);
        return callback(deserializationError3);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetEntityMetadata
 *
 * Retrieves the entity metadata for the provided instanceId and entityName.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {string} entityName Entity name
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.attributesAnnotations] Indicates if extra
 * annotations like 'ReadOnly' or 'Mandatory' should be included.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getEntityMetadata(instanceId, entityName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let attributesAnnotations = (options && options.attributesAnnotations !== undefined) ? options.attributesAnnotations : false;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (attributesAnnotations !== null && attributesAnnotations !== undefined && typeof attributesAnnotations !== 'boolean') {
      throw new Error('attributesAnnotations must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/entities/{entityName}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));
  let queryParameters = [];
  if (attributesAnnotations !== null && attributesAnnotations !== undefined) {
    queryParameters.push('attributesAnnotations=' + encodeURIComponent(attributesAnnotations.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['IEntityMetadata']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }
    // Deserialize Response
    if (statusCode === 503) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError3 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError3.request = msRest.stripRequest(httpRequest);
        deserializationError3.response = msRest.stripResponse(response);
        return callback(deserializationError3);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetEntitySize
 *
 * Retrieves the entity size for the provided instanceId and entityName.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {string} entityName Entity name
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getEntitySize(instanceId, entityName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/entities/{entityName}/entitysize';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{entityName}', encodeURIComponent(entityName));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['EntitySize']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }
    // Deserialize Response
    if (statusCode === 503) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError3 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError3.request = msRest.stripRequest(httpRequest);
        deserializationError3.response = msRest.stripResponse(response);
        return callback(deserializationError3);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary ResetInstance
 *
 * Reset scopes in the given instance. Provide optional management operation
 * scope to reset only that scope.
 *
 * @param {string} instanceId Format - uuid. The instance Id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.instanceManagementOperationScope] The management
 * operation scope for reset.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _resetAnInstance(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let instanceManagementOperationScope = (options && options.instanceManagementOperationScope !== undefined) ? options.instanceManagementOperationScope : undefined;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (instanceManagementOperationScope !== null && instanceManagementOperationScope !== undefined && typeof instanceManagementOperationScope.valueOf() !== 'string') {
      throw new Error('instanceManagementOperationScope must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/reset';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  let queryParameters = [];
  if (instanceManagementOperationScope !== null && instanceManagementOperationScope !== undefined) {
    queryParameters.push('instanceManagementOperationScope=' + encodeURIComponent(instanceManagementOperationScope));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 403 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Boolean'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 403) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError3 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError3.request = msRest.stripRequest(httpRequest);
        deserializationError3.response = msRest.stripResponse(response);
        return callback(deserializationError3);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError4 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError4.request = msRest.stripRequest(httpRequest);
        deserializationError4.response = msRest.stripResponse(response);
        return callback(deserializationError4);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary ListAllInstances
 *
 * Retrieves all instances of the current user.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllInstances(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'InstanceInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'InstanceInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary ListInstancesByInstanceIds
 *
 * Retrieves instances based on instance ids, it can only accept batch of
 * instances.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {array} [options.body] Instance ids of instances to get.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllInstancesInBatchesByInstanceids(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;
  // Validate
  try {
    if (Array.isArray(body)) {
      for (let i = 0; i < body.length; i++) {
        if (body[i] !== null && body[i] !== undefined && !(typeof body[i].valueOf() === 'string' && msRest.isValidUuid(body[i]))) {
          throw new Error('body[i] must be of type string and must be a valid uuid.');
        }
      }
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/batch';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = {
        required: false,
        serializedName: 'body',
        type: {
          name: 'Sequence',
          element: {
              required: false,
              serializedName: 'UuidElementType',
              type: {
                name: 'String'
              }
          }
        }
      };
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'InstanceInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'InstanceInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetInstance
 *
 * Retrieves metadata for a Customer Insights instance based on its instanceId.
 *
 * @param {string} instanceId Format - uuid. Unique id for the Customer
 * Insights instance.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getInstanceMetadata(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['InstanceMetadata']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary DeleteInstance
 *
 * Delete an instance.
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteAnInstance(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 403 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Boolean'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 403) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError3 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError3.request = msRest.stripRequest(httpRequest);
        deserializationError3.response = msRest.stripResponse(response);
        return callback(deserializationError3);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError4 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError4.request = msRest.stripRequest(httpRequest);
        deserializationError4.response = msRest.stripResponse(response);
        return callback(deserializationError4);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary CreateInstance
 *
 * Creates a new instance.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.body] The instance creation request.
 *
 * @param {object} [options.body.instanceMetadata]
 *
 * @param {string} [options.body.instanceMetadata.name] Gets the user defined
 * instance name.
 *
 * @param {string} [options.body.instanceMetadata.provisioningState] Possible
 * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
 * 'deleting', 'refreshCredentials', 'resetInstanceInProgress'
 *
 * @param {string} [options.body.instanceMetadata.instanceType] Possible values
 * include: 'trial', 'sandbox', 'production'
 *
 * @param {object} [options.body.instanceMetadata.refreshSchedule]
 *
 * @param {boolean} [options.body.instanceMetadata.refreshSchedule.isActive]
 * Gets a value indicating whether the schedule is active.
 *
 * @param {string} [options.body.instanceMetadata.refreshSchedule.timezoneId]
 * Gets the ID of the timezone
 *
 * @param {array} [options.body.instanceMetadata.refreshSchedule.cronSchedules]
 * Gets the schedule in CRON format
 *
 * @param {uuid} [options.body.instanceMetadata.refreshSchedule.scheduleId]
 * Gets the ID of the schedule
 *
 * @param {uuid} [options.body.instanceMetadata.refreshSchedule.instanceId]
 * Customer Insights instance id associated with this object.
 *
 * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
 * the instance is set to expire.
 *
 * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
 * where the instance lives.
 *
 * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
 *
 * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
 * the Cds Organization Friendly Name
 *
 * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
 * Organization Url
 *
 * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
 * Cds Organization State
 *
 * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
 *
 * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
 *
 * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
 *
 * @param {string}
 * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
 * datalake folder Friendly Name
 *
 * @param {string}
 * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
 * the Cds datalake folder unique Name
 *
 * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
 * Gets the total number of extensions allowed if this is trial instance
 *
 * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
 * the details of trial extensions done if this is a trial instance
 *
 * @param {number} [options.body.instanceMetadata.version] Version number of
 * this object.
 *
 * @param {string} [options.body.instanceMetadata.updatedBy] UPN of the user
 * who last updated this record.
 *
 * @param {date} [options.body.instanceMetadata.updatedUtc] Time this object
 * was last updated.
 *
 * @param {string} [options.body.instanceMetadata.createdBy] Email address of
 * the user who created this record.
 *
 * @param {date} [options.body.instanceMetadata.createdUtc] Time this object
 * was initially created.
 *
 * @param {uuid} [options.body.instanceMetadata.instanceId] Customer Insights
 * instance id associated with this object.
 *
 * @param {object} [options.body.byosaResourceMetadata]
 *
 * @param {object} [options.body.cdsResourceMetadata]
 *
 * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
 * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
 * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
 * 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp', 'facebookAds',
 * 'http', 'mailchimp', 'googleAds', 'marketo'
 *
 * @param {uuid} [options.body.cdsResourceMetadata.resourceId] Gets the Id of
 * the resource.
 *
 * @param {uuid} [options.body.cdsResourceMetadata.operationId] Gets the Id of
 * the operation being performed on the resource.
 *
 * @param {string} [options.body.cdsResourceMetadata.resourceType] Possible
 * values include: 'adlsGen2', 'd365Sales', 'cds', 'ftp',
 * 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
 * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
 * 'facebookAds', 'http', 'mailchimp', 'googleAds', 'marketo'
 *
 * @param {string} [options.body.cdsResourceMetadata.name] Gets the Name of the
 * resource.
 *
 * @param {string} [options.body.cdsResourceMetadata.description] Gets the
 * Description of the resource.
 *
 * @param {number} [options.body.cdsResourceMetadata.version] Version number of
 * this object.
 *
 * @param {string} [options.body.cdsResourceMetadata.updatedBy] UPN of the user
 * who last updated this record.
 *
 * @param {date} [options.body.cdsResourceMetadata.updatedUtc] Time this object
 * was last updated.
 *
 * @param {string} [options.body.cdsResourceMetadata.createdBy] Email address
 * of the user who created this record.
 *
 * @param {date} [options.body.cdsResourceMetadata.createdUtc] Time this object
 * was initially created.
 *
 * @param {uuid} [options.body.cdsResourceMetadata.instanceId] Customer
 * Insights instance id associated with this object.
 *
 * @param {string} [options.body.bapProvisioningType] Possible values include:
 * 'skip', 'create', 'attach'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createAnInstance(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/V2';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = new client.models['InstancesV2PostRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 403 && statusCode !== 409 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['InstanceMetadata']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 403) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }
    // Deserialize Response
    if (statusCode === 409) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError3 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError3.request = msRest.stripRequest(httpRequest);
        deserializationError3.response = msRest.stripResponse(response);
        return callback(deserializationError3);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError4 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError4.request = msRest.stripRequest(httpRequest);
        deserializationError4.response = msRest.stripResponse(response);
        return callback(deserializationError4);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary UpdateInstance
 *
 * Patches the Market Verticals, Display name, Domain Name, CDS environment and
 * BYOSA secret to the instance.
 *
 * @param {string} instanceId Format - uuid.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.body]
 *
 * @param {object} [options.body.instanceMetadata]
 *
 * @param {string} [options.body.instanceMetadata.name] Gets the user defined
 * instance name.
 *
 * @param {string} [options.body.instanceMetadata.provisioningState] Possible
 * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
 * 'deleting', 'refreshCredentials', 'resetInstanceInProgress'
 *
 * @param {string} [options.body.instanceMetadata.instanceType] Possible values
 * include: 'trial', 'sandbox', 'production'
 *
 * @param {object} [options.body.instanceMetadata.refreshSchedule]
 *
 * @param {boolean} [options.body.instanceMetadata.refreshSchedule.isActive]
 * Gets a value indicating whether the schedule is active.
 *
 * @param {string} [options.body.instanceMetadata.refreshSchedule.timezoneId]
 * Gets the ID of the timezone
 *
 * @param {array} [options.body.instanceMetadata.refreshSchedule.cronSchedules]
 * Gets the schedule in CRON format
 *
 * @param {uuid} [options.body.instanceMetadata.refreshSchedule.scheduleId]
 * Gets the ID of the schedule
 *
 * @param {uuid} [options.body.instanceMetadata.refreshSchedule.instanceId]
 * Customer Insights instance id associated with this object.
 *
 * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
 * the instance is set to expire.
 *
 * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
 * where the instance lives.
 *
 * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
 *
 * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
 * the Cds Organization Friendly Name
 *
 * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
 * Organization Url
 *
 * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
 * Cds Organization State
 *
 * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
 *
 * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
 *
 * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
 *
 * @param {string}
 * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
 * datalake folder Friendly Name
 *
 * @param {string}
 * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
 * the Cds datalake folder unique Name
 *
 * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
 * Gets the total number of extensions allowed if this is trial instance
 *
 * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
 * the details of trial extensions done if this is a trial instance
 *
 * @param {number} [options.body.instanceMetadata.version] Version number of
 * this object.
 *
 * @param {string} [options.body.instanceMetadata.updatedBy] UPN of the user
 * who last updated this record.
 *
 * @param {date} [options.body.instanceMetadata.updatedUtc] Time this object
 * was last updated.
 *
 * @param {string} [options.body.instanceMetadata.createdBy] Email address of
 * the user who created this record.
 *
 * @param {date} [options.body.instanceMetadata.createdUtc] Time this object
 * was initially created.
 *
 * @param {uuid} [options.body.instanceMetadata.instanceId] Customer Insights
 * instance id associated with this object.
 *
 * @param {object} [options.body.byosaResourceMetadata]
 *
 * @param {object} [options.body.cdsResourceMetadata]
 *
 * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
 * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
 * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
 * 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp', 'facebookAds',
 * 'http', 'mailchimp', 'googleAds', 'marketo'
 *
 * @param {uuid} [options.body.cdsResourceMetadata.resourceId] Gets the Id of
 * the resource.
 *
 * @param {uuid} [options.body.cdsResourceMetadata.operationId] Gets the Id of
 * the operation being performed on the resource.
 *
 * @param {string} [options.body.cdsResourceMetadata.resourceType] Possible
 * values include: 'adlsGen2', 'd365Sales', 'cds', 'ftp',
 * 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
 * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
 * 'facebookAds', 'http', 'mailchimp', 'googleAds', 'marketo'
 *
 * @param {string} [options.body.cdsResourceMetadata.name] Gets the Name of the
 * resource.
 *
 * @param {string} [options.body.cdsResourceMetadata.description] Gets the
 * Description of the resource.
 *
 * @param {number} [options.body.cdsResourceMetadata.version] Version number of
 * this object.
 *
 * @param {string} [options.body.cdsResourceMetadata.updatedBy] UPN of the user
 * who last updated this record.
 *
 * @param {date} [options.body.cdsResourceMetadata.updatedUtc] Time this object
 * was last updated.
 *
 * @param {string} [options.body.cdsResourceMetadata.createdBy] Email address
 * of the user who created this record.
 *
 * @param {date} [options.body.cdsResourceMetadata.createdUtc] Time this object
 * was initially created.
 *
 * @param {uuid} [options.body.cdsResourceMetadata.instanceId] Customer
 * Insights instance id associated with this object.
 *
 * @param {string} [options.body.bapProvisioningType] Possible values include:
 * 'skip', 'create', 'attach'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateAnInstance(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/V2';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = new client.models['InstancesInstanceIdV2PatchRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['InstanceMetadata']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError3 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError3.request = msRest.stripRequest(httpRequest);
        deserializationError3.response = msRest.stripResponse(response);
        return callback(deserializationError3);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary CopyInstance
 *
 * Create a new instance and copy metadata from an existing instance.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.body] The metadata to use to create the new
 * instance.
 *
 * @param {uuid} [options.body.instanceIdToCopy]
 *
 * @param {object} [options.body.instanceMetadata]
 *
 * @param {string} [options.body.instanceMetadata.name] Gets the user defined
 * instance name.
 *
 * @param {string} [options.body.instanceMetadata.provisioningState] Possible
 * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
 * 'deleting', 'refreshCredentials', 'resetInstanceInProgress'
 *
 * @param {string} [options.body.instanceMetadata.instanceType] Possible values
 * include: 'trial', 'sandbox', 'production'
 *
 * @param {object} [options.body.instanceMetadata.refreshSchedule]
 *
 * @param {boolean} [options.body.instanceMetadata.refreshSchedule.isActive]
 * Gets a value indicating whether the schedule is active.
 *
 * @param {string} [options.body.instanceMetadata.refreshSchedule.timezoneId]
 * Gets the ID of the timezone
 *
 * @param {array} [options.body.instanceMetadata.refreshSchedule.cronSchedules]
 * Gets the schedule in CRON format
 *
 * @param {uuid} [options.body.instanceMetadata.refreshSchedule.scheduleId]
 * Gets the ID of the schedule
 *
 * @param {uuid} [options.body.instanceMetadata.refreshSchedule.instanceId]
 * Customer Insights instance id associated with this object.
 *
 * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
 * the instance is set to expire.
 *
 * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
 * where the instance lives.
 *
 * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
 *
 * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
 * the Cds Organization Friendly Name
 *
 * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
 * Organization Url
 *
 * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
 * Cds Organization State
 *
 * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
 *
 * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
 *
 * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
 *
 * @param {string}
 * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
 * datalake folder Friendly Name
 *
 * @param {string}
 * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
 * the Cds datalake folder unique Name
 *
 * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
 * Gets the total number of extensions allowed if this is trial instance
 *
 * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
 * the details of trial extensions done if this is a trial instance
 *
 * @param {number} [options.body.instanceMetadata.version] Version number of
 * this object.
 *
 * @param {string} [options.body.instanceMetadata.updatedBy] UPN of the user
 * who last updated this record.
 *
 * @param {date} [options.body.instanceMetadata.updatedUtc] Time this object
 * was last updated.
 *
 * @param {string} [options.body.instanceMetadata.createdBy] Email address of
 * the user who created this record.
 *
 * @param {date} [options.body.instanceMetadata.createdUtc] Time this object
 * was initially created.
 *
 * @param {uuid} [options.body.instanceMetadata.instanceId] Customer Insights
 * instance id associated with this object.
 *
 * @param {object} [options.body.byosaResourceMetadata]
 *
 * @param {object} [options.body.cdsResourceMetadata]
 *
 * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
 * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
 * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
 * 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp', 'facebookAds',
 * 'http', 'mailchimp', 'googleAds', 'marketo'
 *
 * @param {uuid} [options.body.cdsResourceMetadata.resourceId] Gets the Id of
 * the resource.
 *
 * @param {uuid} [options.body.cdsResourceMetadata.operationId] Gets the Id of
 * the operation being performed on the resource.
 *
 * @param {string} [options.body.cdsResourceMetadata.resourceType] Possible
 * values include: 'adlsGen2', 'd365Sales', 'cds', 'ftp',
 * 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
 * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
 * 'facebookAds', 'http', 'mailchimp', 'googleAds', 'marketo'
 *
 * @param {string} [options.body.cdsResourceMetadata.name] Gets the Name of the
 * resource.
 *
 * @param {string} [options.body.cdsResourceMetadata.description] Gets the
 * Description of the resource.
 *
 * @param {number} [options.body.cdsResourceMetadata.version] Version number of
 * this object.
 *
 * @param {string} [options.body.cdsResourceMetadata.updatedBy] UPN of the user
 * who last updated this record.
 *
 * @param {date} [options.body.cdsResourceMetadata.updatedUtc] Time this object
 * was last updated.
 *
 * @param {string} [options.body.cdsResourceMetadata.createdBy] Email address
 * of the user who created this record.
 *
 * @param {date} [options.body.cdsResourceMetadata.createdUtc] Time this object
 * was initially created.
 *
 * @param {uuid} [options.body.cdsResourceMetadata.instanceId] Customer
 * Insights instance id associated with this object.
 *
 * @param {string} [options.body.bapProvisioningType] Possible values include:
 * 'skip', 'create', 'attach'
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _copyAnInstance(options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/copy';

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = new client.models['InstancesCopyPostRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 403 && statusCode !== 409 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['InstanceMetadata']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 403) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }
    // Deserialize Response
    if (statusCode === 409) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError3 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError3.request = msRest.stripRequest(httpRequest);
        deserializationError3.response = msRest.stripResponse(response);
        return callback(deserializationError3);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError4 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError4.request = msRest.stripRequest(httpRequest);
        deserializationError4.response = msRest.stripResponse(response);
        return callback(deserializationError4);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary ListAllMeasuresMetadata
 *
 * ListAllMeasuresMetadata
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAListOfMeasuresMetadata(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/measures';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'MeasureMetadataElementType',
                  type: {
                    name: 'Composite',
                    className: 'MeasureMetadata'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary CreateMeasure
 *
 * CreateMeasure
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.body] New Measure metadata to be created
 *
 * @param {string} [options.body.displayName]
 *
 * @param {string} [options.body.name] Unique name of the measure
 *
 * @param {string} [options.body.description] Description of the measure.
 *
 * @param {object} [options.body.definition]
 *
 * @param {string} [options.body.definition.kind] Possible values include:
 * 'entity', 'attribute'
 *
 * @param {boolean} [options.body.definition.isScalar] Gets a value indicating
 * whether the current measure is a scalar measure e doesn't have any
 * dimensions
 *
 * @param {array} [options.body.definition.linkedEntities] Gets list of linked
 * entities associated with the measure.
 *
 * @param {array} [options.body.definition.variables] Gets list of variables
 * (computed columns) for the measure.
 *
 * @param {object} [options.body.definition.filters]
 *
 * @param {string} [options.body.definition.filters.kind] Possible values
 * include: 'constant', 'property', 'memberAccess', 'functionCall', 'and',
 * 'or', 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo',
 * 'lessThan', 'lessThanOrEqualTo', 'contains', 'startsWith', 'endsWith',
 * 'isNull', 'isNotNull', 'negate', 'add', 'subtract', 'multiply', 'divide',
 * 'modulo', 'exponent', 'today', 'now'
 *
 * @param {object} [options.body.definition.filteringCriteria]
 *
 * @param {string} [options.body.definition.filteringCriteria.logicalOperator]
 * Possible values include: 'and', 'or'
 *
 * @param {string} [options.body.definition.filteringCriteria.attribute] Gets
 * the Attribute of the entity used in segment criteria.
 *
 * @param {string}
 * [options.body.definition.filteringCriteria.comparisonOperator] Possible
 * values include: 'equals', 'notEquals', 'greaterThan',
 * 'greaterThanOrEqualTo', 'lessThan', 'lessThanOrEqualTo', 'any', 'contains',
 * 'startsWith', 'endsWith', 'isNull', 'isNotNull', 'all', 'isIn',
 * 'isWithinLast', 'isBetween', 'isNotBetween', 'yearToDate', 'dayOf',
 * 'monthOf', 'yearOf', 'dayOfWeek', 'timeAt'
 *
 * @param {array} [options.body.definition.filteringCriteria.childCriterias]
 * Gets the list of Child criteria of segment.
 *
 * @param {string} [options.body.definition.filteringCriteria.value] Gets the
 * Value in criteria.
 *
 * @param {boolean} [options.body.definition.filteringCriteria.ignoreCase] Gets
 * a value indicating whether case is ignored for this criteria.
 *
 * @param {array} [options.body.definition.filteringCriteria.listOfValues] Gets
 * the list of values in criteria.
 *
 * @param {boolean} [options.body.definition.filteringCriteria.isTime] flag set
 * to true if entries are of time format
 *
 * @param {array} [options.body.definition.dimensions] Gets list of dimensions
 * with the measure.
 *
 * @param {array} [options.body.definition.aggregates] Gets list of aggregates
 * of the measure.
 *
 * @param {boolean} [options.body.definition.isProfile] Gets a value indicating
 * whether the current measure is a profile measure
 *
 * @param {string} [options.body.definition.measureQuerySql] Gets the user
 * specified custom SQL query.
 *
 * @param {string} [options.body.definition.type] Possible values include:
 * 'structured', 'manual'
 *
 * @param {boolean} [options.body.definition.isManualQueryScalar] Gets the
 * indicating whether the Business Measure is Scalar or not.
 *
 * @param {array} [options.body.definition.dependencies] Gets the list of
 * measures that this measure depends on.
 *
 * @param {object} [options.body.latestEvaluation]
 *
 * @param {uuid} [options.body.latestEvaluation.lastSuccessfulRunId]
 *
 * @param {string} [options.body.latestEvaluation.state] Possible values
 * include: 'none', 'running', 'failed', 'completed'
 *
 * @param {date} [options.body.latestEvaluation.endTime] Evaluation completion
 * time.
 *
 * @param {string} [options.body.latestEvaluation.error] Error Information (if
 * any) that occured during the measure evaluation.
 *
 * @param {object} [options.body.output]
 *
 * @param {object} [options.body.output.values] Output folder path for the
 * evaluation.
 *
 * @param {string} [options.body.output.measureName]
 *
 * @param {date} [options.body.output.evaluationTime] Gets the evaluation start
 * time.
 *
 * @param {object} [options.body.evaluationStats]
 *
 * @param {date} [options.body.evaluationStats.lastSuccessful] Last successful
 * evaluation
 *
 * @param {number} [options.body.evaluationStats.consecutiveFailureCount]
 * Represents Number of consecutive failures
 *
 * @param {object} [options.body.errorDescription]
 *
 * @param {string} [options.body.errorDescription.value]
 *
 * @param {string} [options.body.errorDescription.key] Possible values include:
 * 'activityMappingDuplicateMappingOnEntity', 'activityMappingEmptyInput',
 * 'activityMappingInvalidKeyAttribute',
 * 'activityMappingInvalidRelationshipAttribute',
 * 'activityMappingInvalidStartEndTimeField',
 * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
 * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
 * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
 * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
 * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
 * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
 * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
 * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
 * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
 * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
 * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
 * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
 * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
 * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
 * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
 * 'modelDataTypeError', 'modelDataConvertError',
 * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
 * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
 * 'dataSourceInvalidDataSourceName',
 * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
 * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
 * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
 * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
 * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
 * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
 * 'entityMetadataCanNotUpdateEntity',
 * 'entityMetadataCanNotUpdateEntityOfActivityType',
 * 'entityMetadataForAttributeNotFoundForEntity',
 * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
 * 'gdprDeleteOldSnapshotsConfiguratonError',
 * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
 * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
 * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
 * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
 * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
 * 'instancePreferredLanguageMissing',
 * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
 * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
 * 'invocationUnsupportedMediaType',
 * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
 * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
 * 'segmentEvaluationOrchestrationNotify',
 * 'profileStoreIngestionFailedWithJobInfo',
 * 'profileStoreIngestionOrchestrationFailed',
 * 'profileStoreOrchestrationSuccessful',
 * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
 * 'rbacCanNotRevokePermissionFromInstance',
 * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
 * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
 * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
 * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
 * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
 * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
 * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
 * 'refreshExportRequestThrottling', 'refreshExportSkipped',
 * 'refreshMatchRequestThrotling',
 * 'refreshMeasuresEvaluationRequestThrottling',
 * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
 * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
 * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
 * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
 * 'measuresProcessingOrchestrationFailedV2',
 * 'offlineGraphIngestionOrchestrationFailed',
 * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
 * 'refreshMatchPairsEntityDoesNotExist',
 * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
 * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
 * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
 * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
 * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
 * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
 * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
 * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
 * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
 * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
 * 'bapNotMapped', 'bapCannotCreateEnvironment',
 * 'bapInvalidEnvironmentDisplayNameLength',
 * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
 * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
 * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
 * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
 * 'genericPredictionEntitiesNotAvailable',
 * 'genericPredictionEntityPartitionsNotAvailable',
 * 'genericPredictionEntityWithLabelAttributeNotAvailable',
 * 'genericPredictionAttributesNotAvailable',
 * 'invalidJarvisEntityCreationErrorMessage',
 * 'activityIngestionActivityIdNotFound',
 * 'activityIngestionActivityTimeNotFound',
 * 'activityIngestionIncorrectMinViewFields',
 * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
 * 'activityIngestionNoSourceStream',
 * 'activityIngestionNoSourceStreamWithCorrectActivityName',
 * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
 * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
 * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
 * 'invalidSegmentNameExists', 'inavlidSegmentType',
 * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
 * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
 * 'invalidSegmentValidationNotAllowedForState',
 * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
 * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
 * 'enablingCdsEntitiesFailed',
 * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
 * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
 * 'searchStoreUnavailable', 'profileStoreUnavailable',
 * 'unsupportedInsightType', 'invalidInsightInputGeneric',
 * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
 *
 * @param {array} [options.body.errorDescription.args]
 *
 * @param {object} [options.body.sqlValidationStats]
 *
 * @param {date} [options.body.sqlValidationStats.validationDate] Date of
 * Validation evaluation
 *
 * @param {string} [options.body.sqlValidationStats.error] Gets the number of
 * consecutive failures
 *
 * @param {array} [options.body.evaluationHistory] Evaluation history for the
 * measure. (not persisted in store)
 *
 * @param {array} [options.body.outputHistory] Output history for the measure.
 * (not persisted in store)
 *
 * @param {number} [options.body.version] Version number of this object.
 *
 * @param {string} [options.body.updatedBy] UPN of the user who last updated
 * this record.
 *
 * @param {date} [options.body.updatedUtc] Time this object was last updated.
 *
 * @param {string} [options.body.createdBy] Email address of the user who
 * created this record.
 *
 * @param {date} [options.body.createdUtc] Time this object was initially
 * created.
 *
 * @param {uuid} [options.body.instanceId] Customer Insights instance id
 * associated with this object.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createAMeasure(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/measures';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = new client.models['InstancesInstanceIdManageMeasuresPostRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['MeasureMetadata']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ParsingError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetMeasureMetadata
 *
 * Retrieves the measure metadata for the provided instanceId and measureName.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {string} measureName Name of the measure
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.includeHistoricStats] Boolean for historical stats
 *
 * @param {number} [options.historicStatsDays] Format - int32. Number of
 * lookback days
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getMetadataForAMeasure(instanceId, measureName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let includeHistoricStats = (options && options.includeHistoricStats !== undefined) ? options.includeHistoricStats : false;
  let historicStatsDays = (options && options.historicStatsDays !== undefined) ? options.historicStatsDays : 30;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (measureName === null || measureName === undefined || typeof measureName.valueOf() !== 'string') {
      throw new Error('measureName cannot be null or undefined and it must be of type string.');
    }
    if (includeHistoricStats !== null && includeHistoricStats !== undefined && typeof includeHistoricStats !== 'boolean') {
      throw new Error('includeHistoricStats must be of type boolean.');
    }
    if (historicStatsDays !== null && historicStatsDays !== undefined && typeof historicStatsDays !== 'number') {
      throw new Error('historicStatsDays must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/measures/{measureName}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{measureName}', encodeURIComponent(measureName));
  let queryParameters = [];
  if (includeHistoricStats !== null && includeHistoricStats !== undefined) {
    queryParameters.push('includeHistoricStats=' + encodeURIComponent(includeHistoricStats.toString()));
  }
  if (historicStatsDays !== null && historicStatsDays !== undefined) {
    queryParameters.push('historicStatsDays=' + encodeURIComponent(historicStatsDays.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['MeasureMetadata']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary UpdateMeasure
 *
 * Updates measures metadata for the provided instanceId and measureMetadata.
 * Existing measure is retrieved using measureName.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {string} measureName Name of the measure
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.body] Update measure metadata
 *
 * @param {string} [options.body.displayName]
 *
 * @param {string} [options.body.name] Unique name of the measure
 *
 * @param {string} [options.body.description] Description of the measure.
 *
 * @param {object} [options.body.definition]
 *
 * @param {string} [options.body.definition.kind] Possible values include:
 * 'entity', 'attribute'
 *
 * @param {boolean} [options.body.definition.isScalar] Gets a value indicating
 * whether the current measure is a scalar measure e doesn't have any
 * dimensions
 *
 * @param {array} [options.body.definition.linkedEntities] Gets list of linked
 * entities associated with the measure.
 *
 * @param {array} [options.body.definition.variables] Gets list of variables
 * (computed columns) for the measure.
 *
 * @param {object} [options.body.definition.filters]
 *
 * @param {string} [options.body.definition.filters.kind] Possible values
 * include: 'constant', 'property', 'memberAccess', 'functionCall', 'and',
 * 'or', 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo',
 * 'lessThan', 'lessThanOrEqualTo', 'contains', 'startsWith', 'endsWith',
 * 'isNull', 'isNotNull', 'negate', 'add', 'subtract', 'multiply', 'divide',
 * 'modulo', 'exponent', 'today', 'now'
 *
 * @param {object} [options.body.definition.filteringCriteria]
 *
 * @param {string} [options.body.definition.filteringCriteria.logicalOperator]
 * Possible values include: 'and', 'or'
 *
 * @param {string} [options.body.definition.filteringCriteria.attribute] Gets
 * the Attribute of the entity used in segment criteria.
 *
 * @param {string}
 * [options.body.definition.filteringCriteria.comparisonOperator] Possible
 * values include: 'equals', 'notEquals', 'greaterThan',
 * 'greaterThanOrEqualTo', 'lessThan', 'lessThanOrEqualTo', 'any', 'contains',
 * 'startsWith', 'endsWith', 'isNull', 'isNotNull', 'all', 'isIn',
 * 'isWithinLast', 'isBetween', 'isNotBetween', 'yearToDate', 'dayOf',
 * 'monthOf', 'yearOf', 'dayOfWeek', 'timeAt'
 *
 * @param {array} [options.body.definition.filteringCriteria.childCriterias]
 * Gets the list of Child criteria of segment.
 *
 * @param {string} [options.body.definition.filteringCriteria.value] Gets the
 * Value in criteria.
 *
 * @param {boolean} [options.body.definition.filteringCriteria.ignoreCase] Gets
 * a value indicating whether case is ignored for this criteria.
 *
 * @param {array} [options.body.definition.filteringCriteria.listOfValues] Gets
 * the list of values in criteria.
 *
 * @param {boolean} [options.body.definition.filteringCriteria.isTime] flag set
 * to true if entries are of time format
 *
 * @param {array} [options.body.definition.dimensions] Gets list of dimensions
 * with the measure.
 *
 * @param {array} [options.body.definition.aggregates] Gets list of aggregates
 * of the measure.
 *
 * @param {boolean} [options.body.definition.isProfile] Gets a value indicating
 * whether the current measure is a profile measure
 *
 * @param {string} [options.body.definition.measureQuerySql] Gets the user
 * specified custom SQL query.
 *
 * @param {string} [options.body.definition.type] Possible values include:
 * 'structured', 'manual'
 *
 * @param {boolean} [options.body.definition.isManualQueryScalar] Gets the
 * indicating whether the Business Measure is Scalar or not.
 *
 * @param {array} [options.body.definition.dependencies] Gets the list of
 * measures that this measure depends on.
 *
 * @param {object} [options.body.latestEvaluation]
 *
 * @param {uuid} [options.body.latestEvaluation.lastSuccessfulRunId]
 *
 * @param {string} [options.body.latestEvaluation.state] Possible values
 * include: 'none', 'running', 'failed', 'completed'
 *
 * @param {date} [options.body.latestEvaluation.endTime] Evaluation completion
 * time.
 *
 * @param {string} [options.body.latestEvaluation.error] Error Information (if
 * any) that occured during the measure evaluation.
 *
 * @param {object} [options.body.output]
 *
 * @param {object} [options.body.output.values] Output folder path for the
 * evaluation.
 *
 * @param {string} [options.body.output.measureName]
 *
 * @param {date} [options.body.output.evaluationTime] Gets the evaluation start
 * time.
 *
 * @param {object} [options.body.evaluationStats]
 *
 * @param {date} [options.body.evaluationStats.lastSuccessful] Last successful
 * evaluation
 *
 * @param {number} [options.body.evaluationStats.consecutiveFailureCount]
 * Represents Number of consecutive failures
 *
 * @param {object} [options.body.errorDescription]
 *
 * @param {string} [options.body.errorDescription.value]
 *
 * @param {string} [options.body.errorDescription.key] Possible values include:
 * 'activityMappingDuplicateMappingOnEntity', 'activityMappingEmptyInput',
 * 'activityMappingInvalidKeyAttribute',
 * 'activityMappingInvalidRelationshipAttribute',
 * 'activityMappingInvalidStartEndTimeField',
 * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
 * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
 * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
 * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
 * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
 * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
 * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
 * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
 * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
 * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
 * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
 * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
 * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
 * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
 * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
 * 'modelDataTypeError', 'modelDataConvertError',
 * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
 * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
 * 'dataSourceInvalidDataSourceName',
 * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
 * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
 * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
 * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
 * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
 * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
 * 'entityMetadataCanNotUpdateEntity',
 * 'entityMetadataCanNotUpdateEntityOfActivityType',
 * 'entityMetadataForAttributeNotFoundForEntity',
 * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
 * 'gdprDeleteOldSnapshotsConfiguratonError',
 * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
 * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
 * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
 * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
 * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
 * 'instancePreferredLanguageMissing',
 * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
 * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
 * 'invocationUnsupportedMediaType',
 * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
 * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
 * 'segmentEvaluationOrchestrationNotify',
 * 'profileStoreIngestionFailedWithJobInfo',
 * 'profileStoreIngestionOrchestrationFailed',
 * 'profileStoreOrchestrationSuccessful',
 * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
 * 'rbacCanNotRevokePermissionFromInstance',
 * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
 * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
 * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
 * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
 * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
 * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
 * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
 * 'refreshExportRequestThrottling', 'refreshExportSkipped',
 * 'refreshMatchRequestThrotling',
 * 'refreshMeasuresEvaluationRequestThrottling',
 * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
 * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
 * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
 * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
 * 'measuresProcessingOrchestrationFailedV2',
 * 'offlineGraphIngestionOrchestrationFailed',
 * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
 * 'refreshMatchPairsEntityDoesNotExist',
 * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
 * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
 * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
 * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
 * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
 * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
 * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
 * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
 * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
 * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
 * 'bapNotMapped', 'bapCannotCreateEnvironment',
 * 'bapInvalidEnvironmentDisplayNameLength',
 * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
 * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
 * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
 * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
 * 'genericPredictionEntitiesNotAvailable',
 * 'genericPredictionEntityPartitionsNotAvailable',
 * 'genericPredictionEntityWithLabelAttributeNotAvailable',
 * 'genericPredictionAttributesNotAvailable',
 * 'invalidJarvisEntityCreationErrorMessage',
 * 'activityIngestionActivityIdNotFound',
 * 'activityIngestionActivityTimeNotFound',
 * 'activityIngestionIncorrectMinViewFields',
 * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
 * 'activityIngestionNoSourceStream',
 * 'activityIngestionNoSourceStreamWithCorrectActivityName',
 * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
 * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
 * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
 * 'invalidSegmentNameExists', 'inavlidSegmentType',
 * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
 * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
 * 'invalidSegmentValidationNotAllowedForState',
 * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
 * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
 * 'enablingCdsEntitiesFailed',
 * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
 * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
 * 'searchStoreUnavailable', 'profileStoreUnavailable',
 * 'unsupportedInsightType', 'invalidInsightInputGeneric',
 * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
 *
 * @param {array} [options.body.errorDescription.args]
 *
 * @param {object} [options.body.sqlValidationStats]
 *
 * @param {date} [options.body.sqlValidationStats.validationDate] Date of
 * Validation evaluation
 *
 * @param {string} [options.body.sqlValidationStats.error] Gets the number of
 * consecutive failures
 *
 * @param {array} [options.body.evaluationHistory] Evaluation history for the
 * measure. (not persisted in store)
 *
 * @param {array} [options.body.outputHistory] Output history for the measure.
 * (not persisted in store)
 *
 * @param {number} [options.body.version] Version number of this object.
 *
 * @param {string} [options.body.updatedBy] UPN of the user who last updated
 * this record.
 *
 * @param {date} [options.body.updatedUtc] Time this object was last updated.
 *
 * @param {string} [options.body.createdBy] Email address of the user who
 * created this record.
 *
 * @param {date} [options.body.createdUtc] Time this object was initially
 * created.
 *
 * @param {uuid} [options.body.instanceId] Customer Insights instance id
 * associated with this object.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateAMeasure(instanceId, measureName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (measureName === null || measureName === undefined || typeof measureName.valueOf() !== 'string') {
      throw new Error('measureName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/measures/{measureName}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{measureName}', encodeURIComponent(measureName));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = new client.models['InstancesInstanceIdManageMeasuresMeasureNamePutRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['MeasureMetadata']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ParsingError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary DeleteMeasure
 *
 * Deletes the measure metadata for the provided instanceId using measureName.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {string} measureName Name of the measure
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteAMeasure(instanceId, measureName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (measureName === null || measureName === undefined || typeof measureName.valueOf() !== 'string') {
      throw new Error('measureName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/measures/{measureName}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{measureName}', encodeURIComponent(measureName));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeletionResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DeletionResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetKeyRing
 *
 * Gets the KeyRing (collection of all alternate keys) for the given instance
 * by alternate key.
 *
 * @param {string} instanceId Format - uuid. Identifier for the instance
 *
 * @param {string} dataSourceName The name of the datasource that contains the
 * given entity.
 *
 * @param {string} entityName The name of the entity that contains the given
 * key.
 *
 * @param {string} key The value of the alternate key provided.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getKeyRing(instanceId, dataSourceName, entityName, key, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (dataSourceName === null || dataSourceName === undefined || typeof dataSourceName.valueOf() !== 'string') {
      throw new Error('dataSourceName cannot be null or undefined and it must be of type string.');
    }
    if (entityName === null || entityName === undefined || typeof entityName.valueOf() !== 'string') {
      throw new Error('entityName cannot be null or undefined and it must be of type string.');
    }
    if (key === null || key === undefined || typeof key.valueOf() !== 'string') {
      throw new Error('key cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/profile/keyring';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  let queryParameters = [];
  queryParameters.push('dataSourceName=' + encodeURIComponent(dataSourceName));
  queryParameters.push('entityName=' + encodeURIComponent(entityName));
  queryParameters.push('key=' + encodeURIComponent(key));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['KeyRingResponse']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetProfileStoreState
 *
 * Gets the profile store state infoformation.
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getProfileStoreState(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/profilestore/stateinfo';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ProfileStoreStateInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 503) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary ListAllRoles
 *
 * Get all role definitions.
 *
 * @param {string} instanceId
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllRoleDefinitions(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/rbac/roles';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'RoleDefinitionElementType',
                  type: {
                    name: 'Composite',
                    className: 'RoleDefinition'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetCurrentUserRole
 *
 * Get role of current user.
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link RoleAssignment} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getCurrentUserRole(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/rbac/myrole';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RoleAssignment']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary UpdateRoleAssignment
 *
 * Adds or updates a role assignment for a principal.
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {string} principalId The principal id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.body] The role assignment.
 *
 * @param {string} [options.body.principalId] Gets the Id of the principal.
 *
 * @param {string} [options.body.principalType] Possible values include:
 * 'user', 'group', 'app'
 *
 * @param {array} [options.body.roles] Gets the roles the principal belongs to.
 *
 * @param {uuid} [options.body.instanceId] Customer Insights instance id
 * associated with this object.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateARoleAssignment(instanceId, principalId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (principalId === null || principalId === undefined || typeof principalId.valueOf() !== 'string') {
      throw new Error('principalId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/rbac/principals/{principalId}/assignment';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{principalId}', encodeURIComponent(principalId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = new client.models['InstancesInstanceIdRbacPrincipalsPrincipalIdAssignmentPutRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'RoleAssignmentElementType',
                  type: {
                    name: 'Composite',
                    className: 'RoleAssignment'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary DeleteRoleAssignment
 *
 * Deletes a role assignment for the principal.
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {string} principalId The principal id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deletesARoleAssignment(instanceId, principalId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (principalId === null || principalId === undefined || typeof principalId.valueOf() !== 'string') {
      throw new Error('principalId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/rbac/principals/{principalId}/assignment';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{principalId}', encodeURIComponent(principalId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary ListAllRoleAssignments
 *
 * Gets all role assignments for the instance.
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {array} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllRoleAssignments(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/rbac/assignments';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'RoleAssignmentElementType',
                  type: {
                    name: 'Composite',
                    className: 'RoleAssignment'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary ListAllRelationships
 *
 * Gets all relationship metadata for the provided instanceId.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllRelationships(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/relationships';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'RelationshipMetadataElementType',
                  type: {
                    name: 'Composite',
                    className: 'RelationshipMetadata'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 503) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary CreateRelationship
 *
 * Creates new relationship metadata for the provided instanceId, using input.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.body] The updated relationship metadata
 *
 * @param {string} [options.body.friendlyName] Gets the friendly name of the
 * relationship.
 *
 * @param {string} [options.body.name] Gets the unique name for relationship
 *
 * @param {string} [options.body.description] Gets the description for
 * relationship
 *
 * @param {string} [options.body.relationshipType] Possible values include:
 * 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
 * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
 *
 * @param {string} [options.body.fromAttributeName] Gets the name of the
 * foreign key reference attribute that this relationship originates from.
 *
 * @param {string} [options.body.fromEntityName] Gets the name of the entity
 * this relationship originates from.
 *
 * @param {string} [options.body.toAttributeName] Gets the name of the foreign
 * key attribute that this relationship points to.
 *
 * @param {string} [options.body.toEntityName] Gets the name of the entity this
 * relationship points to.
 *
 * @param {string} [options.body.cardinality] Possible values include:
 * 'oneToMany', 'oneToOne'
 *
 * @param {number} [options.body.version] Version number of this object.
 *
 * @param {string} [options.body.updatedBy] UPN of the user who last updated
 * this record.
 *
 * @param {date} [options.body.updatedUtc] Time this object was last updated.
 *
 * @param {string} [options.body.createdBy] Email address of the user who
 * created this record.
 *
 * @param {date} [options.body.createdUtc] Time this object was initially
 * created.
 *
 * @param {uuid} [options.body.instanceId] Customer Insights instance id
 * associated with this object.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createARelationship(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/relationships';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = new client.models['InstancesInstanceIdManageRelationshipsPostRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RelationshipMetadata']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }
    // Deserialize Response
    if (statusCode === 503) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError3 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError3.request = msRest.stripRequest(httpRequest);
        deserializationError3.response = msRest.stripResponse(response);
        return callback(deserializationError3);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetRelationship
 *
 * Gets the relationship metadata for the provided instanceId and
 * relationshipName.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {string} relationshipName Relationship name
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getARelationship(instanceId, relationshipName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (relationshipName === null || relationshipName === undefined || typeof relationshipName.valueOf() !== 'string') {
      throw new Error('relationshipName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/relationships/{relationshipName}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{relationshipName}', encodeURIComponent(relationshipName));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RelationshipMetadata']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 503) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary DeleteRelationship
 *
 * Deletes the relationship metadata for the provided instanceId and
 * relationshipName.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {string} relationshipName Relationship name
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteARelationship(instanceId, relationshipName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (relationshipName === null || relationshipName === undefined || typeof relationshipName.valueOf() !== 'string') {
      throw new Error('relationshipName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/relationships/{relationshipName}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{relationshipName}', encodeURIComponent(relationshipName));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['OkResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 503) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary UpdateRelationshhip
 *
 * Updates the relationship metadata for the provided instanceId and
 * relationshipName, using input.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {string} relationshipName Relationship name
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.body] The updated relationship metadata
 *
 * @param {string} [options.body.friendlyName] Gets the friendly name of the
 * relationship.
 *
 * @param {string} [options.body.name] Gets the unique name for relationship
 *
 * @param {string} [options.body.description] Gets the description for
 * relationship
 *
 * @param {string} [options.body.relationshipType] Possible values include:
 * 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
 * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
 *
 * @param {string} [options.body.fromAttributeName] Gets the name of the
 * foreign key reference attribute that this relationship originates from.
 *
 * @param {string} [options.body.fromEntityName] Gets the name of the entity
 * this relationship originates from.
 *
 * @param {string} [options.body.toAttributeName] Gets the name of the foreign
 * key attribute that this relationship points to.
 *
 * @param {string} [options.body.toEntityName] Gets the name of the entity this
 * relationship points to.
 *
 * @param {string} [options.body.cardinality] Possible values include:
 * 'oneToMany', 'oneToOne'
 *
 * @param {number} [options.body.version] Version number of this object.
 *
 * @param {string} [options.body.updatedBy] UPN of the user who last updated
 * this record.
 *
 * @param {date} [options.body.updatedUtc] Time this object was last updated.
 *
 * @param {string} [options.body.createdBy] Email address of the user who
 * created this record.
 *
 * @param {date} [options.body.createdUtc] Time this object was initially
 * created.
 *
 * @param {uuid} [options.body.instanceId] Customer Insights instance id
 * associated with this object.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateARelationship(instanceId, relationshipName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (relationshipName === null || relationshipName === undefined || typeof relationshipName.valueOf() !== 'string') {
      throw new Error('relationshipName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/relationships/{relationshipName}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{relationshipName}', encodeURIComponent(relationshipName));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = new client.models['InstancesInstanceIdManageRelationshipsRelationshipNamePutRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['RelationshipMetadata']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }
    // Deserialize Response
    if (statusCode === 503) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError3 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError3.request = msRest.stripRequest(httpRequest);
        deserializationError3.response = msRest.stripResponse(response);
        return callback(deserializationError3);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetSearchConfiguration
 *
 * Gets the search configuration for the instance.
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSearchConfiguration(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/search';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['InstanceSearchConfiguration']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 503) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary UpdateSearchConfiguration
 *
 * UpdateSearchConfiguration
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.body] The search configuration for the instance.
 *
 * @param {array} [options.body.entityConfig] Gets search configurations for
 * entities
 *
 * @param {boolean} [options.body.isSystemGenerated] Gets a value indicating
 * whether the configuration was system generated
 *
 * @param {number} [options.body.version] Version number of this object.
 *
 * @param {string} [options.body.updatedBy] UPN of the user who last updated
 * this record.
 *
 * @param {date} [options.body.updatedUtc] Time this object was last updated.
 *
 * @param {string} [options.body.createdBy] Email address of the user who
 * created this record.
 *
 * @param {date} [options.body.createdUtc] Time this object was initially
 * created.
 *
 * @param {uuid} [options.body.instanceId] Customer Insights instance id
 * associated with this object.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateSearchConfiguration(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/search';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = new client.models['InstancesInstanceIdManageSearchPutRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['InstanceSearchConfiguration']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }
    // Deserialize Response
    if (statusCode === 503) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError3 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError3.request = msRest.stripRequest(httpRequest);
        deserializationError3.response = msRest.stripResponse(response);
        return callback(deserializationError3);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary ListAllSegments
 *
 * Retrieves a list of segment metadata for the provided instanceId.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.includeHistoricStats] Optional parameter to
 * retrieve evaluation history of all the sgements in instanceId.
 *
 * @param {number} [options.historicStatsDays] Format - int32. Optional
 * parameter to get number of days evaluation history.
 *
 * @param {number} [options.numberOfSegments] Format - int32. Optional
 * parameter to limit the number of segments returned.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAllSegments(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let includeHistoricStats = (options && options.includeHistoricStats !== undefined) ? options.includeHistoricStats : false;
  let historicStatsDays = (options && options.historicStatsDays !== undefined) ? options.historicStatsDays : 10;
  let numberOfSegments = (options && options.numberOfSegments !== undefined) ? options.numberOfSegments : undefined;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (includeHistoricStats !== null && includeHistoricStats !== undefined && typeof includeHistoricStats !== 'boolean') {
      throw new Error('includeHistoricStats must be of type boolean.');
    }
    if (historicStatsDays !== null && historicStatsDays !== undefined && typeof historicStatsDays !== 'number') {
      throw new Error('historicStatsDays must be of type number.');
    }
    if (numberOfSegments !== null && numberOfSegments !== undefined && typeof numberOfSegments !== 'number') {
      throw new Error('numberOfSegments must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/segments';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  let queryParameters = [];
  if (includeHistoricStats !== null && includeHistoricStats !== undefined) {
    queryParameters.push('includeHistoricStats=' + encodeURIComponent(includeHistoricStats.toString()));
  }
  if (historicStatsDays !== null && historicStatsDays !== undefined) {
    queryParameters.push('historicStatsDays=' + encodeURIComponent(historicStatsDays.toString()));
  }
  if (numberOfSegments !== null && numberOfSegments !== undefined) {
    queryParameters.push('numberOfSegments=' + encodeURIComponent(numberOfSegments.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'SegmentMetadataElementType',
                  type: {
                    name: 'Composite',
                    className: 'SegmentMetadata'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary CreateSegment
 *
 * CreateSegment
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.body] New Segment metadata to be created
 *
 * @param {string} [options.body.name] Gets the unique name of the segment
 *
 * @param {string} [options.body.friendlyName] Gets the friendlyName of the
 * segment.
 *
 * @param {string} [options.body.description] Gets the description of the
 * segment.
 *
 * @param {object} [options.body.segmentQueryExpression]
 *
 * @param {string} [options.body.segmentQueryExpression.type] Possible values
 * include: 'structured', 'manual'
 *
 * @param {array} [options.body.segmentQueryExpression.projections] Gets list
 * of attributes to be projected in segment.
 *
 * @param {array} [options.body.segmentQueryExpression.rowsets] Gets list of
 * rowsets of segment.
 *
 * @param {string} [options.body.segmentQueryExpression.segmentationQuerySql]
 * Gets the user specified custom SQL query.
 *
 * @param {string} [options.body.state] Possible values include: 'inactive',
 * 'active', 'validating', 'validated', 'invalid', 'validationError'
 *
 * @param {string} [options.body.errorDescription] Gets the error description
 * when the segment metadata has some issues after refresh.
 *
 * @param {date} [options.body.endDate] Gets the end date of the segment.
 *
 * @param {object} [options.body.evaluationStatus]
 *
 * @param {string} [options.body.evaluationStatus.jobStatus] Possible values
 * include: 'None', 'Queued', 'Running', 'CompletedSuccess',
 * 'CompletedFailure', 'Cancelled', 'Interrupted', 'NotQualified'
 *
 * @param {date} [options.body.evaluationStatus.evaluationDate]
 *
 * @param {number} [options.body.evaluationStatus.entityCount]
 *
 * @param {object} [options.body.evaluationStatus.error]
 *
 * @param {string} [options.body.evaluationStatus.error.value]
 *
 * @param {string} [options.body.evaluationStatus.error.key] Possible values
 * include: 'activityMappingDuplicateMappingOnEntity',
 * 'activityMappingEmptyInput', 'activityMappingInvalidKeyAttribute',
 * 'activityMappingInvalidRelationshipAttribute',
 * 'activityMappingInvalidStartEndTimeField',
 * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
 * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
 * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
 * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
 * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
 * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
 * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
 * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
 * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
 * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
 * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
 * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
 * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
 * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
 * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
 * 'modelDataTypeError', 'modelDataConvertError',
 * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
 * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
 * 'dataSourceInvalidDataSourceName',
 * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
 * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
 * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
 * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
 * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
 * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
 * 'entityMetadataCanNotUpdateEntity',
 * 'entityMetadataCanNotUpdateEntityOfActivityType',
 * 'entityMetadataForAttributeNotFoundForEntity',
 * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
 * 'gdprDeleteOldSnapshotsConfiguratonError',
 * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
 * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
 * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
 * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
 * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
 * 'instancePreferredLanguageMissing',
 * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
 * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
 * 'invocationUnsupportedMediaType',
 * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
 * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
 * 'segmentEvaluationOrchestrationNotify',
 * 'profileStoreIngestionFailedWithJobInfo',
 * 'profileStoreIngestionOrchestrationFailed',
 * 'profileStoreOrchestrationSuccessful',
 * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
 * 'rbacCanNotRevokePermissionFromInstance',
 * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
 * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
 * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
 * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
 * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
 * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
 * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
 * 'refreshExportRequestThrottling', 'refreshExportSkipped',
 * 'refreshMatchRequestThrotling',
 * 'refreshMeasuresEvaluationRequestThrottling',
 * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
 * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
 * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
 * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
 * 'measuresProcessingOrchestrationFailedV2',
 * 'offlineGraphIngestionOrchestrationFailed',
 * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
 * 'refreshMatchPairsEntityDoesNotExist',
 * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
 * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
 * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
 * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
 * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
 * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
 * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
 * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
 * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
 * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
 * 'bapNotMapped', 'bapCannotCreateEnvironment',
 * 'bapInvalidEnvironmentDisplayNameLength',
 * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
 * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
 * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
 * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
 * 'genericPredictionEntitiesNotAvailable',
 * 'genericPredictionEntityPartitionsNotAvailable',
 * 'genericPredictionEntityWithLabelAttributeNotAvailable',
 * 'genericPredictionAttributesNotAvailable',
 * 'invalidJarvisEntityCreationErrorMessage',
 * 'activityIngestionActivityIdNotFound',
 * 'activityIngestionActivityTimeNotFound',
 * 'activityIngestionIncorrectMinViewFields',
 * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
 * 'activityIngestionNoSourceStream',
 * 'activityIngestionNoSourceStreamWithCorrectActivityName',
 * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
 * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
 * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
 * 'invalidSegmentNameExists', 'inavlidSegmentType',
 * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
 * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
 * 'invalidSegmentValidationNotAllowedForState',
 * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
 * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
 * 'enablingCdsEntitiesFailed',
 * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
 * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
 * 'searchStoreUnavailable', 'profileStoreUnavailable',
 * 'unsupportedInsightType', 'invalidInsightInputGeneric',
 * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
 *
 * @param {array} [options.body.evaluationStatus.error.args]
 *
 * @param {uuid} [options.body.evaluationStatus.lastSuccessfulRunId]
 *
 * @param {object} [options.body.sqlValidationStats]
 *
 * @param {date} [options.body.sqlValidationStats.validationDate] Date of
 * Validation evaluation
 *
 * @param {string} [options.body.sqlValidationStats.error] Gets the number of
 * consecutive failures
 *
 * @param {array} [options.body.evaluationStatusHistory] Gets the segment
 * evaluation status history. (not persisted in store)
 *
 * @param {number} [options.body.version] Version number of this object.
 *
 * @param {string} [options.body.updatedBy] UPN of the user who last updated
 * this record.
 *
 * @param {date} [options.body.updatedUtc] Time this object was last updated.
 *
 * @param {string} [options.body.createdBy] Email address of the user who
 * created this record.
 *
 * @param {date} [options.body.createdUtc] Time this object was initially
 * created.
 *
 * @param {uuid} [options.body.instanceId] Customer Insights instance id
 * associated with this object.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createASegment(instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/segments';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = new client.models['InstancesInstanceIdManageSegmentsPostRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 201 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 201) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SegmentMetadata']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary ActivateSegment
 *
 * Activate segment on instanceId with segmentName.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {string} segmentName Unique name of a segment
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _activateSegment(instanceId, segmentName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (segmentName === null || segmentName === undefined || typeof segmentName.valueOf() !== 'string') {
      throw new Error('segmentName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/segments/{segmentName}/activate';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{segmentName}', encodeURIComponent(segmentName));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Boolean'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary DeactivateSegment
 *
 * Deactivate segment on instanceId with segmentName.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {string} segmentName Unique name of a segment
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deactivateSegment(instanceId, segmentName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (segmentName === null || segmentName === undefined || typeof segmentName.valueOf() !== 'string') {
      throw new Error('segmentName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/segments/{segmentName}/deactivate';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{segmentName}', encodeURIComponent(segmentName));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Boolean'
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary UpdateSegments
 *
 * Updates segment metadata for the provided instanceId and segmentName with
 * segmentMetadata.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {string} segmentName Unique name of a segment
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.body] New Segment metadata to be updated
 *
 * @param {string} [options.body.name] Gets the unique name of the segment
 *
 * @param {string} [options.body.friendlyName] Gets the friendlyName of the
 * segment.
 *
 * @param {string} [options.body.description] Gets the description of the
 * segment.
 *
 * @param {object} [options.body.segmentQueryExpression]
 *
 * @param {string} [options.body.segmentQueryExpression.type] Possible values
 * include: 'structured', 'manual'
 *
 * @param {array} [options.body.segmentQueryExpression.projections] Gets list
 * of attributes to be projected in segment.
 *
 * @param {array} [options.body.segmentQueryExpression.rowsets] Gets list of
 * rowsets of segment.
 *
 * @param {string} [options.body.segmentQueryExpression.segmentationQuerySql]
 * Gets the user specified custom SQL query.
 *
 * @param {string} [options.body.state] Possible values include: 'inactive',
 * 'active', 'validating', 'validated', 'invalid', 'validationError'
 *
 * @param {string} [options.body.errorDescription] Gets the error description
 * when the segment metadata has some issues after refresh.
 *
 * @param {date} [options.body.endDate] Gets the end date of the segment.
 *
 * @param {object} [options.body.evaluationStatus]
 *
 * @param {string} [options.body.evaluationStatus.jobStatus] Possible values
 * include: 'None', 'Queued', 'Running', 'CompletedSuccess',
 * 'CompletedFailure', 'Cancelled', 'Interrupted', 'NotQualified'
 *
 * @param {date} [options.body.evaluationStatus.evaluationDate]
 *
 * @param {number} [options.body.evaluationStatus.entityCount]
 *
 * @param {object} [options.body.evaluationStatus.error]
 *
 * @param {string} [options.body.evaluationStatus.error.value]
 *
 * @param {string} [options.body.evaluationStatus.error.key] Possible values
 * include: 'activityMappingDuplicateMappingOnEntity',
 * 'activityMappingEmptyInput', 'activityMappingInvalidKeyAttribute',
 * 'activityMappingInvalidRelationshipAttribute',
 * 'activityMappingInvalidStartEndTimeField',
 * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
 * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
 * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
 * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
 * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
 * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
 * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
 * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
 * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
 * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
 * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
 * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
 * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
 * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
 * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
 * 'modelDataTypeError', 'modelDataConvertError',
 * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
 * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
 * 'dataSourceInvalidDataSourceName',
 * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
 * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
 * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
 * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
 * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
 * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
 * 'entityMetadataCanNotUpdateEntity',
 * 'entityMetadataCanNotUpdateEntityOfActivityType',
 * 'entityMetadataForAttributeNotFoundForEntity',
 * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
 * 'gdprDeleteOldSnapshotsConfiguratonError',
 * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
 * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
 * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
 * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
 * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
 * 'instancePreferredLanguageMissing',
 * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
 * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
 * 'invocationUnsupportedMediaType',
 * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
 * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
 * 'segmentEvaluationOrchestrationNotify',
 * 'profileStoreIngestionFailedWithJobInfo',
 * 'profileStoreIngestionOrchestrationFailed',
 * 'profileStoreOrchestrationSuccessful',
 * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
 * 'rbacCanNotRevokePermissionFromInstance',
 * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
 * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
 * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
 * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
 * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
 * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
 * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
 * 'refreshExportRequestThrottling', 'refreshExportSkipped',
 * 'refreshMatchRequestThrotling',
 * 'refreshMeasuresEvaluationRequestThrottling',
 * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
 * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
 * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
 * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
 * 'measuresProcessingOrchestrationFailedV2',
 * 'offlineGraphIngestionOrchestrationFailed',
 * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
 * 'refreshMatchPairsEntityDoesNotExist',
 * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
 * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
 * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
 * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
 * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
 * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
 * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
 * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
 * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
 * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
 * 'bapNotMapped', 'bapCannotCreateEnvironment',
 * 'bapInvalidEnvironmentDisplayNameLength',
 * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
 * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
 * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
 * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
 * 'genericPredictionEntitiesNotAvailable',
 * 'genericPredictionEntityPartitionsNotAvailable',
 * 'genericPredictionEntityWithLabelAttributeNotAvailable',
 * 'genericPredictionAttributesNotAvailable',
 * 'invalidJarvisEntityCreationErrorMessage',
 * 'activityIngestionActivityIdNotFound',
 * 'activityIngestionActivityTimeNotFound',
 * 'activityIngestionIncorrectMinViewFields',
 * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
 * 'activityIngestionNoSourceStream',
 * 'activityIngestionNoSourceStreamWithCorrectActivityName',
 * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
 * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
 * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
 * 'invalidSegmentNameExists', 'inavlidSegmentType',
 * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
 * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
 * 'invalidSegmentValidationNotAllowedForState',
 * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
 * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
 * 'enablingCdsEntitiesFailed',
 * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
 * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
 * 'searchStoreUnavailable', 'profileStoreUnavailable',
 * 'unsupportedInsightType', 'invalidInsightInputGeneric',
 * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
 *
 * @param {array} [options.body.evaluationStatus.error.args]
 *
 * @param {uuid} [options.body.evaluationStatus.lastSuccessfulRunId]
 *
 * @param {object} [options.body.sqlValidationStats]
 *
 * @param {date} [options.body.sqlValidationStats.validationDate] Date of
 * Validation evaluation
 *
 * @param {string} [options.body.sqlValidationStats.error] Gets the number of
 * consecutive failures
 *
 * @param {array} [options.body.evaluationStatusHistory] Gets the segment
 * evaluation status history. (not persisted in store)
 *
 * @param {number} [options.body.version] Version number of this object.
 *
 * @param {string} [options.body.updatedBy] UPN of the user who last updated
 * this record.
 *
 * @param {date} [options.body.updatedUtc] Time this object was last updated.
 *
 * @param {string} [options.body.createdBy] Email address of the user who
 * created this record.
 *
 * @param {date} [options.body.createdUtc] Time this object was initially
 * created.
 *
 * @param {uuid} [options.body.instanceId] Customer Insights instance id
 * associated with this object.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _updateASegment(instanceId, segmentName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (segmentName === null || segmentName === undefined || typeof segmentName.valueOf() !== 'string') {
      throw new Error('segmentName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/segments/{segmentName}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{segmentName}', encodeURIComponent(segmentName));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = new client.models['InstancesInstanceIdManageSegmentsSegmentNamePutRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SegmentMetadata']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary DeleteSegment
 *
 * DeleteSegment
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id
 *
 * @param {string} segmentName Unique name of a segment
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteSegment(instanceId, segmentName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (segmentName === null || segmentName === undefined || typeof segmentName.valueOf() !== 'string') {
      throw new Error('segmentName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/manage/segments/{segmentName}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{segmentName}', encodeURIComponent(segmentName));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 400 && statusCode !== 401 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['OkResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 400) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiError']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetWorkflowJobInformation
 *
 * GetWorkflowJobInformation
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {string} workflowName The name of the workflow.
 *
 * @param {string} jobId Format - uuid. The job id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {boolean} [options.includeTasks] Flag to include tasks or not.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAWorkflowJobInformation(instanceId, workflowName, jobId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let includeTasks = (options && options.includeTasks !== undefined) ? options.includeTasks : false;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (workflowName === null || workflowName === undefined || typeof workflowName.valueOf() !== 'string') {
      throw new Error('workflowName cannot be null or undefined and it must be of type string.');
    }
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
    if (includeTasks !== null && includeTasks !== undefined && typeof includeTasks !== 'boolean') {
      throw new Error('includeTasks must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/workflows/{workflowName}/jobs/{jobId}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{workflowName}', encodeURIComponent(workflowName));
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));
  let queryParameters = [];
  if (includeTasks !== null && includeTasks !== undefined) {
    queryParameters.push('includeTasks=' + encodeURIComponent(includeTasks.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GraphJobInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary CancelWorkflowJob
 *
 * Cancel a job.
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {string} workflowName The name of the workflow.
 *
 * @param {string} jobId Format - uuid. The job id.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _cancelAWorkflowJob(instanceId, workflowName, jobId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (workflowName === null || workflowName === undefined || typeof workflowName.valueOf() !== 'string') {
      throw new Error('workflowName cannot be null or undefined and it must be of type string.');
    }
    if (jobId === null || jobId === undefined || typeof jobId.valueOf() !== 'string') {
      throw new Error('jobId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/workflows/{workflowName}/jobs/{jobId}/cancel';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{workflowName}', encodeURIComponent(workflowName));
  requestUrl = requestUrl.replace('{jobId}', encodeURIComponent(jobId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GraphJobInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary ListWorkFlowJobs
 *
 * Retrieves a list of recent job information.
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {string} workflowName The name of the workflow.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.top] Format - int32. The number of job informations
 * to retrieve.
 *
 * @param {boolean} [options.includeTasks] Flag to include tasks or not.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getListOfRecentWorkflowJobs(instanceId, workflowName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let top = (options && options.top !== undefined) ? options.top : 10;
  let includeTasks = (options && options.includeTasks !== undefined) ? options.includeTasks : false;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (workflowName === null || workflowName === undefined || typeof workflowName.valueOf() !== 'string') {
      throw new Error('workflowName cannot be null or undefined and it must be of type string.');
    }
    if (top !== null && top !== undefined && typeof top !== 'number') {
      throw new Error('top must be of type number.');
    }
    if (includeTasks !== null && includeTasks !== undefined && typeof includeTasks !== 'boolean') {
      throw new Error('includeTasks must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/workflows/{workflowName}/jobs';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{workflowName}', encodeURIComponent(workflowName));
  let queryParameters = [];
  if (top !== null && top !== undefined) {
    queryParameters.push('top=' + encodeURIComponent(top.toString()));
  }
  if (includeTasks !== null && includeTasks !== undefined) {
    queryParameters.push('includeTasks=' + encodeURIComponent(includeTasks.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'GraphJobInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'GraphJobInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary SubmitWorkflowJob
 *
 * Submits a workflow of OperationTypeoperationType for the instance specified
 * in instanceId.
 * Optionally takes a list of identifiers, only if operationType is not
 * OperationType.All and a flag
 * forceRunRequested indicating whether to force run.
 *
 * @param {string} instanceId Format - uuid. The Customer Insights instance id.
 *
 * @param {string} workflowName The workflow name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.body] Job Creation Request.
 *
 * @param {string} [options.body.graphName]
 *
 * @param {string} [options.body.operationType] Possible values include:
 * 'none', 'ingestion', 'derivedEntity', 'dataPreparation', 'map', 'match',
 * 'merge', 'profileStore', 'search', 'activity', 'attributeMeasures',
 * 'entityMeasures', 'measures', 'segmentation', 'enrichment', 'intelligence',
 * 'aiBuilder', 'insights', 'export', 'modelManagement', 'relationship',
 * 'roleAssignment', 'analysis', 'all'
 *
 * @param {string} [options.body.submissionKind] Possible values include:
 * 'onDemand', 'scheduled'
 *
 * @param {string} [options.body.jobType] Possible values include: 'full',
 * 'incremental'
 *
 * @param {array} [options.body.identifiers]
 *
 * @param {boolean} [options.body.forceRunRequested]
 *
 * @param {string} [options.body.inputRefreshMode] Possible values include:
 * 'FailedOrModifiedRecursive', 'FailedRecursive', 'FailedOrModified',
 * 'Failed', 'None'
 *
 * @param {object} [options.body.options]
 *
 * @param {boolean} [options.body.options.runDownstreamAfterMerge]
 *
 * @param {string} [options.operationType] The workflow operation type.
 *
 * @param {array} [options.identifiers] A list of workflow identifiers.
 *
 * @param {boolean} [options.forceRunRequested] Whether to request a force run.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _submitAWorkflowJob(instanceId, workflowName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;
  let operationType = (options && options.operationType !== undefined) ? options.operationType : undefined;
  let identifiers = (options && options.identifiers !== undefined) ? options.identifiers : undefined;
  let forceRunRequested = (options && options.forceRunRequested !== undefined) ? options.forceRunRequested : false;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (workflowName === null || workflowName === undefined || typeof workflowName.valueOf() !== 'string') {
      throw new Error('workflowName cannot be null or undefined and it must be of type string.');
    }
    if (operationType !== null && operationType !== undefined && typeof operationType.valueOf() !== 'string') {
      throw new Error('operationType must be of type string.');
    }
    if (Array.isArray(identifiers)) {
      for (let i = 0; i < identifiers.length; i++) {
        if (identifiers[i] !== null && identifiers[i] !== undefined && typeof identifiers[i].valueOf() !== 'string') {
          throw new Error('identifiers[i] must be of type string.');
        }
      }
    }
    if (forceRunRequested !== null && forceRunRequested !== undefined && typeof forceRunRequested !== 'boolean') {
      throw new Error('forceRunRequested must be of type boolean.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/workflows/{workflowName}/jobs';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{workflowName}', encodeURIComponent(workflowName));
  let queryParameters = [];
  if (operationType !== null && operationType !== undefined) {
    queryParameters.push('operationType=' + encodeURIComponent(operationType));
  }
  if (identifiers !== null && identifiers !== undefined) {
    queryParameters.push('identifiers=' + encodeURIComponent(identifiers.join(',')));
  }
  if (forceRunRequested !== null && forceRunRequested !== undefined) {
    queryParameters.push('forceRunRequested=' + encodeURIComponent(forceRunRequested.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = new client.models['InstancesInstanceIdWorkflowsWorkflowNameJobsPostRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GraphJobInfo']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary ListWorkflowHistory
 *
 * Retrieves a list of historic task information for a workflow.
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {string} workflowName The name of the workflow.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {number} [options.top] Format - int32. The number of task
 * informations to retrieve.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getListOfWorkflowTaskInformationHistory(instanceId, workflowName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let top = (options && options.top !== undefined) ? options.top : 10;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (workflowName === null || workflowName === undefined || typeof workflowName.valueOf() !== 'string') {
      throw new Error('workflowName cannot be null or undefined and it must be of type string.');
    }
    if (top !== null && top !== undefined && typeof top !== 'number') {
      throw new Error('top must be of type number.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/workflows/{workflowName}/history';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{workflowName}', encodeURIComponent(workflowName));
  let queryParameters = [];
  if (top !== null && top !== undefined) {
    queryParameters.push('top=' + encodeURIComponent(top.toString()));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'GraphTaskInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'GraphTaskInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetWorkflowStatus
 *
 * Gets the current status for a workflow.
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {string} workflowName The workflow name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getWorkflowStatus(instanceId, workflowName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (workflowName === null || workflowName === undefined || typeof workflowName.valueOf() !== 'string') {
      throw new Error('workflowName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/workflows/{workflowName}/status';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{workflowName}', encodeURIComponent(workflowName));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'GraphNodeInfoElementType',
                  type: {
                    name: 'Composite',
                    className: 'GraphNodeInfo'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError2 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError2.request = msRest.stripRequest(httpRequest);
        deserializationError2.response = msRest.stripResponse(response);
        return callback(deserializationError2);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary ListSupportedTimezones
 *
 * Gets a list of supported timezones for creating workflow schedules.
 *
 * @param {string} workflowName Any workflow name.
 *
 * @param {string} instanceId
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSupportedTimezones(workflowName, instanceId, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (workflowName === null || workflowName === undefined || typeof workflowName.valueOf() !== 'string') {
      throw new Error('workflowName cannot be null or undefined and it must be of type string.');
    }
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/workflows/{workflowName}/schedules/supportedTimezones';
  requestUrl = requestUrl.replace('{workflowName}', encodeURIComponent(workflowName));
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'TimezoneDetailElementType',
                  type: {
                    name: 'Composite',
                    className: 'TimezoneDetail'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary ListAllWorkflowSchedules
 *
 * ListAllWorkflowSchedules
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {string} workflowName Any workflow name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getWorkflowSchedules(instanceId, workflowName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (workflowName === null || workflowName === undefined || typeof workflowName.valueOf() !== 'string') {
      throw new Error('workflowName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/workflows/{workflowName}/schedules';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{workflowName}', encodeURIComponent(workflowName));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = {
            required: false,
            serializedName: 'parsedResponse',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'WorkflowRefreshScheduleElementType',
                  type: {
                    name: 'Composite',
                    className: 'WorkflowRefreshSchedule'
                  }
              }
            }
          };
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary CreateWorkflowRefreshSchedule
 *
 * Create a workflow refresh schedule.
 *
 * @param {string} instanceId Format - uuid. The instance id.
 *
 * @param {string} workflowName Any workflow name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.body] A schedule object to create.
 *
 * @param {string} [options.body.operationType] Possible values include:
 * 'none', 'ingestion', 'derivedEntity', 'dataPreparation', 'map', 'match',
 * 'merge', 'profileStore', 'search', 'activity', 'attributeMeasures',
 * 'entityMeasures', 'measures', 'segmentation', 'enrichment', 'intelligence',
 * 'aiBuilder', 'insights', 'export', 'modelManagement', 'relationship',
 * 'roleAssignment', 'analysis', 'all'
 *
 * @param {string} [options.body.subType] Possible values include: 'noSubType',
 * 'templatedMeasures', 'createAnalysisModel', 'linkAnalysisModel',
 * 'singleActivityMapping', 'powerPlatform'
 *
 * @param {array} [options.body.identifiers] Gets the identifiers of the
 * schedule
 *
 * @param {string} [options.body.jobType] Possible values include: 'full',
 * 'incremental'
 *
 * @param {boolean} [options.body.isActive] Gets a value indicating whether the
 * schedule is active.
 *
 * @param {string} [options.body.timezoneId] Gets the ID of the timezone
 *
 * @param {array} [options.body.cronSchedules] Gets the schedule in CRON format
 *
 * @param {uuid} [options.body.scheduleId] Gets the ID of the schedule
 *
 * @param {uuid} [options.body.instanceId] Customer Insights instance id
 * associated with this object.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createWorkflowRefreshSchedule(instanceId, workflowName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let body = (options && options.body !== undefined) ? options.body : undefined;
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (workflowName === null || workflowName === undefined || typeof workflowName.valueOf() !== 'string') {
      throw new Error('workflowName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/workflows/{workflowName}/schedules';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{workflowName}', encodeURIComponent(workflowName));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json-patch+json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (body !== null && body !== undefined) {
      let requestModelMapper = new client.models['InstancesInstanceIdWorkflowsWorkflowNameSchedulesPostRequest']().mapper();
      requestModel = client.serialize(requestModelMapper, body, 'body');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(body, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['WorkflowRefreshSchedule']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 500) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * @summary GetEntityProfile
 *
 * Gets the entityProfile for the entity.
 *
 * @param {string} instanceId Format - uuid. Customer Insights instance id.
 *
 * @param {string} qualifiedEntityName Qualified Entity Name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getAnEntityProfile(instanceId, qualifiedEntityName, options, callback) {
   /* jshint validthis: true */
  let client = this;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (instanceId === null || instanceId === undefined || typeof instanceId.valueOf() !== 'string') {
      throw new Error('instanceId cannot be null or undefined and it must be of type string.');
    }
    if (qualifiedEntityName === null || qualifiedEntityName === undefined || typeof qualifiedEntityName.valueOf() !== 'string') {
      throw new Error('qualifiedEntityName cannot be null or undefined and it must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'instances/{instanceId}/dataprofile/{qualifiedEntityName}';
  requestUrl = requestUrl.replace('{instanceId}', encodeURIComponent(instanceId));
  requestUrl = requestUrl.replace('{qualifiedEntityName}', encodeURIComponent(qualifiedEntityName));

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 401 && statusCode !== 404 && statusCode !== 500 && statusCode !== 503) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['EntityDataProfile']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }
    // Deserialize Response
    if (statusCode === 404) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['ApiErrorResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError1 = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError1.request = msRest.stripRequest(httpRequest);
        deserializationError1.response = msRest.stripResponse(response);
        return callback(deserializationError1);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a CustomerInsights. */
class CustomerInsights extends ServiceClient {
  /**
   * Create a CustomerInsights.
   * @param {string} [baseUri] - The base URI of the service.
   * @param {object} [options] - The parameter options
   * @param {Array} [options.filters] - Filters to be added to the request pipeline
   * @param {object} [options.requestOptions] - Options for the underlying request object
   * {@link https://github.com/request/request#requestoptions-callback Options doc}
   * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
   */
  constructor(baseUri, options) {

    if (!options) options = {};

    super(null, options);

    this.baseUri = baseUri;
    if (!this.baseUri) {
      this.baseUri = 'https://api.ci.ai.dynamics.com/v1';
    }

    let packageInfo = this.getPackageJsonInfo(__dirname);
    this.addUserAgentInfo(`${packageInfo.name}/${packageInfo.version}`);
    this.models = models;
    this._getAnAttributeProfile = _getAnAttributeProfile;
    this._getAllDataSources = _getAllDataSources;
    this._getDataSource = _getDataSource;
    this._deleteADataSource = _deleteADataSource;
    this._createAnEntity = _createAnEntity;
    this._updateAnEntity = _updateAnEntity;
    this._getEntitiesWithODataPath = _getEntitiesWithODataPath;
    this._getAllEntityMetadata = _getAllEntityMetadata;
    this._getEntityMetadata = _getEntityMetadata;
    this._getEntitySize = _getEntitySize;
    this._resetAnInstance = _resetAnInstance;
    this._getAllInstances = _getAllInstances;
    this._getAllInstancesInBatchesByInstanceids = _getAllInstancesInBatchesByInstanceids;
    this._getInstanceMetadata = _getInstanceMetadata;
    this._deleteAnInstance = _deleteAnInstance;
    this._createAnInstance = _createAnInstance;
    this._updateAnInstance = _updateAnInstance;
    this._copyAnInstance = _copyAnInstance;
    this._getAListOfMeasuresMetadata = _getAListOfMeasuresMetadata;
    this._createAMeasure = _createAMeasure;
    this._getMetadataForAMeasure = _getMetadataForAMeasure;
    this._updateAMeasure = _updateAMeasure;
    this._deleteAMeasure = _deleteAMeasure;
    this._getKeyRing = _getKeyRing;
    this._getProfileStoreState = _getProfileStoreState;
    this._getAllRoleDefinitions = _getAllRoleDefinitions;
    this._getCurrentUserRole = _getCurrentUserRole;
    this._updateARoleAssignment = _updateARoleAssignment;
    this._deletesARoleAssignment = _deletesARoleAssignment;
    this._getAllRoleAssignments = _getAllRoleAssignments;
    this._getAllRelationships = _getAllRelationships;
    this._createARelationship = _createARelationship;
    this._getARelationship = _getARelationship;
    this._deleteARelationship = _deleteARelationship;
    this._updateARelationship = _updateARelationship;
    this._getSearchConfiguration = _getSearchConfiguration;
    this._updateSearchConfiguration = _updateSearchConfiguration;
    this._getAllSegments = _getAllSegments;
    this._createASegment = _createASegment;
    this._activateSegment = _activateSegment;
    this._deactivateSegment = _deactivateSegment;
    this._updateASegment = _updateASegment;
    this._deleteSegment = _deleteSegment;
    this._getAWorkflowJobInformation = _getAWorkflowJobInformation;
    this._cancelAWorkflowJob = _cancelAWorkflowJob;
    this._getListOfRecentWorkflowJobs = _getListOfRecentWorkflowJobs;
    this._submitAWorkflowJob = _submitAWorkflowJob;
    this._getListOfWorkflowTaskInformationHistory = _getListOfWorkflowTaskInformationHistory;
    this._getWorkflowStatus = _getWorkflowStatus;
    this._getSupportedTimezones = _getSupportedTimezones;
    this._getWorkflowSchedules = _getWorkflowSchedules;
    this._createWorkflowRefreshSchedule = _createWorkflowRefreshSchedule;
    this._getAnEntityProfile = _getAnEntityProfile;
    msRest.addSerializationMixin(this);
  }

  /**
   * @summary GetAttributeProfile
   *
   * Gets the specific attribute profile for the entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} qualifiedEntityName Qualified Entity Name.
   *
   * @param {string} attributeName Attribute Name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAnAttributeProfileWithHttpOperationResponse(instanceId, qualifiedEntityName, attributeName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAnAttributeProfile(instanceId, qualifiedEntityName, attributeName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetAttributeProfile
   *
   * Gets the specific attribute profile for the entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} qualifiedEntityName Qualified Entity Name.
   *
   * @param {string} attributeName Attribute Name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAnAttributeProfile(instanceId, qualifiedEntityName, attributeName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAnAttributeProfile(instanceId, qualifiedEntityName, attributeName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAnAttributeProfile(instanceId, qualifiedEntityName, attributeName, options, optionalCallback);
    }
  }

  /**
   * @summary GetAllDataSources
   *
   * Returns a collections of DataSourceInfo configured for the given Customer
   * Insights instance
   *
   * @param {string} instanceId Format - uuid. The instance id for which to fetch
   * data source info.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllDataSourcesWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllDataSources(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetAllDataSources
   *
   * Returns a collections of DataSourceInfo configured for the given Customer
   * Insights instance
   *
   * @param {string} instanceId Format - uuid. The instance id for which to fetch
   * data source info.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllDataSources(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllDataSources(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllDataSources(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary GetDataSource
   *
   * Fetches a DataSourceInfo matching the dataSourceId configured for the
   * Customer Insights instance.
   *
   * @param {string} instanceId Format - uuid. The instance id to fetch data
   * source info for.
   *
   * @param {string} dataSourceId Format - uuid. The data source id to fetch info
   * for.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getDataSourceWithHttpOperationResponse(instanceId, dataSourceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getDataSource(instanceId, dataSourceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetDataSource
   *
   * Fetches a DataSourceInfo matching the dataSourceId configured for the
   * Customer Insights instance.
   *
   * @param {string} instanceId Format - uuid. The instance id to fetch data
   * source info for.
   *
   * @param {string} dataSourceId Format - uuid. The data source id to fetch info
   * for.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getDataSource(instanceId, dataSourceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getDataSource(instanceId, dataSourceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getDataSource(instanceId, dataSourceId, options, optionalCallback);
    }
  }

  /**
   * @summary DeleteDataSource
   *
   * Deletes a data source from the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} dataSourceId Format - uuid. The data source id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteADataSourceWithHttpOperationResponse(instanceId, dataSourceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteADataSource(instanceId, dataSourceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary DeleteDataSource
   *
   * Deletes a data source from the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} dataSourceId Format - uuid. The data source id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteADataSource(instanceId, dataSourceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteADataSource(instanceId, dataSourceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteADataSource(instanceId, dataSourceId, options, optionalCallback);
    }
  }

  /**
   * @summary CreateEntity (Preview)
   *
   * Writes an entity instance into the store, g. an activity entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance Id.
   *
   * @param {string} entityName Fully qualified entity name, consisting of
   * 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.body] JSON document representing the entity. The
   * schema must be consistent with the entity metadata. Use GET action of this
   * resource to obtain an example.
   *
   * @param {string} [options.validUntil] Format - date-time (as date-time in
   * RFC3339). Expiration time of the change; ISO8601; optional. The value can be
   * maximum 30 days in the future. If the datasource for this entity doesn't
   * contain the changes after this time, the update disappears from the store.
   *
   * @param {string} [options.caller] String to identify the caller; optional.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createAnEntityWithHttpOperationResponse(instanceId, entityName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createAnEntity(instanceId, entityName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary CreateEntity (Preview)
   *
   * Writes an entity instance into the store, g. an activity entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance Id.
   *
   * @param {string} entityName Fully qualified entity name, consisting of
   * 'DataSource_EntityName' e.g. 'PoS_posPurchases', or 'UnifiedActivity'.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.body] JSON document representing the entity. The
   * schema must be consistent with the entity metadata. Use GET action of this
   * resource to obtain an example.
   *
   * @param {string} [options.validUntil] Format - date-time (as date-time in
   * RFC3339). Expiration time of the change; ISO8601; optional. The value can be
   * maximum 30 days in the future. If the datasource for this entity doesn't
   * contain the changes after this time, the update disappears from the store.
   *
   * @param {string} [options.caller] String to identify the caller; optional.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createAnEntity(instanceId, entityName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createAnEntity(instanceId, entityName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createAnEntity(instanceId, entityName, options, optionalCallback);
    }
  }

  /**
   * @summary UpdateEntity (Preview)
   *
   * Updates an entity instance in the store, g. Customer entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance Id.
   *
   * @param {string} entityName Fully qualified entity name, e.g. 'Customer'.
   *
   * @param {string} entityId Id of the entity to update, e.g. 'CustomerId' of a
   * Customer entity.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.body] JSON document with set of changes to apply on
   * the entity. Each change must be consistent with the entity metadata. Use GET
   * action of this resource to obtain an example.
   *
   * @param {string} [options.validUntil] Format - date-time (as date-time in
   * RFC3339). Expiration time of the change; ISO8601; optional. The value can be
   * maximum 30 days in the future. If the datasource for this entity doesn't
   * contain the changes after this time, the update disappears from the store.
   *
   * @param {string} [options.caller] String to identify the caller; optional.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateAnEntityWithHttpOperationResponse(instanceId, entityName, entityId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateAnEntity(instanceId, entityName, entityId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary UpdateEntity (Preview)
   *
   * Updates an entity instance in the store, g. Customer entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance Id.
   *
   * @param {string} entityName Fully qualified entity name, e.g. 'Customer'.
   *
   * @param {string} entityId Id of the entity to update, e.g. 'CustomerId' of a
   * Customer entity.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.body] JSON document with set of changes to apply on
   * the entity. Each change must be consistent with the entity metadata. Use GET
   * action of this resource to obtain an example.
   *
   * @param {string} [options.validUntil] Format - date-time (as date-time in
   * RFC3339). Expiration time of the change; ISO8601; optional. The value can be
   * maximum 30 days in the future. If the datasource for this entity doesn't
   * contain the changes after this time, the update disappears from the store.
   *
   * @param {string} [options.caller] String to identify the caller; optional.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateAnEntity(instanceId, entityName, entityId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateAnEntity(instanceId, entityName, entityId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateAnEntity(instanceId, entityName, entityId, options, optionalCallback);
    }
  }

  /**
   * @summary GetEntityByODataQuery
   *
   * Submits an OData request to the service.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} relativePath Relative OData path. See
   * https://www.odata.org/getting-started/basic-tutorial/ for info.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceSearch] Whether force use search to support
   * the query.
   *
   * @param {boolean} [options.proxy] Whether or not we are requesting data by
   * proxy.
   *
   * @param {string} [options.search] Search OData parameter.
   *
   * @param {string} [options.select] Select OData parameter.
   *
   * @param {string} [options.skip] Skip OData parameter.
   *
   * @param {string} [options.skiptoken] SkipToken OData parameter.
   *
   * @param {string} [options.filter] Filter OData parameter.
   *
   * @param {string} [options.orderby] OrderBy OData parameter.
   *
   * @param {string} [options.expand] Expand OData parameter.
   *
   * @param {string} [options.top] Top OData parameter.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getEntitiesWithODataPathWithHttpOperationResponse(instanceId, relativePath, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getEntitiesWithODataPath(instanceId, relativePath, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetEntityByODataQuery
   *
   * Submits an OData request to the service.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} relativePath Relative OData path. See
   * https://www.odata.org/getting-started/basic-tutorial/ for info.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.forceSearch] Whether force use search to support
   * the query.
   *
   * @param {boolean} [options.proxy] Whether or not we are requesting data by
   * proxy.
   *
   * @param {string} [options.search] Search OData parameter.
   *
   * @param {string} [options.select] Select OData parameter.
   *
   * @param {string} [options.skip] Skip OData parameter.
   *
   * @param {string} [options.skiptoken] SkipToken OData parameter.
   *
   * @param {string} [options.filter] Filter OData parameter.
   *
   * @param {string} [options.orderby] OrderBy OData parameter.
   *
   * @param {string} [options.expand] Expand OData parameter.
   *
   * @param {string} [options.top] Top OData parameter.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntitiesWithODataPath(instanceId, relativePath, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getEntitiesWithODataPath(instanceId, relativePath, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getEntitiesWithODataPath(instanceId, relativePath, options, optionalCallback);
    }
  }

  /**
   * @summary GetAllEntitiesMetadata
   *
   * Retrieves the flattened entity model for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.attributesAnnotations] Indicates if extra
   * annotations like 'ReadOnly' or 'Mandatory' should be included.
   *
   * @param {boolean} [options.includeQuarantined] Indicates if quarantined
   * entities should be included in the output entity model.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllEntityMetadataWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllEntityMetadata(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetAllEntitiesMetadata
   *
   * Retrieves the flattened entity model for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.attributesAnnotations] Indicates if extra
   * annotations like 'ReadOnly' or 'Mandatory' should be included.
   *
   * @param {boolean} [options.includeQuarantined] Indicates if quarantined
   * entities should be included in the output entity model.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllEntityMetadata(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllEntityMetadata(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllEntityMetadata(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary GetEntityMetadata
   *
   * Retrieves the entity metadata for the provided instanceId and entityName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} entityName Entity name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.attributesAnnotations] Indicates if extra
   * annotations like 'ReadOnly' or 'Mandatory' should be included.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getEntityMetadataWithHttpOperationResponse(instanceId, entityName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getEntityMetadata(instanceId, entityName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetEntityMetadata
   *
   * Retrieves the entity metadata for the provided instanceId and entityName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} entityName Entity name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.attributesAnnotations] Indicates if extra
   * annotations like 'ReadOnly' or 'Mandatory' should be included.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntityMetadata(instanceId, entityName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getEntityMetadata(instanceId, entityName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getEntityMetadata(instanceId, entityName, options, optionalCallback);
    }
  }

  /**
   * @summary GetEntitySize
   *
   * Retrieves the entity size for the provided instanceId and entityName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} entityName Entity name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getEntitySizeWithHttpOperationResponse(instanceId, entityName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getEntitySize(instanceId, entityName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetEntitySize
   *
   * Retrieves the entity size for the provided instanceId and entityName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} entityName Entity name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getEntitySize(instanceId, entityName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getEntitySize(instanceId, entityName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getEntitySize(instanceId, entityName, options, optionalCallback);
    }
  }

  /**
   * @summary ResetInstance
   *
   * Reset scopes in the given instance. Provide optional management operation
   * scope to reset only that scope.
   *
   * @param {string} instanceId Format - uuid. The instance Id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.instanceManagementOperationScope] The management
   * operation scope for reset.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  resetAnInstanceWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._resetAnInstance(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary ResetInstance
   *
   * Reset scopes in the given instance. Provide optional management operation
   * scope to reset only that scope.
   *
   * @param {string} instanceId Format - uuid. The instance Id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.instanceManagementOperationScope] The management
   * operation scope for reset.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  resetAnInstance(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._resetAnInstance(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._resetAnInstance(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary ListAllInstances
   *
   * Retrieves all instances of the current user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllInstancesWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllInstances(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary ListAllInstances
   *
   * Retrieves all instances of the current user.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllInstances(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllInstances(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllInstances(options, optionalCallback);
    }
  }

  /**
   * @summary ListInstancesByInstanceIds
   *
   * Retrieves instances based on instance ids, it can only accept batch of
   * instances.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {array} [options.body] Instance ids of instances to get.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllInstancesInBatchesByInstanceidsWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllInstancesInBatchesByInstanceids(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary ListInstancesByInstanceIds
   *
   * Retrieves instances based on instance ids, it can only accept batch of
   * instances.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {array} [options.body] Instance ids of instances to get.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllInstancesInBatchesByInstanceids(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllInstancesInBatchesByInstanceids(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllInstancesInBatchesByInstanceids(options, optionalCallback);
    }
  }

  /**
   * @summary GetInstance
   *
   * Retrieves metadata for a Customer Insights instance based on its instanceId.
   *
   * @param {string} instanceId Format - uuid. Unique id for the Customer
   * Insights instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getInstanceMetadataWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getInstanceMetadata(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetInstance
   *
   * Retrieves metadata for a Customer Insights instance based on its instanceId.
   *
   * @param {string} instanceId Format - uuid. Unique id for the Customer
   * Insights instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getInstanceMetadata(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getInstanceMetadata(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getInstanceMetadata(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary DeleteInstance
   *
   * Delete an instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteAnInstanceWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteAnInstance(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary DeleteInstance
   *
   * Delete an instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteAnInstance(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteAnInstance(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteAnInstance(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary CreateInstance
   *
   * Creates a new instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The instance creation request.
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {boolean} [options.body.instanceMetadata.refreshSchedule.isActive]
   * Gets a value indicating whether the schedule is active.
   *
   * @param {string} [options.body.instanceMetadata.refreshSchedule.timezoneId]
   * Gets the ID of the timezone
   *
   * @param {array} [options.body.instanceMetadata.refreshSchedule.cronSchedules]
   * Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.scheduleId]
   * Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.instanceId]
   * Customer Insights instance id associated with this object.
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * datalake folder Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds datalake folder unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {number} [options.body.instanceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.instanceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.instanceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.instanceMetadata.createdBy] Email address of
   * the user who created this record.
   *
   * @param {date} [options.body.instanceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.instanceMetadata.instanceId] Customer Insights
   * instance id associated with this object.
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp', 'facebookAds',
   * 'http', 'mailchimp', 'googleAds', 'marketo'
   *
   * @param {uuid} [options.body.cdsResourceMetadata.resourceId] Gets the Id of
   * the resource.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.operationId] Gets the Id of
   * the operation being performed on the resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.resourceType] Possible
   * values include: 'adlsGen2', 'd365Sales', 'cds', 'ftp',
   * 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'facebookAds', 'http', 'mailchimp', 'googleAds', 'marketo'
   *
   * @param {string} [options.body.cdsResourceMetadata.name] Gets the Name of the
   * resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.description] Gets the
   * Description of the resource.
   *
   * @param {number} [options.body.cdsResourceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.cdsResourceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.cdsResourceMetadata.createdBy] Email address
   * of the user who created this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.instanceId] Customer
   * Insights instance id associated with this object.
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createAnInstanceWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createAnInstance(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary CreateInstance
   *
   * Creates a new instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The instance creation request.
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {boolean} [options.body.instanceMetadata.refreshSchedule.isActive]
   * Gets a value indicating whether the schedule is active.
   *
   * @param {string} [options.body.instanceMetadata.refreshSchedule.timezoneId]
   * Gets the ID of the timezone
   *
   * @param {array} [options.body.instanceMetadata.refreshSchedule.cronSchedules]
   * Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.scheduleId]
   * Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.instanceId]
   * Customer Insights instance id associated with this object.
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * datalake folder Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds datalake folder unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {number} [options.body.instanceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.instanceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.instanceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.instanceMetadata.createdBy] Email address of
   * the user who created this record.
   *
   * @param {date} [options.body.instanceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.instanceMetadata.instanceId] Customer Insights
   * instance id associated with this object.
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp', 'facebookAds',
   * 'http', 'mailchimp', 'googleAds', 'marketo'
   *
   * @param {uuid} [options.body.cdsResourceMetadata.resourceId] Gets the Id of
   * the resource.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.operationId] Gets the Id of
   * the operation being performed on the resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.resourceType] Possible
   * values include: 'adlsGen2', 'd365Sales', 'cds', 'ftp',
   * 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'facebookAds', 'http', 'mailchimp', 'googleAds', 'marketo'
   *
   * @param {string} [options.body.cdsResourceMetadata.name] Gets the Name of the
   * resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.description] Gets the
   * Description of the resource.
   *
   * @param {number} [options.body.cdsResourceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.cdsResourceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.cdsResourceMetadata.createdBy] Email address
   * of the user who created this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.instanceId] Customer
   * Insights instance id associated with this object.
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createAnInstance(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createAnInstance(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createAnInstance(options, optionalCallback);
    }
  }

  /**
   * @summary UpdateInstance
   *
   * Patches the Market Verticals, Display name, Domain Name, CDS environment and
   * BYOSA secret to the instance.
   *
   * @param {string} instanceId Format - uuid.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body]
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {boolean} [options.body.instanceMetadata.refreshSchedule.isActive]
   * Gets a value indicating whether the schedule is active.
   *
   * @param {string} [options.body.instanceMetadata.refreshSchedule.timezoneId]
   * Gets the ID of the timezone
   *
   * @param {array} [options.body.instanceMetadata.refreshSchedule.cronSchedules]
   * Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.scheduleId]
   * Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.instanceId]
   * Customer Insights instance id associated with this object.
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * datalake folder Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds datalake folder unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {number} [options.body.instanceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.instanceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.instanceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.instanceMetadata.createdBy] Email address of
   * the user who created this record.
   *
   * @param {date} [options.body.instanceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.instanceMetadata.instanceId] Customer Insights
   * instance id associated with this object.
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp', 'facebookAds',
   * 'http', 'mailchimp', 'googleAds', 'marketo'
   *
   * @param {uuid} [options.body.cdsResourceMetadata.resourceId] Gets the Id of
   * the resource.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.operationId] Gets the Id of
   * the operation being performed on the resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.resourceType] Possible
   * values include: 'adlsGen2', 'd365Sales', 'cds', 'ftp',
   * 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'facebookAds', 'http', 'mailchimp', 'googleAds', 'marketo'
   *
   * @param {string} [options.body.cdsResourceMetadata.name] Gets the Name of the
   * resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.description] Gets the
   * Description of the resource.
   *
   * @param {number} [options.body.cdsResourceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.cdsResourceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.cdsResourceMetadata.createdBy] Email address
   * of the user who created this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.instanceId] Customer
   * Insights instance id associated with this object.
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateAnInstanceWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateAnInstance(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary UpdateInstance
   *
   * Patches the Market Verticals, Display name, Domain Name, CDS environment and
   * BYOSA secret to the instance.
   *
   * @param {string} instanceId Format - uuid.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body]
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {boolean} [options.body.instanceMetadata.refreshSchedule.isActive]
   * Gets a value indicating whether the schedule is active.
   *
   * @param {string} [options.body.instanceMetadata.refreshSchedule.timezoneId]
   * Gets the ID of the timezone
   *
   * @param {array} [options.body.instanceMetadata.refreshSchedule.cronSchedules]
   * Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.scheduleId]
   * Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.instanceId]
   * Customer Insights instance id associated with this object.
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * datalake folder Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds datalake folder unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {number} [options.body.instanceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.instanceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.instanceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.instanceMetadata.createdBy] Email address of
   * the user who created this record.
   *
   * @param {date} [options.body.instanceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.instanceMetadata.instanceId] Customer Insights
   * instance id associated with this object.
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp', 'facebookAds',
   * 'http', 'mailchimp', 'googleAds', 'marketo'
   *
   * @param {uuid} [options.body.cdsResourceMetadata.resourceId] Gets the Id of
   * the resource.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.operationId] Gets the Id of
   * the operation being performed on the resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.resourceType] Possible
   * values include: 'adlsGen2', 'd365Sales', 'cds', 'ftp',
   * 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'facebookAds', 'http', 'mailchimp', 'googleAds', 'marketo'
   *
   * @param {string} [options.body.cdsResourceMetadata.name] Gets the Name of the
   * resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.description] Gets the
   * Description of the resource.
   *
   * @param {number} [options.body.cdsResourceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.cdsResourceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.cdsResourceMetadata.createdBy] Email address
   * of the user who created this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.instanceId] Customer
   * Insights instance id associated with this object.
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateAnInstance(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateAnInstance(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateAnInstance(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary CopyInstance
   *
   * Create a new instance and copy metadata from an existing instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The metadata to use to create the new
   * instance.
   *
   * @param {uuid} [options.body.instanceIdToCopy]
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {boolean} [options.body.instanceMetadata.refreshSchedule.isActive]
   * Gets a value indicating whether the schedule is active.
   *
   * @param {string} [options.body.instanceMetadata.refreshSchedule.timezoneId]
   * Gets the ID of the timezone
   *
   * @param {array} [options.body.instanceMetadata.refreshSchedule.cronSchedules]
   * Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.scheduleId]
   * Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.instanceId]
   * Customer Insights instance id associated with this object.
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * datalake folder Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds datalake folder unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {number} [options.body.instanceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.instanceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.instanceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.instanceMetadata.createdBy] Email address of
   * the user who created this record.
   *
   * @param {date} [options.body.instanceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.instanceMetadata.instanceId] Customer Insights
   * instance id associated with this object.
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp', 'facebookAds',
   * 'http', 'mailchimp', 'googleAds', 'marketo'
   *
   * @param {uuid} [options.body.cdsResourceMetadata.resourceId] Gets the Id of
   * the resource.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.operationId] Gets the Id of
   * the operation being performed on the resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.resourceType] Possible
   * values include: 'adlsGen2', 'd365Sales', 'cds', 'ftp',
   * 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'facebookAds', 'http', 'mailchimp', 'googleAds', 'marketo'
   *
   * @param {string} [options.body.cdsResourceMetadata.name] Gets the Name of the
   * resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.description] Gets the
   * Description of the resource.
   *
   * @param {number} [options.body.cdsResourceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.cdsResourceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.cdsResourceMetadata.createdBy] Email address
   * of the user who created this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.instanceId] Customer
   * Insights instance id associated with this object.
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  copyAnInstanceWithHttpOperationResponse(options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._copyAnInstance(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary CopyInstance
   *
   * Create a new instance and copy metadata from an existing instance.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The metadata to use to create the new
   * instance.
   *
   * @param {uuid} [options.body.instanceIdToCopy]
   *
   * @param {object} [options.body.instanceMetadata]
   *
   * @param {string} [options.body.instanceMetadata.name] Gets the user defined
   * instance name.
   *
   * @param {string} [options.body.instanceMetadata.provisioningState] Possible
   * values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress'
   *
   * @param {string} [options.body.instanceMetadata.instanceType] Possible values
   * include: 'trial', 'sandbox', 'production'
   *
   * @param {object} [options.body.instanceMetadata.refreshSchedule]
   *
   * @param {boolean} [options.body.instanceMetadata.refreshSchedule.isActive]
   * Gets a value indicating whether the schedule is active.
   *
   * @param {string} [options.body.instanceMetadata.refreshSchedule.timezoneId]
   * Gets the ID of the timezone
   *
   * @param {array} [options.body.instanceMetadata.refreshSchedule.cronSchedules]
   * Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.scheduleId]
   * Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceMetadata.refreshSchedule.instanceId]
   * Customer Insights instance id associated with this object.
   *
   * @param {date} [options.body.instanceMetadata.expiryTimeUtc] Gets the time
   * the instance is set to expire.
   *
   * @param {string} [options.body.instanceMetadata.region] Gets the Azure region
   * where the instance lives.
   *
   * @param {object} [options.body.instanceMetadata.cdsOrgInfo]
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.friendlyName] Gets
   * the Cds Organization Friendly Name
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.url] Gets the Cds
   * Organization Url
   *
   * @param {string} [options.body.instanceMetadata.cdsOrgInfo.state] Gets the
   * Cds Organization State
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.privateWorkSpace]
   *
   * @param {object} [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace]
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.name] Gets the
   * datalake folder Friendly Name
   *
   * @param {string}
   * [options.body.instanceMetadata.cdsMdlInfo.publicWorkSpace.uniqueName] Gets
   * the Cds datalake folder unique Name
   *
   * @param {number} [options.body.instanceMetadata.maxTrialExtensionsAllowed]
   * Gets the total number of extensions allowed if this is trial instance
   *
   * @param {string} [options.body.instanceMetadata.trialExtensionHistory] Stores
   * the details of trial extensions done if this is a trial instance
   *
   * @param {number} [options.body.instanceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.instanceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.instanceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.instanceMetadata.createdBy] Email address of
   * the user who created this record.
   *
   * @param {date} [options.body.instanceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.instanceMetadata.instanceId] Customer Insights
   * instance id associated with this object.
   *
   * @param {object} [options.body.byosaResourceMetadata]
   *
   * @param {object} [options.body.cdsResourceMetadata]
   *
   * @param {string} [options.body.cdsResourceMetadata.kind] Possible values
   * include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp', 'facebookAds',
   * 'http', 'mailchimp', 'googleAds', 'marketo'
   *
   * @param {uuid} [options.body.cdsResourceMetadata.resourceId] Gets the Id of
   * the resource.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.operationId] Gets the Id of
   * the operation being performed on the resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.resourceType] Possible
   * values include: 'adlsGen2', 'd365Sales', 'cds', 'ftp',
   * 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection',
   * 'facebookAds', 'http', 'mailchimp', 'googleAds', 'marketo'
   *
   * @param {string} [options.body.cdsResourceMetadata.name] Gets the Name of the
   * resource.
   *
   * @param {string} [options.body.cdsResourceMetadata.description] Gets the
   * Description of the resource.
   *
   * @param {number} [options.body.cdsResourceMetadata.version] Version number of
   * this object.
   *
   * @param {string} [options.body.cdsResourceMetadata.updatedBy] UPN of the user
   * who last updated this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.updatedUtc] Time this object
   * was last updated.
   *
   * @param {string} [options.body.cdsResourceMetadata.createdBy] Email address
   * of the user who created this record.
   *
   * @param {date} [options.body.cdsResourceMetadata.createdUtc] Time this object
   * was initially created.
   *
   * @param {uuid} [options.body.cdsResourceMetadata.instanceId] Customer
   * Insights instance id associated with this object.
   *
   * @param {string} [options.body.bapProvisioningType] Possible values include:
   * 'skip', 'create', 'attach'
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  copyAnInstance(options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._copyAnInstance(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._copyAnInstance(options, optionalCallback);
    }
  }

  /**
   * @summary ListAllMeasuresMetadata
   *
   * ListAllMeasuresMetadata
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAListOfMeasuresMetadataWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAListOfMeasuresMetadata(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary ListAllMeasuresMetadata
   *
   * ListAllMeasuresMetadata
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAListOfMeasuresMetadata(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAListOfMeasuresMetadata(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAListOfMeasuresMetadata(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary CreateMeasure
   *
   * CreateMeasure
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Measure metadata to be created
   *
   * @param {string} [options.body.displayName]
   *
   * @param {string} [options.body.name] Unique name of the measure
   *
   * @param {string} [options.body.description] Description of the measure.
   *
   * @param {object} [options.body.definition]
   *
   * @param {string} [options.body.definition.kind] Possible values include:
   * 'entity', 'attribute'
   *
   * @param {boolean} [options.body.definition.isScalar] Gets a value indicating
   * whether the current measure is a scalar measure e doesn't have any
   * dimensions
   *
   * @param {array} [options.body.definition.linkedEntities] Gets list of linked
   * entities associated with the measure.
   *
   * @param {array} [options.body.definition.variables] Gets list of variables
   * (computed columns) for the measure.
   *
   * @param {object} [options.body.definition.filters]
   *
   * @param {string} [options.body.definition.filters.kind] Possible values
   * include: 'constant', 'property', 'memberAccess', 'functionCall', 'and',
   * 'or', 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo',
   * 'lessThan', 'lessThanOrEqualTo', 'contains', 'startsWith', 'endsWith',
   * 'isNull', 'isNotNull', 'negate', 'add', 'subtract', 'multiply', 'divide',
   * 'modulo', 'exponent', 'today', 'now'
   *
   * @param {object} [options.body.definition.filteringCriteria]
   *
   * @param {string} [options.body.definition.filteringCriteria.logicalOperator]
   * Possible values include: 'and', 'or'
   *
   * @param {string} [options.body.definition.filteringCriteria.attribute] Gets
   * the Attribute of the entity used in segment criteria.
   *
   * @param {string}
   * [options.body.definition.filteringCriteria.comparisonOperator] Possible
   * values include: 'equals', 'notEquals', 'greaterThan',
   * 'greaterThanOrEqualTo', 'lessThan', 'lessThanOrEqualTo', 'any', 'contains',
   * 'startsWith', 'endsWith', 'isNull', 'isNotNull', 'all', 'isIn',
   * 'isWithinLast', 'isBetween', 'isNotBetween', 'yearToDate', 'dayOf',
   * 'monthOf', 'yearOf', 'dayOfWeek', 'timeAt'
   *
   * @param {array} [options.body.definition.filteringCriteria.childCriterias]
   * Gets the list of Child criteria of segment.
   *
   * @param {string} [options.body.definition.filteringCriteria.value] Gets the
   * Value in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.ignoreCase] Gets
   * a value indicating whether case is ignored for this criteria.
   *
   * @param {array} [options.body.definition.filteringCriteria.listOfValues] Gets
   * the list of values in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.isTime] flag set
   * to true if entries are of time format
   *
   * @param {array} [options.body.definition.dimensions] Gets list of dimensions
   * with the measure.
   *
   * @param {array} [options.body.definition.aggregates] Gets list of aggregates
   * of the measure.
   *
   * @param {boolean} [options.body.definition.isProfile] Gets a value indicating
   * whether the current measure is a profile measure
   *
   * @param {string} [options.body.definition.measureQuerySql] Gets the user
   * specified custom SQL query.
   *
   * @param {string} [options.body.definition.type] Possible values include:
   * 'structured', 'manual'
   *
   * @param {boolean} [options.body.definition.isManualQueryScalar] Gets the
   * indicating whether the Business Measure is Scalar or not.
   *
   * @param {array} [options.body.definition.dependencies] Gets the list of
   * measures that this measure depends on.
   *
   * @param {object} [options.body.latestEvaluation]
   *
   * @param {uuid} [options.body.latestEvaluation.lastSuccessfulRunId]
   *
   * @param {string} [options.body.latestEvaluation.state] Possible values
   * include: 'none', 'running', 'failed', 'completed'
   *
   * @param {date} [options.body.latestEvaluation.endTime] Evaluation completion
   * time.
   *
   * @param {string} [options.body.latestEvaluation.error] Error Information (if
   * any) that occured during the measure evaluation.
   *
   * @param {object} [options.body.output]
   *
   * @param {object} [options.body.output.values] Output folder path for the
   * evaluation.
   *
   * @param {string} [options.body.output.measureName]
   *
   * @param {date} [options.body.output.evaluationTime] Gets the evaluation start
   * time.
   *
   * @param {object} [options.body.evaluationStats]
   *
   * @param {date} [options.body.evaluationStats.lastSuccessful] Last successful
   * evaluation
   *
   * @param {number} [options.body.evaluationStats.consecutiveFailureCount]
   * Represents Number of consecutive failures
   *
   * @param {object} [options.body.errorDescription]
   *
   * @param {string} [options.body.errorDescription.value]
   *
   * @param {string} [options.body.errorDescription.key] Possible values include:
   * 'activityMappingDuplicateMappingOnEntity', 'activityMappingEmptyInput',
   * 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.errorDescription.args]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationHistory] Evaluation history for the
   * measure. (not persisted in store)
   *
   * @param {array} [options.body.outputHistory] Output history for the measure.
   * (not persisted in store)
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createAMeasureWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createAMeasure(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary CreateMeasure
   *
   * CreateMeasure
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Measure metadata to be created
   *
   * @param {string} [options.body.displayName]
   *
   * @param {string} [options.body.name] Unique name of the measure
   *
   * @param {string} [options.body.description] Description of the measure.
   *
   * @param {object} [options.body.definition]
   *
   * @param {string} [options.body.definition.kind] Possible values include:
   * 'entity', 'attribute'
   *
   * @param {boolean} [options.body.definition.isScalar] Gets a value indicating
   * whether the current measure is a scalar measure e doesn't have any
   * dimensions
   *
   * @param {array} [options.body.definition.linkedEntities] Gets list of linked
   * entities associated with the measure.
   *
   * @param {array} [options.body.definition.variables] Gets list of variables
   * (computed columns) for the measure.
   *
   * @param {object} [options.body.definition.filters]
   *
   * @param {string} [options.body.definition.filters.kind] Possible values
   * include: 'constant', 'property', 'memberAccess', 'functionCall', 'and',
   * 'or', 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo',
   * 'lessThan', 'lessThanOrEqualTo', 'contains', 'startsWith', 'endsWith',
   * 'isNull', 'isNotNull', 'negate', 'add', 'subtract', 'multiply', 'divide',
   * 'modulo', 'exponent', 'today', 'now'
   *
   * @param {object} [options.body.definition.filteringCriteria]
   *
   * @param {string} [options.body.definition.filteringCriteria.logicalOperator]
   * Possible values include: 'and', 'or'
   *
   * @param {string} [options.body.definition.filteringCriteria.attribute] Gets
   * the Attribute of the entity used in segment criteria.
   *
   * @param {string}
   * [options.body.definition.filteringCriteria.comparisonOperator] Possible
   * values include: 'equals', 'notEquals', 'greaterThan',
   * 'greaterThanOrEqualTo', 'lessThan', 'lessThanOrEqualTo', 'any', 'contains',
   * 'startsWith', 'endsWith', 'isNull', 'isNotNull', 'all', 'isIn',
   * 'isWithinLast', 'isBetween', 'isNotBetween', 'yearToDate', 'dayOf',
   * 'monthOf', 'yearOf', 'dayOfWeek', 'timeAt'
   *
   * @param {array} [options.body.definition.filteringCriteria.childCriterias]
   * Gets the list of Child criteria of segment.
   *
   * @param {string} [options.body.definition.filteringCriteria.value] Gets the
   * Value in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.ignoreCase] Gets
   * a value indicating whether case is ignored for this criteria.
   *
   * @param {array} [options.body.definition.filteringCriteria.listOfValues] Gets
   * the list of values in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.isTime] flag set
   * to true if entries are of time format
   *
   * @param {array} [options.body.definition.dimensions] Gets list of dimensions
   * with the measure.
   *
   * @param {array} [options.body.definition.aggregates] Gets list of aggregates
   * of the measure.
   *
   * @param {boolean} [options.body.definition.isProfile] Gets a value indicating
   * whether the current measure is a profile measure
   *
   * @param {string} [options.body.definition.measureQuerySql] Gets the user
   * specified custom SQL query.
   *
   * @param {string} [options.body.definition.type] Possible values include:
   * 'structured', 'manual'
   *
   * @param {boolean} [options.body.definition.isManualQueryScalar] Gets the
   * indicating whether the Business Measure is Scalar or not.
   *
   * @param {array} [options.body.definition.dependencies] Gets the list of
   * measures that this measure depends on.
   *
   * @param {object} [options.body.latestEvaluation]
   *
   * @param {uuid} [options.body.latestEvaluation.lastSuccessfulRunId]
   *
   * @param {string} [options.body.latestEvaluation.state] Possible values
   * include: 'none', 'running', 'failed', 'completed'
   *
   * @param {date} [options.body.latestEvaluation.endTime] Evaluation completion
   * time.
   *
   * @param {string} [options.body.latestEvaluation.error] Error Information (if
   * any) that occured during the measure evaluation.
   *
   * @param {object} [options.body.output]
   *
   * @param {object} [options.body.output.values] Output folder path for the
   * evaluation.
   *
   * @param {string} [options.body.output.measureName]
   *
   * @param {date} [options.body.output.evaluationTime] Gets the evaluation start
   * time.
   *
   * @param {object} [options.body.evaluationStats]
   *
   * @param {date} [options.body.evaluationStats.lastSuccessful] Last successful
   * evaluation
   *
   * @param {number} [options.body.evaluationStats.consecutiveFailureCount]
   * Represents Number of consecutive failures
   *
   * @param {object} [options.body.errorDescription]
   *
   * @param {string} [options.body.errorDescription.value]
   *
   * @param {string} [options.body.errorDescription.key] Possible values include:
   * 'activityMappingDuplicateMappingOnEntity', 'activityMappingEmptyInput',
   * 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.errorDescription.args]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationHistory] Evaluation history for the
   * measure. (not persisted in store)
   *
   * @param {array} [options.body.outputHistory] Output history for the measure.
   * (not persisted in store)
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createAMeasure(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createAMeasure(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createAMeasure(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary GetMeasureMetadata
   *
   * Retrieves the measure metadata for the provided instanceId and measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeHistoricStats] Boolean for historical stats
   *
   * @param {number} [options.historicStatsDays] Format - int32. Number of
   * lookback days
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getMetadataForAMeasureWithHttpOperationResponse(instanceId, measureName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getMetadataForAMeasure(instanceId, measureName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetMeasureMetadata
   *
   * Retrieves the measure metadata for the provided instanceId and measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeHistoricStats] Boolean for historical stats
   *
   * @param {number} [options.historicStatsDays] Format - int32. Number of
   * lookback days
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getMetadataForAMeasure(instanceId, measureName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getMetadataForAMeasure(instanceId, measureName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getMetadataForAMeasure(instanceId, measureName, options, optionalCallback);
    }
  }

  /**
   * @summary UpdateMeasure
   *
   * Updates measures metadata for the provided instanceId and measureMetadata.
   * Existing measure is retrieved using measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] Update measure metadata
   *
   * @param {string} [options.body.displayName]
   *
   * @param {string} [options.body.name] Unique name of the measure
   *
   * @param {string} [options.body.description] Description of the measure.
   *
   * @param {object} [options.body.definition]
   *
   * @param {string} [options.body.definition.kind] Possible values include:
   * 'entity', 'attribute'
   *
   * @param {boolean} [options.body.definition.isScalar] Gets a value indicating
   * whether the current measure is a scalar measure e doesn't have any
   * dimensions
   *
   * @param {array} [options.body.definition.linkedEntities] Gets list of linked
   * entities associated with the measure.
   *
   * @param {array} [options.body.definition.variables] Gets list of variables
   * (computed columns) for the measure.
   *
   * @param {object} [options.body.definition.filters]
   *
   * @param {string} [options.body.definition.filters.kind] Possible values
   * include: 'constant', 'property', 'memberAccess', 'functionCall', 'and',
   * 'or', 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo',
   * 'lessThan', 'lessThanOrEqualTo', 'contains', 'startsWith', 'endsWith',
   * 'isNull', 'isNotNull', 'negate', 'add', 'subtract', 'multiply', 'divide',
   * 'modulo', 'exponent', 'today', 'now'
   *
   * @param {object} [options.body.definition.filteringCriteria]
   *
   * @param {string} [options.body.definition.filteringCriteria.logicalOperator]
   * Possible values include: 'and', 'or'
   *
   * @param {string} [options.body.definition.filteringCriteria.attribute] Gets
   * the Attribute of the entity used in segment criteria.
   *
   * @param {string}
   * [options.body.definition.filteringCriteria.comparisonOperator] Possible
   * values include: 'equals', 'notEquals', 'greaterThan',
   * 'greaterThanOrEqualTo', 'lessThan', 'lessThanOrEqualTo', 'any', 'contains',
   * 'startsWith', 'endsWith', 'isNull', 'isNotNull', 'all', 'isIn',
   * 'isWithinLast', 'isBetween', 'isNotBetween', 'yearToDate', 'dayOf',
   * 'monthOf', 'yearOf', 'dayOfWeek', 'timeAt'
   *
   * @param {array} [options.body.definition.filteringCriteria.childCriterias]
   * Gets the list of Child criteria of segment.
   *
   * @param {string} [options.body.definition.filteringCriteria.value] Gets the
   * Value in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.ignoreCase] Gets
   * a value indicating whether case is ignored for this criteria.
   *
   * @param {array} [options.body.definition.filteringCriteria.listOfValues] Gets
   * the list of values in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.isTime] flag set
   * to true if entries are of time format
   *
   * @param {array} [options.body.definition.dimensions] Gets list of dimensions
   * with the measure.
   *
   * @param {array} [options.body.definition.aggregates] Gets list of aggregates
   * of the measure.
   *
   * @param {boolean} [options.body.definition.isProfile] Gets a value indicating
   * whether the current measure is a profile measure
   *
   * @param {string} [options.body.definition.measureQuerySql] Gets the user
   * specified custom SQL query.
   *
   * @param {string} [options.body.definition.type] Possible values include:
   * 'structured', 'manual'
   *
   * @param {boolean} [options.body.definition.isManualQueryScalar] Gets the
   * indicating whether the Business Measure is Scalar or not.
   *
   * @param {array} [options.body.definition.dependencies] Gets the list of
   * measures that this measure depends on.
   *
   * @param {object} [options.body.latestEvaluation]
   *
   * @param {uuid} [options.body.latestEvaluation.lastSuccessfulRunId]
   *
   * @param {string} [options.body.latestEvaluation.state] Possible values
   * include: 'none', 'running', 'failed', 'completed'
   *
   * @param {date} [options.body.latestEvaluation.endTime] Evaluation completion
   * time.
   *
   * @param {string} [options.body.latestEvaluation.error] Error Information (if
   * any) that occured during the measure evaluation.
   *
   * @param {object} [options.body.output]
   *
   * @param {object} [options.body.output.values] Output folder path for the
   * evaluation.
   *
   * @param {string} [options.body.output.measureName]
   *
   * @param {date} [options.body.output.evaluationTime] Gets the evaluation start
   * time.
   *
   * @param {object} [options.body.evaluationStats]
   *
   * @param {date} [options.body.evaluationStats.lastSuccessful] Last successful
   * evaluation
   *
   * @param {number} [options.body.evaluationStats.consecutiveFailureCount]
   * Represents Number of consecutive failures
   *
   * @param {object} [options.body.errorDescription]
   *
   * @param {string} [options.body.errorDescription.value]
   *
   * @param {string} [options.body.errorDescription.key] Possible values include:
   * 'activityMappingDuplicateMappingOnEntity', 'activityMappingEmptyInput',
   * 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.errorDescription.args]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationHistory] Evaluation history for the
   * measure. (not persisted in store)
   *
   * @param {array} [options.body.outputHistory] Output history for the measure.
   * (not persisted in store)
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateAMeasureWithHttpOperationResponse(instanceId, measureName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateAMeasure(instanceId, measureName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary UpdateMeasure
   *
   * Updates measures metadata for the provided instanceId and measureMetadata.
   * Existing measure is retrieved using measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] Update measure metadata
   *
   * @param {string} [options.body.displayName]
   *
   * @param {string} [options.body.name] Unique name of the measure
   *
   * @param {string} [options.body.description] Description of the measure.
   *
   * @param {object} [options.body.definition]
   *
   * @param {string} [options.body.definition.kind] Possible values include:
   * 'entity', 'attribute'
   *
   * @param {boolean} [options.body.definition.isScalar] Gets a value indicating
   * whether the current measure is a scalar measure e doesn't have any
   * dimensions
   *
   * @param {array} [options.body.definition.linkedEntities] Gets list of linked
   * entities associated with the measure.
   *
   * @param {array} [options.body.definition.variables] Gets list of variables
   * (computed columns) for the measure.
   *
   * @param {object} [options.body.definition.filters]
   *
   * @param {string} [options.body.definition.filters.kind] Possible values
   * include: 'constant', 'property', 'memberAccess', 'functionCall', 'and',
   * 'or', 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo',
   * 'lessThan', 'lessThanOrEqualTo', 'contains', 'startsWith', 'endsWith',
   * 'isNull', 'isNotNull', 'negate', 'add', 'subtract', 'multiply', 'divide',
   * 'modulo', 'exponent', 'today', 'now'
   *
   * @param {object} [options.body.definition.filteringCriteria]
   *
   * @param {string} [options.body.definition.filteringCriteria.logicalOperator]
   * Possible values include: 'and', 'or'
   *
   * @param {string} [options.body.definition.filteringCriteria.attribute] Gets
   * the Attribute of the entity used in segment criteria.
   *
   * @param {string}
   * [options.body.definition.filteringCriteria.comparisonOperator] Possible
   * values include: 'equals', 'notEquals', 'greaterThan',
   * 'greaterThanOrEqualTo', 'lessThan', 'lessThanOrEqualTo', 'any', 'contains',
   * 'startsWith', 'endsWith', 'isNull', 'isNotNull', 'all', 'isIn',
   * 'isWithinLast', 'isBetween', 'isNotBetween', 'yearToDate', 'dayOf',
   * 'monthOf', 'yearOf', 'dayOfWeek', 'timeAt'
   *
   * @param {array} [options.body.definition.filteringCriteria.childCriterias]
   * Gets the list of Child criteria of segment.
   *
   * @param {string} [options.body.definition.filteringCriteria.value] Gets the
   * Value in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.ignoreCase] Gets
   * a value indicating whether case is ignored for this criteria.
   *
   * @param {array} [options.body.definition.filteringCriteria.listOfValues] Gets
   * the list of values in criteria.
   *
   * @param {boolean} [options.body.definition.filteringCriteria.isTime] flag set
   * to true if entries are of time format
   *
   * @param {array} [options.body.definition.dimensions] Gets list of dimensions
   * with the measure.
   *
   * @param {array} [options.body.definition.aggregates] Gets list of aggregates
   * of the measure.
   *
   * @param {boolean} [options.body.definition.isProfile] Gets a value indicating
   * whether the current measure is a profile measure
   *
   * @param {string} [options.body.definition.measureQuerySql] Gets the user
   * specified custom SQL query.
   *
   * @param {string} [options.body.definition.type] Possible values include:
   * 'structured', 'manual'
   *
   * @param {boolean} [options.body.definition.isManualQueryScalar] Gets the
   * indicating whether the Business Measure is Scalar or not.
   *
   * @param {array} [options.body.definition.dependencies] Gets the list of
   * measures that this measure depends on.
   *
   * @param {object} [options.body.latestEvaluation]
   *
   * @param {uuid} [options.body.latestEvaluation.lastSuccessfulRunId]
   *
   * @param {string} [options.body.latestEvaluation.state] Possible values
   * include: 'none', 'running', 'failed', 'completed'
   *
   * @param {date} [options.body.latestEvaluation.endTime] Evaluation completion
   * time.
   *
   * @param {string} [options.body.latestEvaluation.error] Error Information (if
   * any) that occured during the measure evaluation.
   *
   * @param {object} [options.body.output]
   *
   * @param {object} [options.body.output.values] Output folder path for the
   * evaluation.
   *
   * @param {string} [options.body.output.measureName]
   *
   * @param {date} [options.body.output.evaluationTime] Gets the evaluation start
   * time.
   *
   * @param {object} [options.body.evaluationStats]
   *
   * @param {date} [options.body.evaluationStats.lastSuccessful] Last successful
   * evaluation
   *
   * @param {number} [options.body.evaluationStats.consecutiveFailureCount]
   * Represents Number of consecutive failures
   *
   * @param {object} [options.body.errorDescription]
   *
   * @param {string} [options.body.errorDescription.value]
   *
   * @param {string} [options.body.errorDescription.key] Possible values include:
   * 'activityMappingDuplicateMappingOnEntity', 'activityMappingEmptyInput',
   * 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.errorDescription.args]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationHistory] Evaluation history for the
   * measure. (not persisted in store)
   *
   * @param {array} [options.body.outputHistory] Output history for the measure.
   * (not persisted in store)
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateAMeasure(instanceId, measureName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateAMeasure(instanceId, measureName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateAMeasure(instanceId, measureName, options, optionalCallback);
    }
  }

  /**
   * @summary DeleteMeasure
   *
   * Deletes the measure metadata for the provided instanceId using measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteAMeasureWithHttpOperationResponse(instanceId, measureName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteAMeasure(instanceId, measureName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary DeleteMeasure
   *
   * Deletes the measure metadata for the provided instanceId using measureName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} measureName Name of the measure
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteAMeasure(instanceId, measureName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteAMeasure(instanceId, measureName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteAMeasure(instanceId, measureName, options, optionalCallback);
    }
  }

  /**
   * @summary GetKeyRing
   *
   * Gets the KeyRing (collection of all alternate keys) for the given instance
   * by alternate key.
   *
   * @param {string} instanceId Format - uuid. Identifier for the instance
   *
   * @param {string} dataSourceName The name of the datasource that contains the
   * given entity.
   *
   * @param {string} entityName The name of the entity that contains the given
   * key.
   *
   * @param {string} key The value of the alternate key provided.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getKeyRingWithHttpOperationResponse(instanceId, dataSourceName, entityName, key, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getKeyRing(instanceId, dataSourceName, entityName, key, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetKeyRing
   *
   * Gets the KeyRing (collection of all alternate keys) for the given instance
   * by alternate key.
   *
   * @param {string} instanceId Format - uuid. Identifier for the instance
   *
   * @param {string} dataSourceName The name of the datasource that contains the
   * given entity.
   *
   * @param {string} entityName The name of the entity that contains the given
   * key.
   *
   * @param {string} key The value of the alternate key provided.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getKeyRing(instanceId, dataSourceName, entityName, key, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getKeyRing(instanceId, dataSourceName, entityName, key, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getKeyRing(instanceId, dataSourceName, entityName, key, options, optionalCallback);
    }
  }

  /**
   * @summary GetProfileStoreState
   *
   * Gets the profile store state infoformation.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getProfileStoreStateWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getProfileStoreState(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetProfileStoreState
   *
   * Gets the profile store state infoformation.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getProfileStoreState(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getProfileStoreState(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getProfileStoreState(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary ListAllRoles
   *
   * Get all role definitions.
   *
   * @param {string} instanceId
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllRoleDefinitionsWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllRoleDefinitions(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary ListAllRoles
   *
   * Get all role definitions.
   *
   * @param {string} instanceId
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllRoleDefinitions(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllRoleDefinitions(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllRoleDefinitions(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary GetCurrentUserRole
   *
   * Get role of current user.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<RoleAssignment>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getCurrentUserRoleWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getCurrentUserRole(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetCurrentUserRole
   *
   * Get role of current user.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {RoleAssignment} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link RoleAssignment} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getCurrentUserRole(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getCurrentUserRole(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getCurrentUserRole(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary UpdateRoleAssignment
   *
   * Adds or updates a role assignment for a principal.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} principalId The principal id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The role assignment.
   *
   * @param {string} [options.body.principalId] Gets the Id of the principal.
   *
   * @param {string} [options.body.principalType] Possible values include:
   * 'user', 'group', 'app'
   *
   * @param {array} [options.body.roles] Gets the roles the principal belongs to.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateARoleAssignmentWithHttpOperationResponse(instanceId, principalId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateARoleAssignment(instanceId, principalId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary UpdateRoleAssignment
   *
   * Adds or updates a role assignment for a principal.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} principalId The principal id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The role assignment.
   *
   * @param {string} [options.body.principalId] Gets the Id of the principal.
   *
   * @param {string} [options.body.principalType] Possible values include:
   * 'user', 'group', 'app'
   *
   * @param {array} [options.body.roles] Gets the roles the principal belongs to.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateARoleAssignment(instanceId, principalId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateARoleAssignment(instanceId, principalId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateARoleAssignment(instanceId, principalId, options, optionalCallback);
    }
  }

  /**
   * @summary DeleteRoleAssignment
   *
   * Deletes a role assignment for the principal.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} principalId The principal id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deletesARoleAssignmentWithHttpOperationResponse(instanceId, principalId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deletesARoleAssignment(instanceId, principalId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary DeleteRoleAssignment
   *
   * Deletes a role assignment for the principal.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} principalId The principal id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deletesARoleAssignment(instanceId, principalId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deletesARoleAssignment(instanceId, principalId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deletesARoleAssignment(instanceId, principalId, options, optionalCallback);
    }
  }

  /**
   * @summary ListAllRoleAssignments
   *
   * Gets all role assignments for the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Array>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllRoleAssignmentsWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllRoleAssignments(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary ListAllRoleAssignments
   *
   * Gets all role assignments for the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Array} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {array} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllRoleAssignments(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllRoleAssignments(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllRoleAssignments(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary ListAllRelationships
   *
   * Gets all relationship metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllRelationshipsWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllRelationships(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary ListAllRelationships
   *
   * Gets all relationship metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllRelationships(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllRelationships(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllRelationships(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary CreateRelationship
   *
   * Creates new relationship metadata for the provided instanceId, using input.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The updated relationship metadata
   *
   * @param {string} [options.body.friendlyName] Gets the friendly name of the
   * relationship.
   *
   * @param {string} [options.body.name] Gets the unique name for relationship
   *
   * @param {string} [options.body.description] Gets the description for
   * relationship
   *
   * @param {string} [options.body.relationshipType] Possible values include:
   * 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
   * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
   *
   * @param {string} [options.body.fromAttributeName] Gets the name of the
   * foreign key reference attribute that this relationship originates from.
   *
   * @param {string} [options.body.fromEntityName] Gets the name of the entity
   * this relationship originates from.
   *
   * @param {string} [options.body.toAttributeName] Gets the name of the foreign
   * key attribute that this relationship points to.
   *
   * @param {string} [options.body.toEntityName] Gets the name of the entity this
   * relationship points to.
   *
   * @param {string} [options.body.cardinality] Possible values include:
   * 'oneToMany', 'oneToOne'
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createARelationshipWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createARelationship(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary CreateRelationship
   *
   * Creates new relationship metadata for the provided instanceId, using input.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The updated relationship metadata
   *
   * @param {string} [options.body.friendlyName] Gets the friendly name of the
   * relationship.
   *
   * @param {string} [options.body.name] Gets the unique name for relationship
   *
   * @param {string} [options.body.description] Gets the description for
   * relationship
   *
   * @param {string} [options.body.relationshipType] Possible values include:
   * 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
   * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
   *
   * @param {string} [options.body.fromAttributeName] Gets the name of the
   * foreign key reference attribute that this relationship originates from.
   *
   * @param {string} [options.body.fromEntityName] Gets the name of the entity
   * this relationship originates from.
   *
   * @param {string} [options.body.toAttributeName] Gets the name of the foreign
   * key attribute that this relationship points to.
   *
   * @param {string} [options.body.toEntityName] Gets the name of the entity this
   * relationship points to.
   *
   * @param {string} [options.body.cardinality] Possible values include:
   * 'oneToMany', 'oneToOne'
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createARelationship(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createARelationship(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createARelationship(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary GetRelationship
   *
   * Gets the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getARelationshipWithHttpOperationResponse(instanceId, relationshipName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getARelationship(instanceId, relationshipName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetRelationship
   *
   * Gets the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getARelationship(instanceId, relationshipName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getARelationship(instanceId, relationshipName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getARelationship(instanceId, relationshipName, options, optionalCallback);
    }
  }

  /**
   * @summary DeleteRelationship
   *
   * Deletes the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteARelationshipWithHttpOperationResponse(instanceId, relationshipName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteARelationship(instanceId, relationshipName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary DeleteRelationship
   *
   * Deletes the relationship metadata for the provided instanceId and
   * relationshipName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteARelationship(instanceId, relationshipName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteARelationship(instanceId, relationshipName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteARelationship(instanceId, relationshipName, options, optionalCallback);
    }
  }

  /**
   * @summary UpdateRelationshhip
   *
   * Updates the relationship metadata for the provided instanceId and
   * relationshipName, using input.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The updated relationship metadata
   *
   * @param {string} [options.body.friendlyName] Gets the friendly name of the
   * relationship.
   *
   * @param {string} [options.body.name] Gets the unique name for relationship
   *
   * @param {string} [options.body.description] Gets the description for
   * relationship
   *
   * @param {string} [options.body.relationshipType] Possible values include:
   * 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
   * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
   *
   * @param {string} [options.body.fromAttributeName] Gets the name of the
   * foreign key reference attribute that this relationship originates from.
   *
   * @param {string} [options.body.fromEntityName] Gets the name of the entity
   * this relationship originates from.
   *
   * @param {string} [options.body.toAttributeName] Gets the name of the foreign
   * key attribute that this relationship points to.
   *
   * @param {string} [options.body.toEntityName] Gets the name of the entity this
   * relationship points to.
   *
   * @param {string} [options.body.cardinality] Possible values include:
   * 'oneToMany', 'oneToOne'
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateARelationshipWithHttpOperationResponse(instanceId, relationshipName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateARelationship(instanceId, relationshipName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary UpdateRelationshhip
   *
   * Updates the relationship metadata for the provided instanceId and
   * relationshipName, using input.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} relationshipName Relationship name
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The updated relationship metadata
   *
   * @param {string} [options.body.friendlyName] Gets the friendly name of the
   * relationship.
   *
   * @param {string} [options.body.name] Gets the unique name for relationship
   *
   * @param {string} [options.body.description] Gets the description for
   * relationship
   *
   * @param {string} [options.body.relationshipType] Possible values include:
   * 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
   * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
   *
   * @param {string} [options.body.fromAttributeName] Gets the name of the
   * foreign key reference attribute that this relationship originates from.
   *
   * @param {string} [options.body.fromEntityName] Gets the name of the entity
   * this relationship originates from.
   *
   * @param {string} [options.body.toAttributeName] Gets the name of the foreign
   * key attribute that this relationship points to.
   *
   * @param {string} [options.body.toEntityName] Gets the name of the entity this
   * relationship points to.
   *
   * @param {string} [options.body.cardinality] Possible values include:
   * 'oneToMany', 'oneToOne'
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateARelationship(instanceId, relationshipName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateARelationship(instanceId, relationshipName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateARelationship(instanceId, relationshipName, options, optionalCallback);
    }
  }

  /**
   * @summary GetSearchConfiguration
   *
   * Gets the search configuration for the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSearchConfigurationWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSearchConfiguration(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetSearchConfiguration
   *
   * Gets the search configuration for the instance.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSearchConfiguration(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSearchConfiguration(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSearchConfiguration(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary UpdateSearchConfiguration
   *
   * UpdateSearchConfiguration
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The search configuration for the instance.
   *
   * @param {array} [options.body.entityConfig] Gets search configurations for
   * entities
   *
   * @param {boolean} [options.body.isSystemGenerated] Gets a value indicating
   * whether the configuration was system generated
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateSearchConfigurationWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateSearchConfiguration(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary UpdateSearchConfiguration
   *
   * UpdateSearchConfiguration
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] The search configuration for the instance.
   *
   * @param {array} [options.body.entityConfig] Gets search configurations for
   * entities
   *
   * @param {boolean} [options.body.isSystemGenerated] Gets a value indicating
   * whether the configuration was system generated
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateSearchConfiguration(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateSearchConfiguration(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateSearchConfiguration(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary ListAllSegments
   *
   * Retrieves a list of segment metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeHistoricStats] Optional parameter to
   * retrieve evaluation history of all the sgements in instanceId.
   *
   * @param {number} [options.historicStatsDays] Format - int32. Optional
   * parameter to get number of days evaluation history.
   *
   * @param {number} [options.numberOfSegments] Format - int32. Optional
   * parameter to limit the number of segments returned.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAllSegmentsWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAllSegments(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary ListAllSegments
   *
   * Retrieves a list of segment metadata for the provided instanceId.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeHistoricStats] Optional parameter to
   * retrieve evaluation history of all the sgements in instanceId.
   *
   * @param {number} [options.historicStatsDays] Format - int32. Optional
   * parameter to get number of days evaluation history.
   *
   * @param {number} [options.numberOfSegments] Format - int32. Optional
   * parameter to limit the number of segments returned.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAllSegments(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAllSegments(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAllSegments(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary CreateSegment
   *
   * CreateSegment
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Segment metadata to be created
   *
   * @param {string} [options.body.name] Gets the unique name of the segment
   *
   * @param {string} [options.body.friendlyName] Gets the friendlyName of the
   * segment.
   *
   * @param {string} [options.body.description] Gets the description of the
   * segment.
   *
   * @param {object} [options.body.segmentQueryExpression]
   *
   * @param {string} [options.body.segmentQueryExpression.type] Possible values
   * include: 'structured', 'manual'
   *
   * @param {array} [options.body.segmentQueryExpression.projections] Gets list
   * of attributes to be projected in segment.
   *
   * @param {array} [options.body.segmentQueryExpression.rowsets] Gets list of
   * rowsets of segment.
   *
   * @param {string} [options.body.segmentQueryExpression.segmentationQuerySql]
   * Gets the user specified custom SQL query.
   *
   * @param {string} [options.body.state] Possible values include: 'inactive',
   * 'active', 'validating', 'validated', 'invalid', 'validationError'
   *
   * @param {string} [options.body.errorDescription] Gets the error description
   * when the segment metadata has some issues after refresh.
   *
   * @param {date} [options.body.endDate] Gets the end date of the segment.
   *
   * @param {object} [options.body.evaluationStatus]
   *
   * @param {string} [options.body.evaluationStatus.jobStatus] Possible values
   * include: 'None', 'Queued', 'Running', 'CompletedSuccess',
   * 'CompletedFailure', 'Cancelled', 'Interrupted', 'NotQualified'
   *
   * @param {date} [options.body.evaluationStatus.evaluationDate]
   *
   * @param {number} [options.body.evaluationStatus.entityCount]
   *
   * @param {object} [options.body.evaluationStatus.error]
   *
   * @param {string} [options.body.evaluationStatus.error.value]
   *
   * @param {string} [options.body.evaluationStatus.error.key] Possible values
   * include: 'activityMappingDuplicateMappingOnEntity',
   * 'activityMappingEmptyInput', 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.evaluationStatus.error.args]
   *
   * @param {uuid} [options.body.evaluationStatus.lastSuccessfulRunId]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationStatusHistory] Gets the segment
   * evaluation status history. (not persisted in store)
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createASegmentWithHttpOperationResponse(instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createASegment(instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary CreateSegment
   *
   * CreateSegment
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Segment metadata to be created
   *
   * @param {string} [options.body.name] Gets the unique name of the segment
   *
   * @param {string} [options.body.friendlyName] Gets the friendlyName of the
   * segment.
   *
   * @param {string} [options.body.description] Gets the description of the
   * segment.
   *
   * @param {object} [options.body.segmentQueryExpression]
   *
   * @param {string} [options.body.segmentQueryExpression.type] Possible values
   * include: 'structured', 'manual'
   *
   * @param {array} [options.body.segmentQueryExpression.projections] Gets list
   * of attributes to be projected in segment.
   *
   * @param {array} [options.body.segmentQueryExpression.rowsets] Gets list of
   * rowsets of segment.
   *
   * @param {string} [options.body.segmentQueryExpression.segmentationQuerySql]
   * Gets the user specified custom SQL query.
   *
   * @param {string} [options.body.state] Possible values include: 'inactive',
   * 'active', 'validating', 'validated', 'invalid', 'validationError'
   *
   * @param {string} [options.body.errorDescription] Gets the error description
   * when the segment metadata has some issues after refresh.
   *
   * @param {date} [options.body.endDate] Gets the end date of the segment.
   *
   * @param {object} [options.body.evaluationStatus]
   *
   * @param {string} [options.body.evaluationStatus.jobStatus] Possible values
   * include: 'None', 'Queued', 'Running', 'CompletedSuccess',
   * 'CompletedFailure', 'Cancelled', 'Interrupted', 'NotQualified'
   *
   * @param {date} [options.body.evaluationStatus.evaluationDate]
   *
   * @param {number} [options.body.evaluationStatus.entityCount]
   *
   * @param {object} [options.body.evaluationStatus.error]
   *
   * @param {string} [options.body.evaluationStatus.error.value]
   *
   * @param {string} [options.body.evaluationStatus.error.key] Possible values
   * include: 'activityMappingDuplicateMappingOnEntity',
   * 'activityMappingEmptyInput', 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.evaluationStatus.error.args]
   *
   * @param {uuid} [options.body.evaluationStatus.lastSuccessfulRunId]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationStatusHistory] Gets the segment
   * evaluation status history. (not persisted in store)
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createASegment(instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createASegment(instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createASegment(instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary ActivateSegment
   *
   * Activate segment on instanceId with segmentName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  activateSegmentWithHttpOperationResponse(instanceId, segmentName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._activateSegment(instanceId, segmentName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary ActivateSegment
   *
   * Activate segment on instanceId with segmentName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  activateSegment(instanceId, segmentName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._activateSegment(instanceId, segmentName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._activateSegment(instanceId, segmentName, options, optionalCallback);
    }
  }

  /**
   * @summary DeactivateSegment
   *
   * Deactivate segment on instanceId with segmentName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deactivateSegmentWithHttpOperationResponse(instanceId, segmentName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deactivateSegment(instanceId, segmentName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary DeactivateSegment
   *
   * Deactivate segment on instanceId with segmentName.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deactivateSegment(instanceId, segmentName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deactivateSegment(instanceId, segmentName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deactivateSegment(instanceId, segmentName, options, optionalCallback);
    }
  }

  /**
   * @summary UpdateSegments
   *
   * Updates segment metadata for the provided instanceId and segmentName with
   * segmentMetadata.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Segment metadata to be updated
   *
   * @param {string} [options.body.name] Gets the unique name of the segment
   *
   * @param {string} [options.body.friendlyName] Gets the friendlyName of the
   * segment.
   *
   * @param {string} [options.body.description] Gets the description of the
   * segment.
   *
   * @param {object} [options.body.segmentQueryExpression]
   *
   * @param {string} [options.body.segmentQueryExpression.type] Possible values
   * include: 'structured', 'manual'
   *
   * @param {array} [options.body.segmentQueryExpression.projections] Gets list
   * of attributes to be projected in segment.
   *
   * @param {array} [options.body.segmentQueryExpression.rowsets] Gets list of
   * rowsets of segment.
   *
   * @param {string} [options.body.segmentQueryExpression.segmentationQuerySql]
   * Gets the user specified custom SQL query.
   *
   * @param {string} [options.body.state] Possible values include: 'inactive',
   * 'active', 'validating', 'validated', 'invalid', 'validationError'
   *
   * @param {string} [options.body.errorDescription] Gets the error description
   * when the segment metadata has some issues after refresh.
   *
   * @param {date} [options.body.endDate] Gets the end date of the segment.
   *
   * @param {object} [options.body.evaluationStatus]
   *
   * @param {string} [options.body.evaluationStatus.jobStatus] Possible values
   * include: 'None', 'Queued', 'Running', 'CompletedSuccess',
   * 'CompletedFailure', 'Cancelled', 'Interrupted', 'NotQualified'
   *
   * @param {date} [options.body.evaluationStatus.evaluationDate]
   *
   * @param {number} [options.body.evaluationStatus.entityCount]
   *
   * @param {object} [options.body.evaluationStatus.error]
   *
   * @param {string} [options.body.evaluationStatus.error.value]
   *
   * @param {string} [options.body.evaluationStatus.error.key] Possible values
   * include: 'activityMappingDuplicateMappingOnEntity',
   * 'activityMappingEmptyInput', 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.evaluationStatus.error.args]
   *
   * @param {uuid} [options.body.evaluationStatus.lastSuccessfulRunId]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationStatusHistory] Gets the segment
   * evaluation status history. (not persisted in store)
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  updateASegmentWithHttpOperationResponse(instanceId, segmentName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._updateASegment(instanceId, segmentName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary UpdateSegments
   *
   * Updates segment metadata for the provided instanceId and segmentName with
   * segmentMetadata.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] New Segment metadata to be updated
   *
   * @param {string} [options.body.name] Gets the unique name of the segment
   *
   * @param {string} [options.body.friendlyName] Gets the friendlyName of the
   * segment.
   *
   * @param {string} [options.body.description] Gets the description of the
   * segment.
   *
   * @param {object} [options.body.segmentQueryExpression]
   *
   * @param {string} [options.body.segmentQueryExpression.type] Possible values
   * include: 'structured', 'manual'
   *
   * @param {array} [options.body.segmentQueryExpression.projections] Gets list
   * of attributes to be projected in segment.
   *
   * @param {array} [options.body.segmentQueryExpression.rowsets] Gets list of
   * rowsets of segment.
   *
   * @param {string} [options.body.segmentQueryExpression.segmentationQuerySql]
   * Gets the user specified custom SQL query.
   *
   * @param {string} [options.body.state] Possible values include: 'inactive',
   * 'active', 'validating', 'validated', 'invalid', 'validationError'
   *
   * @param {string} [options.body.errorDescription] Gets the error description
   * when the segment metadata has some issues after refresh.
   *
   * @param {date} [options.body.endDate] Gets the end date of the segment.
   *
   * @param {object} [options.body.evaluationStatus]
   *
   * @param {string} [options.body.evaluationStatus.jobStatus] Possible values
   * include: 'None', 'Queued', 'Running', 'CompletedSuccess',
   * 'CompletedFailure', 'Cancelled', 'Interrupted', 'NotQualified'
   *
   * @param {date} [options.body.evaluationStatus.evaluationDate]
   *
   * @param {number} [options.body.evaluationStatus.entityCount]
   *
   * @param {object} [options.body.evaluationStatus.error]
   *
   * @param {string} [options.body.evaluationStatus.error.value]
   *
   * @param {string} [options.body.evaluationStatus.error.key] Possible values
   * include: 'activityMappingDuplicateMappingOnEntity',
   * 'activityMappingEmptyInput', 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute',
   * 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError',
   * 'apiVersionNotSupported', 'authEmptyAuthorizationCode',
   * 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp',
   * 'authInvalidAppType', 'authInvalidToken', 'authUserHasC360LicenseError',
   * 'configurationControllerMissingInput', 'customer360ApiInvalidIdentity',
   * 'customer360ApiInvalidTenantIdClaims', 'customer360ApiInvalidUserIdClaims',
   * 'dataRefreshInvalidScheduleRequest', 'dataSourceCreateAlreadyExistError',
   * 'dataSourceModelAlreadyExistError', 'dataSourceDataSourceCanNotDelete',
   * 'dataSourceDataSourceDeleted', 'dataSourceDataSourceNotFound',
   * 'dataSourceDuplicateDataSourceName', 'dataSourceEmptyDataSource',
   * 'dataSourceEmptyDataSourceName', 'dataSourceEmptyDataSourceNameError',
   * 'dataSourceEmptyAttributeError', 'dataLakeAccountInvalidError',
   * 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError',
   * 'resourceMetadataNotFoundError', 'dataSourceInactiveInstance',
   * 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName',
   * 'dataSourceInvalidDataSourceNameCharacter', 'dataSourceInvalidEntityNames',
   * 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout',
   * 'dataSourceUpdateAlreadyExistError', 'dataSourceUpdateDependenciesError',
   * 'datasourceIngestionUnexpectedError', 'dynamics365EmptyHeader',
   * 'entityDataControllerContentType', 'entityMetadataCanNotMarkAttribute',
   * 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity',
   * 'entityMetadataNotFoundForEntity', 'failedToSubmiProfileStoreJob',
   * 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing',
   * 'instancePreferredRegionalFormatMissing', 'invalidDataSourceType',
   * 'invocationBadRequestInReadingHeaderInfo', 'invocationFailedBindToMethod',
   * 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify',
   * 'nullOrEmptyInstanceId', 'offlineGraphIngestionOrchestrationNotify',
   * 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo',
   * 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful',
   * 'publicMetadataControllerAnonymousType', 'rbacAADDirectoryObjectNotFound',
   * 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole',
   * 'rbacRoleIsNotValid', 'rbacUnsupportedPrincipalType', 'rbacUserNotFound',
   * 'refreshBackgroundTaskRunningError', 'refreshConflationCancelled',
   * 'refreshConflationMetadataNotFound', 'refreshConflationJobFailed',
   * 'refreshEnrichmentMetadataNotFound', 'refreshEnrichmentMisconfigured',
   * 'refreshEnrichmentRequestExceeded', 'refreshEnrichmentRequestThrottling',
   * 'refreshExportCancelled', 'refreshExportCompleted', 'refreshExportFailed',
   * 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling',
   * 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError',
   * 'staleMatchRunError', 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2',
   * 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist',
   * 'invalidSegmentDefinitionErrorMessage', 'clauseForNextRefresh',
   * 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped',
   * 'refreshIntelligenceDisabled', 'refreshConflationConfigurationNotFound',
   * 'conflationPlanInvalid', 'conflationMetadataNotFoundForEntity',
   * 'conflationMetadataNotFoundForColumn', 'conflationConfigurationInvalid',
   * 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed',
   * 'bapNotMapped', 'bapCannotCreateEnvironment',
   * 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment',
   * 'bapInvalidTenantEnvironmentLimit', 'bapInvalidUserEnvironmentLimit',
   * 'dataSourceIngestionCancelled', 'dataSourceIngestionSkippedNoEntities',
   * 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable',
   * 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound',
   * 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields',
   * 'activityIngestionNoJarvisColumnMapping', 'activityIngestionNoPrimaryKey',
   * 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName',
   * 'activityIngestionNoStartOrEndTime', 'activityIngestionRangeIndexNotFound',
   * 'activityIngestionUniqueSourceStream', 'entityNoPrimaryKey',
   * 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType',
   * 'inavlidSegmentValidationDisabled', 'invalidSegmentNameConflict',
   * 'invalidSegmentNoExistingSegWithName', 'invalidSegmentSegNotFound',
   * 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl',
   * 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable',
   * 'unsupportedInsightType', 'invalidInsightInputGeneric',
   * 'invalidMalformedInsightInputPayload', 'invalidInsightInputMissingName'
   *
   * @param {array} [options.body.evaluationStatus.error.args]
   *
   * @param {uuid} [options.body.evaluationStatus.lastSuccessfulRunId]
   *
   * @param {object} [options.body.sqlValidationStats]
   *
   * @param {date} [options.body.sqlValidationStats.validationDate] Date of
   * Validation evaluation
   *
   * @param {string} [options.body.sqlValidationStats.error] Gets the number of
   * consecutive failures
   *
   * @param {array} [options.body.evaluationStatusHistory] Gets the segment
   * evaluation status history. (not persisted in store)
   *
   * @param {number} [options.body.version] Version number of this object.
   *
   * @param {string} [options.body.updatedBy] UPN of the user who last updated
   * this record.
   *
   * @param {date} [options.body.updatedUtc] Time this object was last updated.
   *
   * @param {string} [options.body.createdBy] Email address of the user who
   * created this record.
   *
   * @param {date} [options.body.createdUtc] Time this object was initially
   * created.
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  updateASegment(instanceId, segmentName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._updateASegment(instanceId, segmentName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._updateASegment(instanceId, segmentName, options, optionalCallback);
    }
  }

  /**
   * @summary DeleteSegment
   *
   * DeleteSegment
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteSegmentWithHttpOperationResponse(instanceId, segmentName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteSegment(instanceId, segmentName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary DeleteSegment
   *
   * DeleteSegment
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id
   *
   * @param {string} segmentName Unique name of a segment
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteSegment(instanceId, segmentName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteSegment(instanceId, segmentName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteSegment(instanceId, segmentName, options, optionalCallback);
    }
  }

  /**
   * @summary GetWorkflowJobInformation
   *
   * GetWorkflowJobInformation
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {string} jobId Format - uuid. The job id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeTasks] Flag to include tasks or not.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAWorkflowJobInformationWithHttpOperationResponse(instanceId, workflowName, jobId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAWorkflowJobInformation(instanceId, workflowName, jobId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetWorkflowJobInformation
   *
   * GetWorkflowJobInformation
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {string} jobId Format - uuid. The job id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {boolean} [options.includeTasks] Flag to include tasks or not.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAWorkflowJobInformation(instanceId, workflowName, jobId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAWorkflowJobInformation(instanceId, workflowName, jobId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAWorkflowJobInformation(instanceId, workflowName, jobId, options, optionalCallback);
    }
  }

  /**
   * @summary CancelWorkflowJob
   *
   * Cancel a job.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {string} jobId Format - uuid. The job id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  cancelAWorkflowJobWithHttpOperationResponse(instanceId, workflowName, jobId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._cancelAWorkflowJob(instanceId, workflowName, jobId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary CancelWorkflowJob
   *
   * Cancel a job.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {string} jobId Format - uuid. The job id.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  cancelAWorkflowJob(instanceId, workflowName, jobId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._cancelAWorkflowJob(instanceId, workflowName, jobId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._cancelAWorkflowJob(instanceId, workflowName, jobId, options, optionalCallback);
    }
  }

  /**
   * @summary ListWorkFlowJobs
   *
   * Retrieves a list of recent job information.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.top] Format - int32. The number of job informations
   * to retrieve.
   *
   * @param {boolean} [options.includeTasks] Flag to include tasks or not.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getListOfRecentWorkflowJobsWithHttpOperationResponse(instanceId, workflowName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getListOfRecentWorkflowJobs(instanceId, workflowName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary ListWorkFlowJobs
   *
   * Retrieves a list of recent job information.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.top] Format - int32. The number of job informations
   * to retrieve.
   *
   * @param {boolean} [options.includeTasks] Flag to include tasks or not.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getListOfRecentWorkflowJobs(instanceId, workflowName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getListOfRecentWorkflowJobs(instanceId, workflowName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getListOfRecentWorkflowJobs(instanceId, workflowName, options, optionalCallback);
    }
  }

  /**
   * @summary SubmitWorkflowJob
   *
   * Submits a workflow of OperationTypeoperationType for the instance specified
   * in instanceId.
   * Optionally takes a list of identifiers, only if operationType is not
   * OperationType.All and a flag
   * forceRunRequested indicating whether to force run.
   *
   * @param {string} instanceId Format - uuid. The Customer Insights instance id.
   *
   * @param {string} workflowName The workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] Job Creation Request.
   *
   * @param {string} [options.body.graphName]
   *
   * @param {string} [options.body.operationType] Possible values include:
   * 'none', 'ingestion', 'derivedEntity', 'dataPreparation', 'map', 'match',
   * 'merge', 'profileStore', 'search', 'activity', 'attributeMeasures',
   * 'entityMeasures', 'measures', 'segmentation', 'enrichment', 'intelligence',
   * 'aiBuilder', 'insights', 'export', 'modelManagement', 'relationship',
   * 'roleAssignment', 'analysis', 'all'
   *
   * @param {string} [options.body.submissionKind] Possible values include:
   * 'onDemand', 'scheduled'
   *
   * @param {string} [options.body.jobType] Possible values include: 'full',
   * 'incremental'
   *
   * @param {array} [options.body.identifiers]
   *
   * @param {boolean} [options.body.forceRunRequested]
   *
   * @param {string} [options.body.inputRefreshMode] Possible values include:
   * 'FailedOrModifiedRecursive', 'FailedRecursive', 'FailedOrModified',
   * 'Failed', 'None'
   *
   * @param {object} [options.body.options]
   *
   * @param {boolean} [options.body.options.runDownstreamAfterMerge]
   *
   * @param {string} [options.operationType] The workflow operation type.
   *
   * @param {array} [options.identifiers] A list of workflow identifiers.
   *
   * @param {boolean} [options.forceRunRequested] Whether to request a force run.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  submitAWorkflowJobWithHttpOperationResponse(instanceId, workflowName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._submitAWorkflowJob(instanceId, workflowName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary SubmitWorkflowJob
   *
   * Submits a workflow of OperationTypeoperationType for the instance specified
   * in instanceId.
   * Optionally takes a list of identifiers, only if operationType is not
   * OperationType.All and a flag
   * forceRunRequested indicating whether to force run.
   *
   * @param {string} instanceId Format - uuid. The Customer Insights instance id.
   *
   * @param {string} workflowName The workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] Job Creation Request.
   *
   * @param {string} [options.body.graphName]
   *
   * @param {string} [options.body.operationType] Possible values include:
   * 'none', 'ingestion', 'derivedEntity', 'dataPreparation', 'map', 'match',
   * 'merge', 'profileStore', 'search', 'activity', 'attributeMeasures',
   * 'entityMeasures', 'measures', 'segmentation', 'enrichment', 'intelligence',
   * 'aiBuilder', 'insights', 'export', 'modelManagement', 'relationship',
   * 'roleAssignment', 'analysis', 'all'
   *
   * @param {string} [options.body.submissionKind] Possible values include:
   * 'onDemand', 'scheduled'
   *
   * @param {string} [options.body.jobType] Possible values include: 'full',
   * 'incremental'
   *
   * @param {array} [options.body.identifiers]
   *
   * @param {boolean} [options.body.forceRunRequested]
   *
   * @param {string} [options.body.inputRefreshMode] Possible values include:
   * 'FailedOrModifiedRecursive', 'FailedRecursive', 'FailedOrModified',
   * 'Failed', 'None'
   *
   * @param {object} [options.body.options]
   *
   * @param {boolean} [options.body.options.runDownstreamAfterMerge]
   *
   * @param {string} [options.operationType] The workflow operation type.
   *
   * @param {array} [options.identifiers] A list of workflow identifiers.
   *
   * @param {boolean} [options.forceRunRequested] Whether to request a force run.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  submitAWorkflowJob(instanceId, workflowName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._submitAWorkflowJob(instanceId, workflowName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._submitAWorkflowJob(instanceId, workflowName, options, optionalCallback);
    }
  }

  /**
   * @summary ListWorkflowHistory
   *
   * Retrieves a list of historic task information for a workflow.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.top] Format - int32. The number of task
   * informations to retrieve.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getListOfWorkflowTaskInformationHistoryWithHttpOperationResponse(instanceId, workflowName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getListOfWorkflowTaskInformationHistory(instanceId, workflowName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary ListWorkflowHistory
   *
   * Retrieves a list of historic task information for a workflow.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The name of the workflow.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {number} [options.top] Format - int32. The number of task
   * informations to retrieve.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getListOfWorkflowTaskInformationHistory(instanceId, workflowName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getListOfWorkflowTaskInformationHistory(instanceId, workflowName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getListOfWorkflowTaskInformationHistory(instanceId, workflowName, options, optionalCallback);
    }
  }

  /**
   * @summary GetWorkflowStatus
   *
   * Gets the current status for a workflow.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getWorkflowStatusWithHttpOperationResponse(instanceId, workflowName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getWorkflowStatus(instanceId, workflowName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetWorkflowStatus
   *
   * Gets the current status for a workflow.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName The workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getWorkflowStatus(instanceId, workflowName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getWorkflowStatus(instanceId, workflowName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getWorkflowStatus(instanceId, workflowName, options, optionalCallback);
    }
  }

  /**
   * @summary ListSupportedTimezones
   *
   * Gets a list of supported timezones for creating workflow schedules.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {string} instanceId
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSupportedTimezonesWithHttpOperationResponse(workflowName, instanceId, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSupportedTimezones(workflowName, instanceId, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary ListSupportedTimezones
   *
   * Gets a list of supported timezones for creating workflow schedules.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {string} instanceId
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSupportedTimezones(workflowName, instanceId, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSupportedTimezones(workflowName, instanceId, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSupportedTimezones(workflowName, instanceId, options, optionalCallback);
    }
  }

  /**
   * @summary ListAllWorkflowSchedules
   *
   * ListAllWorkflowSchedules
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getWorkflowSchedulesWithHttpOperationResponse(instanceId, workflowName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getWorkflowSchedules(instanceId, workflowName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary ListAllWorkflowSchedules
   *
   * ListAllWorkflowSchedules
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getWorkflowSchedules(instanceId, workflowName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getWorkflowSchedules(instanceId, workflowName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getWorkflowSchedules(instanceId, workflowName, options, optionalCallback);
    }
  }

  /**
   * @summary CreateWorkflowRefreshSchedule
   *
   * Create a workflow refresh schedule.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] A schedule object to create.
   *
   * @param {string} [options.body.operationType] Possible values include:
   * 'none', 'ingestion', 'derivedEntity', 'dataPreparation', 'map', 'match',
   * 'merge', 'profileStore', 'search', 'activity', 'attributeMeasures',
   * 'entityMeasures', 'measures', 'segmentation', 'enrichment', 'intelligence',
   * 'aiBuilder', 'insights', 'export', 'modelManagement', 'relationship',
   * 'roleAssignment', 'analysis', 'all'
   *
   * @param {string} [options.body.subType] Possible values include: 'noSubType',
   * 'templatedMeasures', 'createAnalysisModel', 'linkAnalysisModel',
   * 'singleActivityMapping', 'powerPlatform'
   *
   * @param {array} [options.body.identifiers] Gets the identifiers of the
   * schedule
   *
   * @param {string} [options.body.jobType] Possible values include: 'full',
   * 'incremental'
   *
   * @param {boolean} [options.body.isActive] Gets a value indicating whether the
   * schedule is active.
   *
   * @param {string} [options.body.timezoneId] Gets the ID of the timezone
   *
   * @param {array} [options.body.cronSchedules] Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.scheduleId] Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createWorkflowRefreshScheduleWithHttpOperationResponse(instanceId, workflowName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createWorkflowRefreshSchedule(instanceId, workflowName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary CreateWorkflowRefreshSchedule
   *
   * Create a workflow refresh schedule.
   *
   * @param {string} instanceId Format - uuid. The instance id.
   *
   * @param {string} workflowName Any workflow name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.body] A schedule object to create.
   *
   * @param {string} [options.body.operationType] Possible values include:
   * 'none', 'ingestion', 'derivedEntity', 'dataPreparation', 'map', 'match',
   * 'merge', 'profileStore', 'search', 'activity', 'attributeMeasures',
   * 'entityMeasures', 'measures', 'segmentation', 'enrichment', 'intelligence',
   * 'aiBuilder', 'insights', 'export', 'modelManagement', 'relationship',
   * 'roleAssignment', 'analysis', 'all'
   *
   * @param {string} [options.body.subType] Possible values include: 'noSubType',
   * 'templatedMeasures', 'createAnalysisModel', 'linkAnalysisModel',
   * 'singleActivityMapping', 'powerPlatform'
   *
   * @param {array} [options.body.identifiers] Gets the identifiers of the
   * schedule
   *
   * @param {string} [options.body.jobType] Possible values include: 'full',
   * 'incremental'
   *
   * @param {boolean} [options.body.isActive] Gets a value indicating whether the
   * schedule is active.
   *
   * @param {string} [options.body.timezoneId] Gets the ID of the timezone
   *
   * @param {array} [options.body.cronSchedules] Gets the schedule in CRON format
   *
   * @param {uuid} [options.body.scheduleId] Gets the ID of the schedule
   *
   * @param {uuid} [options.body.instanceId] Customer Insights instance id
   * associated with this object.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createWorkflowRefreshSchedule(instanceId, workflowName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createWorkflowRefreshSchedule(instanceId, workflowName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createWorkflowRefreshSchedule(instanceId, workflowName, options, optionalCallback);
    }
  }

  /**
   * @summary GetEntityProfile
   *
   * Gets the entityProfile for the entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} qualifiedEntityName Qualified Entity Name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Object>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getAnEntityProfileWithHttpOperationResponse(instanceId, qualifiedEntityName, options) {
    let client = this;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getAnEntityProfile(instanceId, qualifiedEntityName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * @summary GetEntityProfile
   *
   * Gets the entityProfile for the entity.
   *
   * @param {string} instanceId Format - uuid. Customer Insights instance id.
   *
   * @param {string} qualifiedEntityName Qualified Entity Name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Object} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getAnEntityProfile(instanceId, qualifiedEntityName, options, optionalCallback) {
    let client = this;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getAnEntityProfile(instanceId, qualifiedEntityName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getAnEntityProfile(instanceId, qualifiedEntityName, options, optionalCallback);
    }
  }

}

module.exports = CustomerInsights;
module.exports['default'] = CustomerInsights;
module.exports.CustomerInsights = CustomerInsights;
module.exports.CustomerInsightsModels = models;
