/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as moment from "moment";

/**
 * Represents a DAG refresh schedule
 */
export interface WorkflowRefreshSchedule {
  /**
   * Possible values include: 'none', 'ingestion', 'derivedEntity', 'hierarchy', 'dataPreparation',
   * 'map', 'realtimeM3Search', 'match', 'merge', 'profileStore', 'search', 'activity', 'contact',
   * 'attributeMeasures', 'entityMeasures', 'measures', 'segmentation', 'segmentMembership',
   * 'enrichment', 'preEnrichment', 'transform', 'intelligence', 'aiBuilder', 'insights', 'export',
   * 'modelManagement', 'relationship', 'roleAssignment', 'analysis', 'semanticEntity', 'all'
   */
  operationType?: string;
  /**
   * Possible values include: 'noSubType', 'templatedMeasures', 'createAnalysisModel',
   * 'linkAnalysisModel', 'singleActivityMapping', 'powerPlatform'
   */
  subType?: string;
  /**
   * Gets the identifiers of the schedule
   */
  identifiers?: string[];
  /**
   * Possible values include: 'full', 'incremental'
   */
  jobType?: string;
  /**
   * Gets a value indicating whether the schedule is active.
   */
  isActive?: boolean;
  /**
   * Gets the ID of the timezone
   */
  timezoneId?: string;
  /**
   * Gets the schedule in CRON format
   */
  cronSchedules?: string[];
  /**
   * Gets the ID of the schedule
   */
  scheduleId?: string;
  /**
   * Customer Insights instance id associated with this object.
   */
  instanceId?: string;
}

/**
 * Histogram bin.
 */
export interface HistogramBin {
  /**
   * Lower bound of Histogram bin.
   */
  lowerBound?: number;
  /**
   * Upper bound Histogram bin.
   */
  upperBound?: number;
  /**
   * Represents an approximation count of the bin count.
   */
  count?: number;
}

/**
 * Numerical quantiles.
 */
export interface Quantiles {
  /**
   * Represents 1% quantile.
   */
  p0D1?: number;
  /**
   * Represents 1% quantile.
   */
  p1?: number;
  /**
   * Represents 5% quantile.
   */
  p5?: number;
  /**
   * Represents 25% quantile.
   */
  p25?: number;
  /**
   * Represents 50% quantile.
   */
  p50?: number;
  /**
   * Represents 75% quantile.
   */
  p75?: number;
  /**
   * Represents 95% quantile.
   */
  p95?: number;
  /**
   * Represents 99% quantile.
   */
  p99?: number;
  /**
   * Represents 9% quantile.
   */
  p99D9?: number;
}

/**
 * Statistical moments.
 */
export interface Moments {
  /**
   * Represents the mean.
   */
  mean?: number;
  /**
   * Represents standard deviation.
   */
  standardDeviation?: number;
  /**
   * Represents variance.
   */
  variance?: number;
  /**
   * Represents skewness in data.
   */
  skewness?: number;
  /**
   * Represents kurtosis.
   */
  kurtosis?: number;
}

/**
 * A value and the count of that value.
 */
export interface ValueCount {
  /**
   * Represents the value.
   */
  value?: any;
  /**
   * Represents Count of the value.
   */
  count?: number;
}

/**
 * Attribute data profile
 */
export interface AttributeDataProfile {
  /**
   * Represents Distribution of the top 100 values.
   */
  valueCounts?: ValueCount[];
  /**
   * Represents histogram information Ordered from smallest to largest bin.
   */
  histogram?: HistogramBin[];
  /**
   * Qualified entity name.
   */
  qualifiedEntityName?: string;
  /**
   * Attribute name.
   */
  attributeName?: string;
  /**
   * Minimum value.
   */
  min?: any;
  /**
   * Maximum value.
   */
  max?: any;
  /**
   * Total row count.
   */
  count?: number;
  /**
   * Row count of missing values.
   */
  missingCount?: number;
  /**
   * Number of error values.
   */
  errorCount?: number;
  quantiles?: Quantiles;
  moments?: Moments;
  /**
   * Number of unique values.
  */
  uniqueValueCount?: number;
  /**
   * Profiling date
  */
  profilingDate?: Date;
  /**
   * Represents a value indicating whether this attribute can be used as a primary key of the
   * entity
  */
  isSuggestedPrimaryKey?: boolean;
  /**
   * Represents a value indicating whether we calculate exact or approx stats
  */
  checkIfExactStats?: any;
}

/**
 * Represents Entity Data Profile information.
*/
export interface EntityDataProfile {
  /**
   * Qualified Entity Name.
  */
  qualifiedEntityName?: string;
  /**
   * Row count.
  */
  rowCount?: number;
  /**
   * Quarentine row count
  */
  quarantineRowCount?: number;
  /**
   * Date for Profiling.
  */
  profilingDate?: Date;
  /**
   * Profiling attributes.
  */
  profiledAttributes?: string;
  /**
   * Respresents currupt attributes.
  */
  corruptAttributes?: string;
  /**
   * Contains all the attributes data profiles.
  */
  attributeDataProfiles?: AttributeDataProfile[];
}

/**
 * Represents response result type
*/
export interface CIResult {
  /**
   * Possible values include: 'system', 'user', 'external'
  */
  exceptionCulprit?: string;
  errorCode?: string;
  /**
   * Possible values include: 'error', 'warning', 'recommendation'
  */
  resultSeverity?: string;
  /**
   * Message providing more information about the event.
  */
  message?: string;
  /**
   * Message providing more information about the event.
  */
  name?: string;
  params?: { [propertyName: string]: any };
  /**
   * List of CiResult contining CI result error code and information (if any).
  */
  ciResults?: CIResult[];
}

/**
 * Api Error response class (DTO)
*/
export interface ApiErrorResult {
  exception?: any;
  httpStatusCode?: string;
  /**
   * Possible values include: 'system', 'user', 'external'
  */
  exceptionCulprit?: string;
  errorCode?: string;
  /**
   * Possible values include: 'error', 'warning', 'recommendation'
  */
  resultSeverity?: string;
  /**
   * Message providing more information about the event.
  */
  message?: string;
  /**
   * Message providing more information about the event.
  */
  name?: string;
  params?: { [propertyName: string]: any };
  /**
   * List of CiResult contining CI result error code and information (if any).
  */
  ciResults?: CIResult[];
}

/**
 * Represents the semantic info used in API requests (attribute level)
*/
export interface AttributeSemanticInformation {
  /**
   * Name of the attribute.
  */
  attributeName?: string;
  /**
   * Semantic label. Possible values include: 'CalendarDate', 'CalendarDayOfMonth',
   * 'CalendarDayOfWeek', 'CalendarDayOfYear', 'CalendarHalfYear', 'CalendarMonthOfYear',
   * 'CalendarMonth', 'CalendarWeek', 'CalendarYear', 'CalendarFiscalDate',
   * 'CalendarFiscalDayOfMonth', 'CalendarFiscalDayOfWeek', 'CalendarFiscalDayOfYear',
   * 'CalendarFiscalHalfYear', 'CalendarFiscalMonthOfYear', 'CalendarFiscalMonth',
   * 'CalendarFiscalQuarter', 'CalendarFiscalWeekOfMonth', 'CalendarFiscalWeekOfYear',
   * 'CalendarFiscalWeek', 'CalendarFiscalYear', 'Account', 'Channel', 'Contact', 'Customer',
   * 'Language', 'Organization', 'OrganizationUnit', 'Person', 'Product', 'ProductGroup',
   * 'LocationAddress', 'LocationAddressStreet', 'LocationCity', 'LocationContinent',
   * 'LocationCountry', 'LocationCounty', 'LocationLatitude', 'LocationLongitude', 'LocationPoint',
   * 'LocationPostalCode', 'LocationProvince', 'LocationRegion', 'LocationState',
   * 'LocationTimezone', 'MeasurementDateCreation', 'MeasurementDateModify', 'MeasurementStatus',
   * 'MeasurementVersion', 'BarCode', 'Brand', 'IdentityGovernmentID', 'PersonFirstName',
   * 'PersonFullName', 'PersonLastName', 'PersonMiddleName', 'IdentityServiceEmail',
   * 'IdentityServiceFacebook', 'IdentityServicePhone', 'IdentityServiceTwitter', 'Image', 'Place',
   * 'ReferenceDescription', 'ReferenceImageURL', 'ReferencePhonetic', 'ReferenceURL'
  */
  label?: string;
}

/**
 * Represents the enrichment entity info used in API requests (entity level)
*/
export interface EntityEnrichmentInformation {
  /**
   * Gets a value indicating whether there is an enriched entity for the ds entity.
  */
  hasEnrichedEntity?: boolean;
  /**
   * Name of the enriched entity.
  */
  enrichedEntityName?: string;
  /**
   * Gets the list configured enrichments on the ds entity.
  */
  configuredEnrichments?: string[];
}

/**
 * Represents the entity info used in API requests (entity level)
*/
export interface DatasourceEntityInformation {
  /**
   * Name of the entity.
  */
  entityName?: string;
  /**
   * Primary key name of the entity. We require the entity to have a single column primary key
   * column
  */
  primaryKey?: string;
  /**
   * Possible values include: 'unspecified', 'profile', 'conflationMap', 'activity',
   * 'aggregateKpi', 'profileKpi', 'unifiedActivity', 'segment', 'intelligence',
   * 'genericPrediction', 'enrichment', 'insights', 'derivedEntity', 'corrupt', 'selfConflation',
   * 'conflationManualReview', 'selfConflationManualReview', 'semanticActivity',
   * 'segmentMembership', 'hierarchy', 'dataLineage', 'transform', 'semanticEntity'
  */
  entityType?: string;
  /**
   * Time stamp field name.
  */
  timestampFieldName?: string;
  /**
   * Semantic labels by attribute name.
  */
  semanticLabels?: AttributeSemanticInformation[];
  entityEnrichmentInfo?: EntityEnrichmentInformation;
  /**
   * Gets theDeltaTable version of this entity.
  */
  deltaTableVersion?: number;
  /**
   * Specifies if CDM definition for this entity should be auto generated.
  */
  autoGenerateCDMDefinition?: boolean;
}

/**
 * Represents a Incremental Refresh Property.
*/
export interface IncrementalRefreshProperties {
  /**
   * Name of the entity.
  */
  entityName?: string;
  /**
   * Column to detect changes.
  */
  detectChangesAttributeName?: string;
  /**
   * Column to get incremental data.
  */
  filterByAttributeName?: string;
  /**
   * Granularity of the incremental refresh.
  */
  incrementalGranularity?: string;
  /**
   * Incremental period.
  */
  incrementalPeriods?: number;
  /**
   * Indicating whether to refresh completed periods or not.
  */
  refreshCompletePeriods?: boolean;
  /**
   * Off set period.
  */
  incrementalPeriodsOffset?: number;
  /**
   * Primary key of the entity.
  */
  primaryKeyAttributeName?: string;
  /**
   * Rolling window granularity.
  */
  rollingWindowGranularity?: string;
  /**
   * Rolling window period.
  */
  rollingWindowPeriods?: number;
}

/**
 * Represents metadata for a Customer Insights data source.
*/
export interface DataSourceMetadata {
  /**
   * Possible values include: 'salesforce', 'dynamics365', 'powerQuery', 'attachCdm',
   * 'attachSynapse', 'attachCds', 'powerPlatform', 'datahub', 'firstParty'
  */
  kind?: string;
  /**
   * Represents if still in active state
  */
  isActive?: boolean;
  /**
   * List of all Entity Names
  */
  entityNames?: string[];
  entitiesCount?: number;
  /**
   * Unique identity for this object.
  */
  dataSourceId?: string;
  /**
   * Unique name of the dataSource.
  */
  name?: string;
  /**
   * FriendlyName of the dataSource.
  */
  friendlyName?: string;
  /**
   * Entity information, by entity name.
  */
  entityInformation?: DatasourceEntityInformation[];
  /**
   * Possible values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress', 'updating', 'quickUpdate',
   * 'deactivated'
  */
  provisioningState?: string;
  /**
   * Represents the time datasource was last refreshed.
  */
  lastRefresh?: Date;
  /**
   * Possible values include: 'notUpdated', 'updated', 'updating', 'updateFailed',
   * 'updateCancelled'
  */
  refreshState?: string;
  /**
   * Incremental refresh properties for entities.
  */
  incrementalRefreshProperties?: IncrementalRefreshProperties[];
  /**
   * Model path for CDM data source.
  */
  modelJsonPath?: string;
  /**
   * Version number of this object.
  */
  version?: number;
  /**
   * UPN of the user who last updated this record.
  */
  updatedBy?: string;
  /**
   * Time this object was last updated.
  */
  updatedUtc?: Date;
  /**
   * Email address of the user who created this record.
  */
  createdBy?: string;
  /**
   * Time this object was initially created.
  */
  createdUtc?: Date;
  /**
   * Customer Insights instance id associated with this object.
  */
  instanceId?: string;
}

export interface QueryMetadata {
  queryId?: string;
  queryName?: string;
  queryGroupId?: string;
  entityName?: string;
  loadEnabled?: boolean;
}

export interface Mashup {
  fastCombine?: boolean;
  allowNativeQueries?: boolean;
  queriesMetadata?: { [propertyName: string]: QueryMetadata };
  document?: string;
}

export interface Annotation {
  name?: string;
  value?: string;
}

export interface Entity {
  name?: string;
  description?: string;
  isHidden?: boolean;
  annotations?: Annotation[];
}

export interface Relationship {
  name?: string;
  description?: string;
  annotations?: Annotation[];
}

export interface ReferenceModel {
  id?: string;
  location?: string;
}

export interface Model {
  name?: string;
  description?: string;
  isHidden?: boolean;
  version?: string;
  culture?: string;
  pbitimeZone?: string;
  modifiedTime?: Date;
  pbimashup?: Mashup;
  annotations?: Annotation[];
  entities?: Entity[];
  relationships?: Relationship[];
  referenceModels?: ReferenceModel[];
}

/**
 * Data source Information
*/
export interface DataSourceInfo {
  dataSourceMetadata?: DataSourceMetadata;
  model?: Model;
}

export interface OkResult {
  statusCode?: number;
}

export interface ODataErrorDetail {
  errorCode?: string;
  message?: string;
  target?: string;
}

export interface ODataTypeAnnotation {
  typeName?: string;
}

export interface ODataValue {
  typeAnnotation?: ODataTypeAnnotation;
}

export interface ODataInnerError {
  properties?: { [propertyName: string]: ODataValue };
  message?: string;
  typeName?: string;
  stackTrace?: string;
  innerError?: ODataInnerError;
}

export interface ODataInstanceAnnotation {
  name?: string;
  value?: ODataValue;
  typeAnnotation?: ODataTypeAnnotation;
}

export interface ODataError {
  errorCode?: string;
  message?: string;
  target?: string;
  details?: ODataErrorDetail[];
  innerError?: ODataInnerError;
  instanceAnnotations?: ODataInstanceAnnotation[];
  typeAnnotation?: ODataTypeAnnotation;
}

export interface CreatedResult {
  location?: string;
  value?: any;
  formatters?: any[];
  contentTypes?: string[];
  declaredType?: string;
  statusCode?: number;
}

export interface AcceptedResult {
  location?: string;
  value?: any;
  formatters?: any[];
  contentTypes?: string[];
  declaredType?: string;
  statusCode?: number;
}

export interface NoContentResult {
  statusCode?: number;
}

export interface ODataEntityPayload {
  odatacontext?: string;
  odatacount?: number;
  value?: any[];
}

export interface IEdmType {
  /**
   * Possible values include: 'none', 'primitive', 'entity', 'complex', 'collection',
   * 'entityReference', 'enum', 'typeDefinition', 'untyped', 'path'
  */
  typeKind?: string;
}

/**
 * Represents seachable attribute properties
*/
export interface IAttributeSearchProperties {
  /**
   * Gets a value indicating whether the attribute supports full text search.
  */
  isSearchable?: boolean;
  /**
   * Gets a value indicating whether the attribute supports filtering.
  */
  isFilterable?: boolean;
  /**
   * Gets a value indicating whether the attribute can be included as facet results.
  */
  isFacetable?: boolean;
  /**
   * Gets a value indicating whether the attribute can be included in orderby directives.
  */
  isSortable?: boolean;
  /**
   * Gets an optional specification for search faceting used at query time (advanced).
   * this is the part behind the comma in the examples below.
   * bucket facet: "price,interval:10"
   * other type: "listPrice,values:10|25|100|500|1000|2500"
   * value facet: city,count:5
  */
  facetSpecification?: string;
}

/**
 * Represents attribute Metadata
*/
export interface IAttributeMetadata {
  /**
   * Unique Name for Attribute Metadata
  */
  name?: string;
  /**
   * User friendly Name for Attribute Metadata
  */
  friendlyName?: string;
  /**
   * Base Name for Attribute Metadata
  */
  baseName?: string;
  /**
   * Gets data type for property.
  */
  dataType?: string;
  /**
   * Gets semantic type for property. Possible values include: 'CalendarDate',
   * 'CalendarDayOfMonth', 'CalendarDayOfWeek', 'CalendarDayOfYear', 'CalendarHalfYear',
   * 'CalendarMonthOfYear', 'CalendarMonth', 'CalendarWeek', 'CalendarYear', 'CalendarFiscalDate',
   * 'CalendarFiscalDayOfMonth', 'CalendarFiscalDayOfWeek', 'CalendarFiscalDayOfYear',
   * 'CalendarFiscalHalfYear', 'CalendarFiscalMonthOfYear', 'CalendarFiscalMonth',
   * 'CalendarFiscalQuarter', 'CalendarFiscalWeekOfMonth', 'CalendarFiscalWeekOfYear',
   * 'CalendarFiscalWeek', 'CalendarFiscalYear', 'Account', 'Channel', 'Contact', 'Customer',
   * 'Language', 'Organization', 'OrganizationUnit', 'Person', 'Product', 'ProductGroup',
   * 'LocationAddress', 'LocationAddressStreet', 'LocationCity', 'LocationContinent',
   * 'LocationCountry', 'LocationCounty', 'LocationLatitude', 'LocationLongitude', 'LocationPoint',
   * 'LocationPostalCode', 'LocationProvince', 'LocationRegion', 'LocationState',
   * 'LocationTimezone', 'MeasurementDateCreation', 'MeasurementDateModify', 'MeasurementStatus',
   * 'MeasurementVersion', 'BarCode', 'Brand', 'IdentityGovernmentID', 'PersonFirstName',
   * 'PersonFullName', 'PersonLastName', 'PersonMiddleName', 'IdentityServiceEmail',
   * 'IdentityServiceFacebook', 'IdentityServicePhone', 'IdentityServiceTwitter', 'Image', 'Place',
   * 'ReferenceDescription', 'ReferenceImageURL', 'ReferencePhonetic', 'ReferenceURL'
  */
  semanticType?: string;
  searchProperties?: IAttributeSearchProperties;
}

/**
 * Represents a DCI entity data partition
*/
export interface PartitionMetadata {
  /**
   * Gets the name of the data partition
  */
  name?: string;
  /**
   * Gets the uri location of the data
  */
  location?: string;
  /**
   * Gets the refresh time of the data partition
  */
  refreshTime?: Date;
  fileFormatSettings?: any;
  /**
   * Gets a value indicating whether a partition is CI Generated or not.
  */
  isCIGenerated?: boolean;
  /**
   * Gets a value indicating whether a partition need to be forced for SAS authentication.
  */
  forceSasAuth?: boolean;
  /**
   * Flag to represent header presence (if any)
  */
  hasHeader?: boolean;
}

/**
 * Represents Entity Metadata.
*/
export interface IEntityMetadata {
  /**
   * Gets the name of the entity. eg: Contact.
  */
  name?: string;
  /**
   * Gets the unqiue logical name for the entity
   * If entity is from a datasource, QualifiedEntityName = datasourceId_EntityName eg:
   * d8d3b26a-a8ad-42f7-901e-f7f745003a84_Contact.
   * If entity is generated by C360, QualifiedEntityName = EntityName eg: Contact.
  */
  qualifiedEntityName?: string;
  /**
   * Gets the datasource name of this entity, if no data source, return null or emptyString
  */
  dataSourceName?: string;
  /**
   * Possible values include: 'dynamics365', 'salesforce', 'conflationSortAndRefine',
   * 'conflationDeduplication', 'conflationMatchPairs', 'conflationResolveConflicts', 'enriched',
   * 'kpi', 'powerQuery', 'dataPreparation', 'intelligence', 'unifiedActivity', 'segmentation',
   * 'ingestion', 'attachCdm', 'genericPrediction', 'attachCds', 'unknown', 'powerPlatform',
   * 'datahub', 'insights', 'derivedEntity', 'powerPlatformSource', 'powerPlatformBYDL',
   * 'powerPlatformBYDLSource', 'semanticActivity', 'segmentMembership', 'firstParty', 'hierarchy',
   * 'contact', 'semanticEntity', 'attachSynapse', 'transform'
  */
  dataflowType?: string;
  /**
   * Gets a value indicating whether Sas Auth is used for the entity.
  */
  shouldUseSparkSasAuth?: boolean;
  /**
   * Gets the original datasourceid of this entity, if no data source, return null or emptyString
  */
  datasourceId?: string;
  /**
   * Possible values include: 'unspecified', 'profile', 'conflationMap', 'activity',
   * 'aggregateKpi', 'profileKpi', 'unifiedActivity', 'segment', 'intelligence',
   * 'genericPrediction', 'enrichment', 'insights', 'derivedEntity', 'corrupt', 'selfConflation',
   * 'conflationManualReview', 'selfConflationManualReview', 'semanticActivity',
   * 'segmentMembership', 'hierarchy', 'dataLineage', 'transform', 'semanticEntity'
  */
  entityType?: string;
  /**
   * Gets entity attributes.
  */
  attributes?: IAttributeMetadata[];
  /**
   * Gets the keys of the entity.
  */
  keys?: IAttributeMetadata[][];
  /**
   * Gets entity relationships.
  */
  relationships?: IRelationshipMetadata[];
  timestampAttribute?: IAttributeMetadata;
  incrementalAttribute?: IAttributeMetadata;
  /**
   * Possible values include: 'Account', 'AccountLeads', 'ActivityParty', 'ActivityPointer',
   * 'Annotation', 'Appointment', 'BusinessUnit', 'Campaign', 'CampaignActivity', 'CampaignItem',
   * 'CampaignResponse', 'Characteristic', 'Competitor', 'CompetitorAddress', 'CompetitorProduct',
   * 'Connection', 'ConnectionRole', 'Contact', 'Contract', 'ContractDetail', 'Customer',
   * 'CustomerAddress', 'CustomerRelationship', 'Discount', 'DiscountType', 'Email', 'Entitlement',
   * 'Equipment', 'Fax', 'Feedback', 'Goal', 'Incident', 'Invoice', 'InvoiceDetail', 'KbArticle',
   * 'KnowledgeArticle', 'Lead', 'LeadAddress', 'Letter', 'Metric', 'Opportunity', 'Organization',
   * 'Owner', 'PhoneCall', 'Position', 'PriceLevel', 'Product', 'Quote', 'RatingModel', 'Resource',
   * 'ResourceGroup', 'SalesLiterature', 'SalesOrder', 'Service', 'ServiceAppointment', 'Site',
   * 'SLA', 'SocialActivity', 'SocialProfile', 'SystemUser', 'Task', 'Team', 'Territory', 'UoM'
  */
  semanticType?: string;
  /**
   * Gets last refresh time for entity.
  */
  refreshTime?: Date;
  /**
   * Gets entity data partitions.
  */
  partitions?: PartitionMetadata[];
  /**
   * Gets entity incremental upsert data partitions.
  */
  incrementalUpsertPartitions?: PartitionMetadata[];
  /**
   * Gets entity incremental delete data partitions.
  */
  incrementalDeletePartitions?: PartitionMetadata[];
  /**
   * Gets entity data parquet partitions.
  */
  fullPartitionsParquet?: PartitionMetadata[];
  /**
   * Gets entity incremental upsert data parquet partitions.
  */
  incrementalUpsertPartitionsParquet?: PartitionMetadata[];
  /**
   * Gets entity incremental delete data parquet partitions.
  */
  incrementalDeletePartitionsParquet?: PartitionMetadata[];
  /**
   * Gets base entity name
  */
  annotations?: Annotation[];
}

/**
 * Represents Relationship Metadata
*/
export interface IRelationshipMetadata {
  /**
   * Unique Name for relationship
  */
  name?: string;
  /**
   * User Friendly Name for relationship
  */
  friendlyName?: string;
  fromAttribute?: IAttributeMetadata;
  toAttribute?: IAttributeMetadata;
  /**
   * Possible values include: 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
   * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
  */
  relationshipType?: string;
  dataSourceEntity?: IEntityMetadata;
  /**
   * List of data source mapping attributes
  */
  dataSourceMappingAttributes?: IAttributeMetadata[];
}

/**
 * Represents Entity Model.
*/
export interface IC360EntityModel {
  /**
   * Gets the instance ID associated with the model.
  */
  instanceId?: string;
  /**
   * Gets the dataflow ID associated with the model.
  */
  dataflowId?: string;
  /**
   * Gets the datasource ID associated with the model.
  */
  datasourceId?: string;
  /**
   * Possible values include: 'dynamics365', 'salesforce', 'conflationSortAndRefine',
   * 'conflationDeduplication', 'conflationMatchPairs', 'conflationResolveConflicts', 'enriched',
   * 'kpi', 'powerQuery', 'dataPreparation', 'intelligence', 'unifiedActivity', 'segmentation',
   * 'ingestion', 'attachCdm', 'genericPrediction', 'attachCds', 'unknown', 'powerPlatform',
   * 'datahub', 'insights', 'derivedEntity', 'powerPlatformSource', 'powerPlatformBYDL',
   * 'powerPlatformBYDLSource', 'semanticActivity', 'segmentMembership', 'firstParty', 'hierarchy',
   * 'contact', 'semanticEntity', 'attachSynapse', 'transform'
  */
  dataflowType?: string;
  /**
   * Gets entities in the model.
  */
  entities?: IEntityMetadata[];
}

/**
 * The information about an entity size
*/
export interface EntitySize {
  /**
   * Gets the entity Name
  */
  qualifiedEntityName?: string;
  /**
   * Gets the size of the entire entity (in Bytes)
  */
  size?: number;
  /**
   * Gets the row count of the entity
  */
  rowCount?: number;
}

/**
 * Represents metadata for a Hierarchy Dependency.
*/
export interface HierarchyDependency {
  /**
   * Gets the source entities fully qualified name.
  */
  sourceEntity?: string;
  /**
   * Gets entity account Id.
  */
  accountIdAttribute?: string;
  /**
   * Gets parent account id.
  */
  parentAccountIdAttribute?: string;
}

/**
 * Represents metadata for a Account Hierarchy.
*/
export interface HierarchyMetadata {
  /**
   * Gets the unique name of the hierarchy.
  */
  name?: string;
  /**
   * Gets the Display name of the hierarchy.
  */
  displayName?: string;
  dependency?: HierarchyDependency;
  /**
   * Version number of this object.
  */
  version?: number;
  /**
   * UPN of the user who last updated this record.
  */
  updatedBy?: string;
  /**
   * Time this object was last updated.
  */
  updatedUtc?: Date;
  /**
   * Email address of the user who created this record.
  */
  createdBy?: string;
  /**
   * Time this object was initially created.
  */
  createdUtc?: Date;
  /**
   * Customer Insights instance id associated with this object.
  */
  instanceId?: string;
}

export interface OkObjectResult {
  value?: any;
  formatters?: any[];
  contentTypes?: string[];
  declaredType?: string;
  statusCode?: number;
}

/**
 * The instance info.
*/
export interface InstanceInfo {
  /**
   * Gets the unique ID for this instance.
  */
  instanceId?: string;
  /**
   * Gets the instance name. (not persisted in store)
  */
  name?: string;
  /**
   * Possible values include: 'trial', 'sandbox', 'production', 'pitchDemo', 'pov'
  */
  instanceType?: string;
  /**
   * Gets the time the instance is set to expire. (not persisted in store)
  */
  expiryTimeUtc?: Date;
  /**
   * Gets the total number of extensions allowed if this is trial instance (not persisted in store)
  */
  maxTrialExtensionsAllowed?: number;
  /**
   * Stores the details of trial extensions done if this is a trial instance (not persisted in
   * store)
  */
  trialExtensionHistory?: string;
  /**
   * Gets the unique identifier for the scale unit (not persisted in store)
  */
  scaleUnitId?: string;
  /**
   * Gets the Azure Region where the scale unit resides (not persisted in store)
  */
  azureRegion?: string;
  /**
   * Gets the Insights App Type for g. Verity, Engagement Insight etc. (not persisted in store)
  */
  platformType?: string;
}

/**
 * Represents a embedded PowerBI report
*/
export interface EmbeddedReport {
  /**
   * Possible values include: 'overview', 'sales', 'marketing', 'service', 'instanceZero'
  */
  reportType?: string;
  /**
   * Gets the Uri used for Power BI report embedding.
  */
  embedUrl?: string;
  /**
   * Gets the id used for Power BI report embedding.
  */
  reportId?: string;
}

/**
 * Represents an instance provisioning error
*/
export interface InstanceProvisioningError {
  /**
   * Possible values include: 'invalidDynamics365DataSourceCredentials',
   * 'invalidSalesforceDataSourceCredentials', 'internalError', 'bapCannotCreateEnvironment'
  */
  errorCode?: string;
  /**
   * Gets string formatting arguments for the provisioning error
  */
  errorArgs?: string[];
}

/**
 * Represents the status of a provisioning operation
*/
export interface ProvisioningStatus {
  /**
   * Gets the total number of steps in the provisioning operation.
  */
  totalSteps?: number;
  /**
   * Gets the current step in the provisioning operation.
  */
  currentStep?: number;
  /**
   * Possible values include: 'starting', 'creating', 'loadingData', 'completed'
  */
  currentOperation?: string;
  /**
   * Gets the instance created time.
  */
  createdTimeUtc?: Date;
  /**
   * Gets the instance last updated time.
  */
  lastUpdatedTimeUtc?: Date;
  /**
   * Gets a list of provisioning errors.
  */
  errors?: InstanceProvisioningError[];
}

/**
 * Represents a email subscription for the instance
*/
export interface EmailSubscriptionMetadata {
  /**
   * Possible values include: 'finishData'
  */
  emailSubscription?: string;
  /**
   * Gets the email for the subscription.
  */
  email?: string;
  /**
   * Gets the current status for the subscription.
  */
  status?: string;
}

/**
 * Represents a refresh schedule for the state machine
*/
export interface DataRefreshSchedule {
  /**
   * Gets a value indicating whether the schedule is active.
  */
  isActive?: boolean;
  /**
   * Gets the ID of the timezone
  */
  timezoneId?: string;
  /**
   * Gets the schedule in CRON format
  */
  cronSchedules?: string[];
  /**
   * Gets the ID of the schedule
  */
  scheduleId?: string;
  /**
   * Customer Insights instance id associated with this object.
  */
  instanceId?: string;
}

/**
 * The information for a trial instance
*/
export interface TrialInfo {
  /**
   * Gets the list of section were helped is disabled
  */
  helpSectionsVisited?: string[];
  /**
   * Gets a value indicating whether the initial ingestion has completed
  */
  hasCompletedInitialIngestion?: boolean;
  /**
   * Gets a value indicating whether the trial environment is activated or not
  */
  trialActivated?: boolean;
}

/**
 * The information for CDS Organization in BAP
*/
export interface CdsOrgInfo {
  /**
   * Gets the Cds Organization Friendly Name
  */
  friendlyName?: string;
  /**
   * Gets the Cds Organization Url
  */
  url?: string;
  /**
   * Gets the Cds Organization State
  */
  state?: string;
  /**
   * Gets region location of Cds Organization
  */
  location?: string;
  /**
   * Gets SKU of Cds Organization
  */
  environmentSku?: string;
  /**
   * Gets the expiration time of CDS Organization if the SKU is Trial
  */
  expirationTime?: Date;
  /**
   * Gets the max allowed expiration time of CDS Organization if the SKU is Trial
  */
  maxAllowedExpirationTime?: Date;
}

/**
 * The information for datalake folder in CDS
*/
export interface DatalakeFolderDetail {
  /**
   * Gets the datalake folder Friendly Name
  */
  name?: string;
  /**
   * Gets the Cds datalake folder unique Name
  */
  uniqueName?: string;
}

/**
 * The information on CDS MDL datalake folders
*/
export interface CdsMdlInfo {
  privateWorkSpace?: DatalakeFolderDetail;
  publicWorkSpace?: DatalakeFolderDetail;
}

/**
 * The information on how authentication needs to happen for embedded resources
*/
export interface PbiProvisioningConfig {
  /**
   * Indicates whether we need to use client login for Pbi Embedded
  */
  useClientLoginForReports?: boolean;
  /**
   * Indicates whether we need to use client login for PQ Embedded
  */
  useClientLoginForPQ?: boolean;
  /**
   * Power BI Capacity id
  */
  capacityId?: string;
}

/**
 * Extension Details of trial instance
*/
export interface TrialExtensionDetails {
  /**
   * Gets the extended on date
  */
  extendedOn?: Date;
  /**
   * Gets the number of days Extended
  */
  extendedForDays?: string;
  /**
   * Gets the Name of Extended By
  */
  extendedBy?: string;
}

/**
 * The instance metadata.
*/
export interface InstanceMetadata {
  isB2B?: boolean;
  isB2C?: boolean;
  isByoPbi?: boolean;
  isByoSynapse?: boolean;
  isCdsMdlOrCdsByodl?: boolean;
  /**
   * Gets the user defined instance name.
  */
  name?: string;
  /**
   * Possible values include: 'new', 'creating', 'active', 'createFailed', 'updateFailed',
   * 'deleting', 'refreshCredentials', 'resetInstanceInProgress', 'updating', 'quickUpdate',
   * 'deactivated'
  */
  provisioningState?: string;
  /**
   * Possible values include: 'trial', 'sandbox', 'production', 'pitchDemo', 'pov'
  */
  instanceType?: string;
  refreshSchedule?: DataRefreshSchedule;
  /**
   * Gets the time the instance is set to expire.
  */
  expiryTimeUtc?: Date;
  /**
   * Gets the Azure region where the instance lives.
  */
  region?: string;
  cdsOrgInfo?: CdsOrgInfo;
  cdsMdlInfo?: CdsMdlInfo;
  /**
   * Gets the total number of extensions allowed if this is trial instance
  */
  maxTrialExtensionsAllowed?: number;
  /**
   * Stores the details of trial extensions done if this is a trial instance
  */
  trialExtensionHistory?: string;
  /**
   * Gets a value indicating if credential  is required to refresh any of the datasources
  */
  isRefreshCredentialRequired?: boolean;
  /**
   * Stores the details of trial extensions done if this is a trial instance
  */
  trialExtensionDetails?: TrialExtensionDetails[];
  /**
   * Gets the Workspace type, whether B2B or B2C (Main)
  */
  configuredWorkspaces?: string[];
  /**
   * Field to store the Insights Partner who are onboarded to Insights Platform.
  */
  platformType?: string;
  /**
   * Gets the Azure Region where the scale unit resides (not persisted in store)
  */
  azureRegion?: string;
  /**
   * Version number of this object.
  */
  version?: number;
  /**
   * UPN of the user who last updated this record.
  */
  updatedBy?: string;
  /**
   * Time this object was last updated.
  */
  updatedUtc?: Date;
  /**
   * Email address of the user who created this record.
  */
  createdBy?: string;
  /**
   * Time this object was initially created.
  */
  createdUtc?: Date;
  /**
   * Customer Insights instance id associated with this object.
  */
  instanceId?: string;
}

/**
 * Represents mapping between enity fields and Linked Metadata.
*/
export interface MappedSecretMetadata {
  /**
   * The identifier for field mapping to a keyVault
  */
  mappedFieldId?: string;
  /**
   * Gets uniqueId of the KeyVault
  */
  linkedKeyVaultMetadataId?: string;
  /**
   * Gets uniqueId of entity Mapping Secrets
  */
  mappingEntityId?: string;
  /**
   * Gets Secret Names for Fields Mapped in KeyVault
  */
  byoKeyVaultFieldMapping?: { [propertyName: string]: string };
  /**
   * Customer Insights instance id associated with this object.
  */
  instanceId?: string;
}

/**
 * Represents a Resource metadata
*/
export interface ResourceMetadata {
  /**
   * Possible values include: 'bearerAuthenticationConnection', 'sshKeyAuthenticationConnection',
   * 'apiKeyAuthenticationConnection', 'basicAuthenticationConnection', 'firstPartyADConnection',
   * 'amazonS3Connection', 'adlsGen2', 'd365Sales', 'd365Marketing', 'attachCds', 'ftp',
   * 'facebookAds', 'amlWorkspace', 'mlStudioWebservice', 'adRoll', 'rollWorks', 'constantContact',
   * 'campaignMonitor', 'http', 'dotDigital', 'mailchimp', 'linkedIn', 'googleAds', 'marketo',
   * 'microsoftAds', 'omnisend', 'sendGrid', 'sendinblue', 'activeCampaign', 'autopilot',
   * 'klaviyo', 'snapchat', 'powerBI', 'azureSql', 'synapse'
  */
  kind?: string;
  /**
   * Gets the Id of the resource.
  */
  resourceId?: string;
  /**
   * Gets the Id of the operation being performed on the resource.
  */
  operationId?: string;
  /**
   * Gets the Name of the resource.
  */
  name?: string;
  /**
   * Gets the Description of the resource.
  */
  description?: string;
  /**
   * MetadataId for Linked KeyVaultMetadata
  */
  keyVaultMetadataId?: string;
  mappedSecrets?: MappedSecretMetadata;
  /**
   * Version number of this object.
  */
  version?: number;
  /**
   * UPN of the user who last updated this record.
  */
  updatedBy?: string;
  /**
   * Time this object was last updated.
  */
  updatedUtc?: Date;
  /**
   * Email address of the user who created this record.
  */
  createdBy?: string;
  /**
   * Time this object was initially created.
  */
  createdUtc?: Date;
  /**
   * Customer Insights instance id associated with this object.
  */
  instanceId?: string;
}

/**
 * The information for bring your own Power BI
*/
export interface ByoPbiProvisioningInfo {
  /**
   * Storage account subscriptionId.
  */
  storageSubscriptionId?: string;
  /**
   * Storage account Resource Group.
  */
  storageResourceGroup?: string;
  /**
   * Storage account Region.
  */
  storageResourceRegion?: string;
  /**
   * Storage account tenant.
  */
  storageResourceTenantId?: string;
  /**
   * Pbi Capacity Id.
  */
  capacityId?: string;
  /**
   * Synapse serverless sql host name
  */
  synapseServerlessSqlHostName?: string;
}

export interface InstanceCreationRequest {
  instanceMetadata?: InstanceMetadata;
  byosaResourceMetadata?: ResourceMetadata;
  cdsResourceMetadata?: ResourceMetadata;
  isCdsMdlStorageEnabled?: boolean;
  isCiToByosaMigrationEnabled?: boolean;
  /**
   * Possible values include: 'skip', 'create', 'attach'
  */
  bapProvisioningType?: string;
  isPbiProvisioningRequired?: boolean;
  isDataverseUpdateRequested?: boolean;
}

export interface InstanceCopyRequest {
  instanceIdToCopy?: string;
  instanceMetadata?: InstanceMetadata;
  byosaResourceMetadata?: ResourceMetadata;
  cdsResourceMetadata?: ResourceMetadata;
  isCdsMdlStorageEnabled?: boolean;
  isCiToByosaMigrationEnabled?: boolean;
  /**
   * Possible values include: 'skip', 'create', 'attach'
  */
  bapProvisioningType?: string;
  isPbiProvisioningRequired?: boolean;
  isDataverseUpdateRequested?: boolean;
}

/**
 * Represents the base linked entity.
*/
export interface MeasureLinkedEntity {
  /**
   * Possible values include: 'base', 'join', 'scalar'
  */
  kind?: string;
  /**
   * Gets the name of the entity.
  */
  entity?: string;
  /**
   * Gets the alias of the entity.
  */
  alias?: string;
}

/**
 * Represents a variable condition.
*/
export interface MeasureVariableCondition {
  /**
   * Possible values include: 'replaceNulls', 'replaceTargetValues'
  */
  kind?: string;
}

/**
 * Represents a set of variable conditions to apply to a MeasureVariable.
*/
export interface MeasureVariableConditionGroup {
  /**
   * Attribute to use in condition.
  */
  name?: string;
  /**
   * Gets the MeasureVariableConditions.
  */
  conditions?: MeasureVariableCondition[];
}

/**
 * Represents a variable (computed column) in a measure
*/
export interface MeasureVariable {
  /**
   * Possible values include: 'arithmetic', 'date'
  */
  kind?: string;
  /**
   * Gets the name of the variable
  */
  name?: string;
  /**
   * Gets the data type of the variable
  */
  dataType?: string;
  /**
   * Gets the expression text for computing the variable
  */
  expressionText?: string;
  /**
   * Gets the variable conditions
  */
  variableConditionGroups?: MeasureVariableConditionGroup[];
}

/**
 * Base class to represent a measure expression
*/
export interface MeasureExpression {
  /**
   * Possible values include: 'constant', 'property', 'memberAccess', 'functionCall', 'and', 'or',
   * 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo', 'lessThan', 'lessThanOrEqualTo',
   * 'contains', 'startsWith', 'endsWith', 'isNull', 'isNotNull', 'negate', 'add', 'subtract',
   * 'multiply', 'divide', 'modulo', 'exponent', 'today', 'now'
  */
  kind?: string;
}

/**
 * Represents a base Segment Query.
*/
export interface SegmentMembershipCriteria {
  /**
   * Possible values include: 'post', 'default', 'consent', 'engagement'
  */
  kind?: string;
  /**
   * Possible values include: 'and', 'or'
  */
  logicalOperator?: string;
  /**
   * Gets the Attribute of the entity used in segment criteria.
  */
  attribute?: string;
  /**
   * Possible values include: 'equals', 'notEquals', 'greaterThan', 'greaterThanOrEqualTo',
   * 'lessThan', 'lessThanOrEqualTo', 'any', 'contains', 'startsWith', 'endsWith', 'isNull',
   * 'isNotNull', 'all', 'isIn', 'isWithinLast', 'isBetween', 'isNotBetween', 'yearToDate',
   * 'dayOf', 'monthOf', 'yearOf', 'dayOfWeek', 'timeAt', 'childOf', 'parentOf'
  */
  comparisonOperator?: string;
  /**
   * Gets the list of Child criteria of segment.
  */
  childCriterias?: SegmentMembershipCriteria[];
  /**
   * Gets the Value in criteria.
  */
  value?: string;
  /**
   * Gets a value indicating whether case is ignored for this criteria.
  */
  ignoreCase?: boolean;
  /**
   * Gets the list of values in criteria.
  */
  listOfValues?: string[];
  /**
   * flag set to true if entries are of time format
  */
  isTime?: boolean;
}

/**
 * Represents a dimension
*/
export interface MeasureDimension {
  /**
   * Gets the field on which group by will be applied
  */
  field?: string;
  /**
   * Gets the alias for the field
  */
  alias?: string;
  /**
   * Gets the display name for the dimension
  */
  displayName?: string;
  /**
   * Gets the order for the dimension
  */
  order?: number;
  /**
   * Possible values include: 'none', 'day', 'month', 'year'
  */
  bucket?: string;
  /**
   * Gets a value indicating whether the dimension is readonly or not
  */
  isReadOnly?: boolean;
}

/**
 * Represents an aggregate
*/
export interface MeasureAggregate {
  /**
   * Possible values include: 'sum', 'avg', 'min', 'max', 'count', 'countDistinct', 'first',
   * 'last', 'argMax', 'argMin'
  */
  operation?: string;
  /**
   * Gets the field on which the aggregate operation is applied
  */
  field?: string;
  /**
   * Gets the alias for the field
  */
  alias?: string;
  /**
   * Gets the display name for the aggregate
  */
  displayName?: string;
  /**
   * Gets the order for the aggregate
  */
  order?: number;
  /**
   * Possible values include: 'rollup'
  */
  operationScope?: string;
  /**
   * Gets list of aggregates of the measure.
  */
  aggregates?: MeasureAggregate[];
  /**
   * Gets a value indicating whether to display the field in results
  */
  isIncluded?: boolean;
}

/**
 * Collection of the entity name and other info of the source activity entity ingested by user.
*/
export interface ActivitySourceEntityInfo {
  /**
   * Gets the qualified entity name of the activity source entity.
  */
  entityName?: string;
}

/**
 * Collection of the Activity type and entity name corresponding to that activity type.
*/
export interface InsightActivityDetails {
  /**
   * Gets the name of the activity Type.
  */
  activityType?: string;
  /**
   * Gets the name of the entity that corresponds to the activity type.
  */
  entityName?: string;
  /**
   * Collection of the entity name and other info of the source activity entity ingested by user.
  */
  activitySourceEntitiesInfo?: ActivitySourceEntityInfo[];
}

/**
 * Represents a reference to an entity
*/
export interface EntityDependency {
  /**
   * Gets the qualified entity name.
  */
  qualifiedEntityName?: string;
  /**
   * Possible values include: 'unspecified', 'profile', 'conflationMap', 'activity',
   * 'aggregateKpi', 'profileKpi', 'unifiedActivity', 'segment', 'intelligence',
   * 'genericPrediction', 'enrichment', 'insights', 'derivedEntity', 'corrupt', 'selfConflation',
   * 'conflationManualReview', 'selfConflationManualReview', 'semanticActivity',
   * 'segmentMembership', 'hierarchy', 'dataLineage', 'transform', 'semanticEntity'
  */
  type?: string;
  /**
   * Gets the list of attributes included in the dependency.
  */
  attributeNames?: string[];
  /**
   * Gets the list of relationships included in the dependency
  */
  relationshipNames?: string[];
  /**
   * Contains the Activity type and entity name corresponding to that activity type.
  */
  activityDetails?: InsightActivityDetails[];
}

/**
 * Represents a measure definition
*/
export interface MeasureDefinition {
  /**
   * Possible values include: 'entity', 'attribute'
  */
  kind?: string;
  /**
   * Gets a value indicating whether the current measure is a scalar measure e doesn't have any
   * dimensions
  */
  isScalar?: boolean;
  /**
   * Gets list of linked entities associated with the measure.
  */
  linkedEntities?: MeasureLinkedEntity[];
  /**
   * Gets list of variables (computed columns) for the measure.
  */
  variables?: MeasureVariable[];
  filters?: MeasureExpression;
  filteringCriteria?: SegmentMembershipCriteria;
  /**
   * Gets list of dimensions with the measure.
  */
  dimensions?: MeasureDimension[];
  /**
   * Gets list of aggregates of the measure.
  */
  aggregates?: MeasureAggregate[];
  /**
   * Gets a value indicating whether the current measure is a profile measure
  */
  isProfile?: boolean;
  /**
   * Gets the user specified custom SQL query.
  */
  measureQuerySql?: string;
  /**
   * Possible values include: 'structured', 'manual'
  */
  type?: string;
  /**
   * Gets the indicating whether the Business Measure is Scalar or not.
  */
  isManualQueryScalar?: boolean;
  /**
   * Gets the list of measures that this measure depends on.
  */
  dependencies?: EntityDependency[];
}

/**
 * Represents the measure evaluation details for a particular measure. It includes various
 * properties pertaining to an
 * evaluation including the measure name, orchestrationId, start time, state, errors (if-any) etc.
 * This latest evaluation
 * is stored in the measure metadata, while historical copies are written to table storage.
*/
export interface Evaluation {
  lastSuccessfulRunId?: string;
  /**
   * Possible values include: 'none', 'running', 'failed', 'completed'
  */
  state?: string;
  /**
   * Evaluation completion time.
  */
  endTime?: Date;
  /**
   * Error Information (if any) that occured during the measure evaluation.
  */
  error?: string;
}

export interface ScalarOutput {
  /**
   * Output folder path for the evaluation.
  */
  values?: { [propertyName: string]: string };
  measureName?: string;
  /**
   * Gets the evaluation start time.
  */
  evaluationTime?: Date;
}

/**
 * Represents measure evaluation stats
*/
export interface EvaluationStats {
  /**
   * Last successful evaluation
  */
  lastSuccessful?: Date;
  /**
   * Represents Number of consecutive failures
  */
  consecutiveFailureCount?: number;
}

export interface StringInfo {
  value?: string;
  /**
   * Possible values include: 'activityMappingDuplicateMappingOnEntity',
   * 'activityMappingEmptyInput', 'activityMappingInvalidKeyAttribute',
   * 'activityMappingInvalidRelationshipAttribute', 'activityMappingInvalidStartEndTimeField',
   * 'activityMappingInvalidStartTimeFieldValue', 'apiInternalError', 'apiVersionNotSupported',
   * 'authEmptyAuthorizationCode', 'authEmptyAuthorizationCodeError', 'authEmptyBearerToken',
   * 'authEmptyBearerTokenError', 'authEmptyRedirect', 'authEmptyRedirectUrl',
   * 'authEmptyRefreshToken', 'authEmptyState', 'authInvalidApp', 'authInvalidAppType',
   * 'authInvalidToken', 'authUserHasC360LicenseError', 'configurationControllerMissingInput',
   * 'customer360ApiInvalidIdentity', 'customer360ApiInvalidTenantIdClaims',
   * 'customer360ApiInvalidUserIdClaims', 'dataRefreshInvalidScheduleRequest',
   * 'dataSourceCreateAlreadyExistError', 'dataSourceModelAlreadyExistError',
   * 'dataSourceDataSourceCanNotDelete', 'dataSourceDataSourceDeleted',
   * 'dataSourceDataSourceNotFound', 'dataSourceDuplicateDataSourceName',
   * 'dataSourceEmptyDataSource', 'dataSourceEmptyDataSourceName',
   * 'dataSourceEmptyDataSourceNameError', 'dataSourceEmptyAttributeError',
   * 'dataLakeAccountInvalidError', 'dataLakeSecretInvalidError', 'dataSourceModelNotFoundError',
   * 'modelDataTypeError', 'modelDataConvertError', 'resourceMetadataNotFoundError',
   * 'dataSourceInactiveInstance', 'dataSourceInstanceNotFound', 'dataSourceCreationFailed',
   * 'dataSourceInvalidDataSourceName', 'dataSourceInvalidDataSourceNameCharacter',
   * 'dataSourceInvalidEntityNames', 'dataSourceMetadataExceedsLimit', 'dataSourceNotFound',
   * 'dataSourceNotProvisioned', 'dataSourceRefreshTimeout', 'dataSourceUpdateAlreadyExistError',
   * 'dataSourceUpdateDependenciesError', 'datasourceIngestionUnexpectedError',
   * 'dynamics365EmptyHeader', 'entityDataControllerContentType',
   * 'entityMetadataCanNotMarkAttribute', 'entityMetadataCanNotUpdateEntity',
   * 'entityMetadataCanNotUpdateEntityOfActivityType',
   * 'entityMetadataForAttributeNotFoundForEntity', 'entityMetadataNotFoundForEntity',
   * 'failedToSubmiProfileStoreJob', 'gdprDeleteOldSnapshotsConfiguratonError',
   * 'gdprDeleteOldSnapshotsNonC360DataflowsError', 'graphApiEmptySearchTerm',
   * 'graphApiPrincipalIdMissingInRequest', 'graphApiPrincipalIdsExceedslimit',
   * 'graphApiPrincipalIdsExceedslimitError', 'graphApiTopLimitError',
   * 'graphApiGroupDirectoryInfoFailed', 'graphApiUserDirectoryInfoFailed',
   * 'instanceNoAssignmentsInRequest', 'instanceUserSettingsMissing',
   * 'instancePreferredLanguageMissing', 'instancePreferredRegionalFormatMissing',
   * 'invalidDataSourceType', 'invocationBadRequestInReadingHeaderInfo',
   * 'invocationFailedBindToMethod', 'invocationUnsupportedMediaType',
   * 'measuresProcessingOrchestrationSkipMeasuresAndNotify', 'nullOrEmptyInstanceId',
   * 'offlineGraphIngestionOrchestrationNotify', 'segmentEvaluationOrchestrationNotify',
   * 'profileStoreIngestionFailedWithJobInfo', 'profileStoreIngestionOrchestrationFailed',
   * 'profileStoreOrchestrationSuccessful', 'publicMetadataControllerAnonymousType',
   * 'rbacAADDirectoryObjectNotFound', 'rbacCanNotRevokePermissionFromInstance',
   * 'rbacDeletedRoleAssignmentsFromUser', 'rbacInvalidRole', 'rbacRoleIsNotValid',
   * 'rbacUnsupportedPrincipalType', 'rbacUserNotFound', 'refreshBackgroundTaskRunningError',
   * 'refreshConflationCancelled', 'refreshConflationMetadataNotFound',
   * 'refreshConflationJobFailed', 'refreshEnrichmentMetadataNotFound',
   * 'refreshEnrichmentMisconfigured', 'refreshEnrichmentRequestExceeded',
   * 'refreshEnrichmentRequestThrottling', 'refreshExportCancelled', 'refreshExportCompleted',
   * 'refreshExportFailed', 'refreshExportRequestThrottling', 'refreshExportSkipped',
   * 'refreshMatchRequestThrotling', 'refreshMeasuresEvaluationRequestThrottling',
   * 'refreshMergeRequestThrotling', 'refreshPrerequisitesUnmetError',
   * 'refreshRunningOrchestrationNotFound', 'resourceBuilderFailure',
   * 'segmentAdvancedEditorNotEnabled', 'staleMatchMetadataError', 'staleMatchRunError',
   * 'testName', 'measuresProcessingOrchestrationFailed',
   * 'measuresProcessingOrchestrationFailedV2', 'offlineGraphIngestionOrchestrationFailed',
   * 'segmentEvaluationOrchestrationFailed', 'matchMergeOrchestrationFailed',
   * 'refreshMatchPairsEntityDoesNotExist', 'invalidSegmentDefinitionErrorMessage',
   * 'clauseForNextRefresh', 'refreshIntelligenceCancelled', 'refreshIntelligenceCompleted',
   * 'refreshIntelligenceFailed', 'refreshIntelligenceSkipped', 'refreshIntelligenceDisabled',
   * 'refreshConflationConfigurationNotFound', 'conflationPlanInvalid',
   * 'conflationMetadataNotFoundForEntity', 'conflationMetadataNotFoundForColumn',
   * 'conflationConfigurationInvalid', 'conflationUnexpectedError', 'matchPairsEntityDataMissing',
   * 'matchPairsEntityNotExist', 'conflationResolutionInvalid',
   * 'intelligenceUnsupportedDiscoverySource', 'refreshDataPreparationCancelled',
   * 'refreshDataPreparationRequestThrottling', 'refreshDataPreparationFailed', 'bapNotMapped',
   * 'bapCannotCreateEnvironment', 'bapInvalidEnvironmentDisplayNameLength',
   * 'bapInvalidEnvironmentDisplayName', 'bapInvalidEnvironmentLocation',
   * 'bapInvalidEnvironmentSku', 'bapInvalidEnvironment', 'bapInvalidTenantEnvironmentLimit',
   * 'bapInvalidUserEnvironmentLimit', 'dataSourceIngestionCancelled',
   * 'dataSourceIngestionSkippedNoEntities', 'genericPredictionEntitiesNotAvailable',
   * 'genericPredictionEntityPartitionsNotAvailable',
   * 'genericPredictionEntityWithLabelAttributeNotAvailable',
   * 'genericPredictionAttributesNotAvailable', 'invalidJarvisEntityCreationErrorMessage',
   * 'activityIngestionActivityIdNotFound', 'activityIngestionActivityTimeNotFound',
   * 'activityIngestionIncorrectMinViewFields', 'activityIngestionNoJarvisColumnMapping',
   * 'activityIngestionNoPrimaryKey', 'activityIngestionNoSourceStream',
   * 'activityIngestionNoSourceStreamWithCorrectActivityName', 'activityIngestionNoStartOrEndTime',
   * 'activityIngestionRangeIndexNotFound', 'activityIngestionUniqueSourceStream',
   * 'entityNoPrimaryKey', 'invalidSegmentAdvancedSegCreateInInvalidState', 'invalidSegmentFormat',
   * 'invalidSegmentNameExists', 'inavlidSegmentType', 'inavlidSegmentValidationDisabled',
   * 'invalidSegmentNameConflict', 'invalidSegmentNoExistingSegWithName',
   * 'invalidSegmentSegNotFound', 'invalidSegmentValidationNotAllowedForState',
   * 'invalidSegmentValidationNotAllowedForType', 'segmentNotFound',
   * 'dataSourceEmptyResourceIdError', 'invalidOrganizationUrl', 'enablingCdsEntitiesFailed',
   * 'dataSourceIngestionSkippedForMissingCdsModelJsonPath',
   * 'dataSourceIngestionSkippedForCdsModelIncomplete', 'missingOrganizationUrl',
   * 'searchStoreUnavailable', 'profileStoreUnavailable', 'unsupportedInsightType',
   * 'invalidInsightInputGeneric', 'invalidMalformedInsightInputPayload',
   * 'invalidInsightInputMissingName'
  */
  key?: string;
  args?: string[];
}

/**
 * Represents measure sql validation stats
*/
export interface SqlValidationStats {
  /**
   * Date of Validation evaluation
  */
  validationDate?: Date;
  /**
   * Gets the number of consecutive failures
  */
  error?: string;
}

/**
 * Represents metadata for a measure (or KPI).
*/
export interface MeasureMetadata {
  displayName?: string;
  /**
   * Unique name of the measure
  */
  name?: string;
  /**
   * Description of the measure.
  */
  description?: string;
  definition?: MeasureDefinition;
  latestEvaluation?: Evaluation;
  output?: ScalarOutput;
  evaluationStats?: EvaluationStats;
  errorDescription?: StringInfo;
  sqlValidationStats?: SqlValidationStats;
  /**
   * Evaluation history for the measure. (not persisted in store)
  */
  evaluationHistory?: Evaluation[];
  /**
   * Output history for the measure. (not persisted in store)
  */
  outputHistory?: ScalarOutput[];
  /**
   * Check if measure metadata is a template
  */
  isTemplate?: boolean;
  /**
   * Gets the template ID for templates
  */
  templateId?: string;
  /**
   * Check if measure metadata is created from a template
  */
  isCreatedFromTemplate?: boolean;
  /**
   * Version number of this object.
  */
  version?: number;
  /**
   * UPN of the user who last updated this record.
  */
  updatedBy?: string;
  /**
   * Time this object was last updated.
  */
  updatedUtc?: Date;
  /**
   * Email address of the user who created this record.
  */
  createdBy?: string;
  /**
   * Time this object was initially created.
  */
  createdUtc?: Date;
  /**
   * Customer Insights instance id associated with this object.
  */
  instanceId?: string;
}

export interface SourceLocation {
  line?: number;
  column?: number;
}

export interface LogMessage {
  location?: SourceLocation;
  message?: string;
}

export interface ParsingError {
  messages?: LogMessage[];
  /**
   * Possible values include: 'unknown', 'parsingFailed', 'entityNotFound', 'attributeNotFound',
   * 'unsupportedSyntax', 'invalidOperation', 'incorrectArgumentCount', 'incorrectIntervalType',
   * 'invalidArgument'
  */
  code?: string;
}

export interface KeyRingResponse {
  instanceId?: string;
  customerId?: string;
  keyRing?: any;
}

export interface ProfileStoreModuleRunInfo {
  /**
   * LastSuccessfulRunId Info for every fullyQualifiedEntity.
  */
  runInfo?: { [propertyName: string]: string };
}

export interface ProfileStoreCollectionInfo {
  /**
   * Possible values include: 'empty', 'inBuild', 'queryable'
  */
  currentState?: string;
  /**
   * Gets the row count of customer file yielded from merge output.
  */
  rowCount?: number;
  /**
   * Gets the size of customer file yielded from merge .
  */
  size?: number;
  /**
   * Gets the state of profile store hydration per job type.
  */
  profileStoreHydrationStateInfo?: { [propertyName: string]: string };
}

/**
 * Represents runtime profile store state
*/
export interface ProfileStoreStateInfo {
  /**
   * Gets the latest date of ingestion.
  */
  ingestionTime?: Date;
  primaryInfo?: ProfileStoreCollectionInfo;
  secondaryInfo?: ProfileStoreCollectionInfo;
  /**
   * Customer Insights instance id associated with this object.
  */
  instanceId?: string;
}

export interface RoleDefinition {
  description?: string;
  roleName?: string;
}

/**
 * Represents a role assignment Metadata.
*/
export interface RoleAssignment {
  /**
   * Gets the Id of the principal.
  */
  principalId?: string;
  /**
   * Possible values include: 'user', 'group', 'app'
  */
  principalType?: string;
  /**
   * Gets the roles the principal belongs to.
  */
  roles?: string[];
  /**
   * Customer Insights instance id associated with this object.
  */
  instanceId?: string;
}

/**
 * Represents a Relationship
*/
export interface RelationshipMetadata {
  /**
   * Gets the friendly name of the relationship.
  */
  friendlyName?: string;
  /**
   * Gets the unique name for relationship
  */
  name?: string;
  /**
   * Gets the description for relationship
  */
  description?: string;
  /**
   * Possible values include: 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
   * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
  */
  relationshipType?: string;
  /**
   * Gets the name of the foreign key reference attribute that this relationship originates from.
  */
  fromAttributeName?: string;
  /**
   * Gets the name of the entity this relationship originates from.
  */
  fromEntityName?: string;
  /**
   * Gets the name of the foreign key attribute that this relationship points to.
  */
  toAttributeName?: string;
  /**
   * Gets the name of the entity this relationship points to.
  */
  toEntityName?: string;
  /**
   * Possible values include: 'oneToMany', 'oneToOne', 'manyToOne'
  */
  cardinality?: string;
  /**
   * Possible values include: 'user', 'system', 'inferred'
  */
  source?: string;
  /**
   * Version number of this object.
  */
  version?: number;
  /**
   * UPN of the user who last updated this record.
  */
  updatedBy?: string;
  /**
   * Time this object was last updated.
  */
  updatedUtc?: Date;
  /**
   * Email address of the user who created this record.
  */
  createdBy?: string;
  /**
   * Time this object was initially created.
  */
  createdUtc?: Date;
  /**
   * Customer Insights instance id associated with this object.
  */
  instanceId?: string;
}

/**
 * Represents search configuration for an attribute
*/
export interface AttributeSearchProperties {
  /**
   * Gets a value indicating whether the attribute supports full text search.
  */
  isSearchable?: boolean;
  /**
   * Gets a value indicating whether the attribute supports filtering.
  */
  isFilterable?: boolean;
  /**
   * Gets a value indicating whether the attribute can be included as facet results.
  */
  isFacetable?: boolean;
  /**
   * Gets an optional specification for search faceting used at query time (advanced).
  */
  facetSpecification?: string;
  /**
   * Gets a value indicating whether the attribute supports ordering.
  */
  isSortable?: boolean;
}

export interface AttributeSearchConfiguration {
  /**
   * Gets the attribute name.
  */
  name?: string;
  properties?: AttributeSearchProperties;
}

export interface EntitySearchConfiguration {
  /**
   * Gets unique entity name for this entity
  */
  qualifiedEntityName?: string;
  /**
   * Gets the attribute search config
  */
  attributes?: AttributeSearchConfiguration[];
}

/**
 * Represents search configuration of an instance
*/
export interface InstanceSearchConfiguration {
  /**
   * Gets search configurations for entities
  */
  entityConfig?: EntitySearchConfiguration[];
  /**
   * Gets a value indicating whether the configuration was system generated
  */
  isSystemGenerated?: boolean;
  /**
   * Version number of this object.
  */
  version?: number;
  /**
   * UPN of the user who last updated this record.
  */
  updatedBy?: string;
  /**
   * Time this object was last updated.
  */
  updatedUtc?: Date;
  /**
   * Email address of the user who created this record.
  */
  createdBy?: string;
  /**
   * Time this object was initially created.
  */
  createdUtc?: Date;
  /**
   * Customer Insights instance id associated with this object.
  */
  instanceId?: string;
}

/**
 * Represent a Segment Projection.
*/
export interface SegmentationProjection {
  /**
   * Gets the Entity Name of the projection.
  */
  entityName?: string;
  /**
   * Gets the Attribute Names being projected.
  */
  attributeNames?: string[];
  /**
   * Gets the relationship path to use for segment projection.
  */
  path?: string[];
  /**
   * Possible values include: 'pre', 'post'
  */
  projectionType?: string;
}

/**
 * Represent a Row set.
*/
export interface SegmentationRowset {
  /**
   * Possible values include: 'union', 'intersect', 'except', 'none', 'include', 'exclude'
  */
  rowsetOperation?: string;
  criteria?: SegmentMembershipCriteria;
  /**
   * Gets the relationship path to use for segment criteria.
  */
  paths?: string[][];
  /**
   * Gets the rowset Id in the rowsets.
  */
  rowsetId?: string;
}

/**
 * Represents a Hierarchy entity used to define a B2B segment/measure.
*/
export interface HierarchyDefinition {
  /**
   * Gets the Hierarchy entity fully qualified name.
  */
  hierarchyEntityName?: string;
  /**
   * Gets the Hierarchy entity Source attribute name.
  */
  sourceAttributeName?: string;
  /**
   * Gets the Hierarchy entity Destination attribute name.
  */
  destinationAttributeName?: string;
}

/**
 * Represent a Segment Query.
*/
export interface SegmentationQuery {
  /**
   * Possible values include: 'structured', 'manual'
  */
  type?: string;
  /**
   * Gets list of attributes to be projected in segment. (DEPRECATED)
  */
  projections?: string[];
  /**
   * Gets list of attributes to be projected in segment.
  */
  projectedAttributes?: SegmentationProjection[];
  /**
   * Gets list of rowsets of segment.
  */
  rowsets?: SegmentationRowset[];
  /**
   * Gets the user specified custom SQL query.
  */
  segmentationQuerySql?: string;
  /**
   * Gets a list of Hierarchies for segment query.
  */
  hierarchies?: HierarchyDefinition[];
}

export interface SegmentationPublishStats {
  /**
   * Possible values include: 'None', 'Queued', 'Running', 'CompletedSuccess', 'CompletedFailure',
   * 'Cancelled', 'Interrupted', 'NotQualified'
  */
  jobStatus?: string;
  evaluationDate?: Date;
  entityCount?: number;
  error?: StringInfo;
  lastSuccessfulRunId?: string;
}

/**
 * Represents historical Segment statistics.
*/
export interface HistoricalSegmentStats {
  /**
   * Gets the segment ran date.
  */
  evaluationDate?: Date;
  /**
   * Gets the count of entity.
  */
  entityCount?: number;
  /**
   * Gets the segment evaluation job status.
  */
  jobStatus?: string;
  error?: StringInfo;
}

/**
 * Represents a SegmentRowset Stat.
*/
export interface SegmentRowsetStat {
  /**
   * Gets a Rowset Id for the Rowset Stat.
  */
  rowsetId?: string;
  /**
   * Gets a Rowset Count for the Rowset Id.
  */
  rowsetCount?: number;
}

/**
 * Represents a Segment Stat.
*/
export interface SegmentQueryStat {
  /**
   * Gets a list of Rowset Stat.
  */
  rowsetStat?: SegmentRowsetStat[];
}

/**
 * Represents a base Segment Metadata.
*/
export interface SegmentMetadata {
  /**
   * Possible values include: 'default', 'engagement'
  */
  kind?: string;
  /**
   * Gets the unique name of the segment
  */
  name?: string;
  /**
   * Gets the friendlyName of the segment.
  */
  friendlyName?: string;
  /**
   * Gets the description of the segment.
  */
  description?: string;
  segmentQueryExpression?: SegmentationQuery;
  /**
   * Possible values include: 'inactive', 'active', 'validating', 'validated', 'invalid',
   * 'validationError'
  */
  state?: string;
  /**
   * Gets the error description when the segment metadata has some issues after refresh.
  */
  errorDescription?: string;
  /**
   * Gets the end date of the segment.
  */
  endDate?: Date;
  evaluationStatus?: SegmentationPublishStats;
  sqlValidationStats?: SqlValidationStats;
  /**
   * Gets the segment evaluation status history. (not persisted in store)
  */
  evaluationStatusHistory?: HistoricalSegmentStats[];
  segmentQueryStats?: SegmentQueryStat;
  /**
   * Version number of this object.
  */
  version?: number;
  /**
   * UPN of the user who last updated this record.
  */
  updatedBy?: string;
  /**
   * Time this object was last updated.
  */
  updatedUtc?: Date;
  /**
   * Email address of the user who created this record.
  */
  createdBy?: string;
  /**
   * Time this object was initially created.
  */
  createdUtc?: Date;
  /**
   * Customer Insights instance id associated with this object.
  */
  instanceId?: string;
}

/**
 * Represents custom information about a task.
*/
export interface CustomTaskInformation {
  /**
   * Possible values include: 'test', 'segmentation', 'measures', 'export', 'incrementalIngestion',
   * 'incrementalMatch', 'incrementalMatchWithPreview', 'merge', 'mark', 'affinities'
  */
  kind?: string;
}

export interface SelectionReason {
  /**
   * Possible values include: 'unknown', 'requested', 'firstRun', 'unsuccessful', 'lastRunSkipped',
   * 'alreadyRunning', 'modifiedInputs', 'upstreamRerunning', 'dependantSystemNode',
   * 'dependsOnMerge'
  */
  code?: string;
  details?: string;
}

export interface GraphTaskInfo {
  taskId?: string;
  /**
   * Possible values include: 'queued', 'needsUpdate', 'running', 'failed', 'timedOut', 'aborted',
   * 'deleted', 'successful', 'skipped'
  */
  taskStatus?: string;
  /**
   * Possible values include: 'none', 'ingestion', 'derivedEntity', 'hierarchy', 'dataPreparation',
   * 'map', 'realtimeM3Search', 'match', 'merge', 'profileStore', 'search', 'activity', 'contact',
   * 'attributeMeasures', 'entityMeasures', 'measures', 'segmentation', 'segmentMembership',
   * 'enrichment', 'preEnrichment', 'transform', 'intelligence', 'aiBuilder', 'insights', 'export',
   * 'modelManagement', 'relationship', 'roleAssignment', 'analysis', 'semanticEntity', 'all'
  */
  operationType?: string;
  /**
   * Possible values include: 'noSubType', 'templatedMeasures', 'createAnalysisModel',
   * 'linkAnalysisModel', 'singleActivityMapping', 'powerPlatform'
  */
  subType?: string;
  jobIds?: string[];
  friendlyName?: string;
  endTimestamp?: Date;
  ciError?: CIResult;
  ciErrors?: CIResult[];
  waitingTaskIds?: string[];
  additionalInfo?: CustomTaskInformation;
  submittedTimestamp?: Date;
}

export interface GraphJobOptions {
  runDownstreamAfterMerge?: boolean;
  /**
   * Describes unknown properties. The value of an unknown property can be of "any" type.
  */
  [additionalPropertyName: string]: any;
}

export interface GraphJobInfo {
  jobId?: string;
  /**
   * Possible values include: 'full', 'incremental'
  */
  jobType?: string;
  /**
   * Possible values include: 'onDemand', 'scheduled'
  */
  jobSubmissionKind?: string;
  /**
   * Possible values include: 'queued', 'needsUpdate', 'running', 'failed', 'timedOut', 'aborted',
   * 'deleted', 'successful', 'skipped'
  */
  jobStatus?: string;
  /**
   * Possible values include: 'none', 'ingestion', 'derivedEntity', 'hierarchy', 'dataPreparation',
   * 'map', 'realtimeM3Search', 'match', 'merge', 'profileStore', 'search', 'activity', 'contact',
   * 'attributeMeasures', 'entityMeasures', 'measures', 'segmentation', 'segmentMembership',
   * 'enrichment', 'preEnrichment', 'transform', 'intelligence', 'aiBuilder', 'insights', 'export',
   * 'modelManagement', 'relationship', 'roleAssignment', 'analysis', 'semanticEntity', 'all'
  */
  operationType?: string;
  /**
   * Possible values include: 'noSubType', 'templatedMeasures', 'createAnalysisModel',
   * 'linkAnalysisModel', 'singleActivityMapping', 'powerPlatform'
  */
  subType?: string;
  endTimestamp?: Date;
  shouldForceRunRequestedNodes?: boolean;
  tasks?: GraphTaskInfo[];
  idList?: string[];
  options?: GraphJobOptions;
  submittedTimestamp?: Date;
}

export interface OnDemandJobRequest {
  graphName?: string;
  /**
   * Possible values include: 'none', 'ingestion', 'derivedEntity', 'hierarchy', 'dataPreparation',
   * 'map', 'realtimeM3Search', 'match', 'merge', 'profileStore', 'search', 'activity', 'contact',
   * 'attributeMeasures', 'entityMeasures', 'measures', 'segmentation', 'segmentMembership',
   * 'enrichment', 'preEnrichment', 'transform', 'intelligence', 'aiBuilder', 'insights', 'export',
   * 'modelManagement', 'relationship', 'roleAssignment', 'analysis', 'semanticEntity', 'all'
  */
  operationType?: string;
  /**
   * Possible values include: 'onDemand', 'scheduled'
  */
  submissionKind?: string;
  /**
   * Possible values include: 'full', 'incremental'
  */
  jobType?: string;
  identifiers?: string[];
  forceRunRequested?: boolean;
  /**
   * Possible values include: 'FailedOrModifiedRecursive', 'FailedRecursive', 'FailedOrModified',
   * 'Failed', 'None'
  */
  inputRefreshMode?: string;
  options?: GraphJobOptions;
}

export interface DataInfo {
  /**
   * Possible values include: 'resource', 'entity', 'custom'
  */
  kind?: string;
  /**
   * Possible values include: 'none', 'new', 'update'
  */
  changeType?: string;
  /**
   * Gets the name of the data info.
  */
  name?: string;
}

export interface GraphNodeInfo {
  /**
   * Possible values include: 'none', 'ingestion', 'derivedEntity', 'hierarchy', 'dataPreparation',
   * 'map', 'realtimeM3Search', 'match', 'merge', 'profileStore', 'search', 'activity', 'contact',
   * 'attributeMeasures', 'entityMeasures', 'measures', 'segmentation', 'segmentMembership',
   * 'enrichment', 'preEnrichment', 'transform', 'intelligence', 'aiBuilder', 'insights', 'export',
   * 'modelManagement', 'relationship', 'roleAssignment', 'analysis', 'semanticEntity', 'all'
  */
  operationType?: string;
  /**
   * Possible values include: 'noSubType', 'templatedMeasures', 'createAnalysisModel',
   * 'linkAnalysisModel', 'singleActivityMapping', 'powerPlatform'
  */
  subType?: string;
  identifier?: string;
  friendlyName?: string;
  jobIds?: string[];
  /**
   * Possible values include: 'queued', 'needsUpdate', 'running', 'failed', 'timedOut', 'aborted',
   * 'deleted', 'successful', 'skipped'
  */
  taskStatus?: string;
  lastSuccessJobIds?: string[];
  endTimestamp?: Date;
  lastSuccessfulTimestamp?: Date;
  ciError?: CIResult;
  ciErrors?: CIResult[];
  additionalInfo?: CustomTaskInformation;
  selectionReason?: SelectionReason;
}

export interface TimezoneDetail {
  id?: string;
  name?: string;
}

/**
 * Represents a dismissed notification.
*/
export interface DismissedNotification {
  /**
   * Gets the unique id of the notification
  */
  notificationId?: string;
  /**
   * Gets the expiration UTC date time of this notification.
  */
  notificationExpiryTimeUtc?: Date;
}

/**
 * Represents a user notifications settings
*/
export interface UserNotificationsSettings {
  /**
   * Gets the list of dismissed banner notifications for this user.
  */
  dismissedBannerNotifications?: DismissedNotification[];
}

/**
 * Defaults or user selected values to store across sessions
*/
export interface History {
  /**
   * Gets history id.
  */
  id?: string;
  /**
   * Checks for already visited.
  */
  viewed?: boolean;
}

/**
 * Settings to track coachmarks that users have viewed
*/
export interface Coachmarks {
  history?: History;
}

/**
 * Settings to track banners that users have viewed and dismissed
*/
export interface Banners {
  history?: History;
}

/**
 * Settings to track notifications that users have viewed and dismissed
*/
export interface Notifications {
  history?: History;
}

/**
 * Represents a mapping  that can store all user ids associated with the email
*/
export interface PortalSettings {
  coachmarks?: Coachmarks;
  banners?: Banners;
  notifications?: Notifications;
  /**
   * Gets a value indicating whether the user has seen the all apps (welcome) page.
  */
  isExistingUser?: boolean;
  /**
   * Gets a value indicating whether the user has seen the all apps (welcome) page.
  */
  showDefaultHomePage?: boolean;
  /**
   * Gets a value indicating whether the user has seen the all apps (welcome) page.
  */
  proTagger?: boolean;
}

/**
 * Represents a Terms of Use for user
*/
export interface TermsOfUse {
  /**
   * Possible values include: 'none', 'accepted', 'declined'
  */
  state?: string;
  /**
   * Gets the current version of this document.
  */
  version?: string;
  /**
   * Gets the created time of terms acceptance.
  */
  createdUtc?: Date;
}

/**
 * Represents a User
*/
export interface UserInfo {
  /**
   * Gets the unique ID for this user.
  */
  userId?: string;
  /**
   * Gets user identifier.
  */
  upn?: string;
  /**
   * Gets list of Instances Id.
  */
  instancesIds?: InstanceInfo[];
  /**
   * Gets user preferred language.
  */
  preferredLanguage?: string;
  /**
   * Gets user preferred regional format.
  */
  preferredRegionalFormat?: string;
  /**
   * Gets user default instance id.
  */
  defaultInstance?: string;
  userNotificationsSettings?: UserNotificationsSettings;
  /**
   * Gets the industry demo selected by user during trial
  */
  industryDemo?: string;
  /**
   * Gets the tenant id of the user.
  */
  tenantId?: string;
  /**
   * Gets a value indicating whether the user has seen the all apps (welcome) page.
  */
  hasSeenWelcome?: boolean;
  /**
   * Gets the created time of User settings created for EI Migration.
  */
  createdUtc?: Date;
  /**
   * Gets a value indicating whether the user Opt-In to be contacted through emails. This is for
   * CPM integration from EI.
  */
  allowEmailContacts?: boolean;
  portalSettings?: PortalSettings;
  termsOfUse?: TermsOfUse;
  /**
   * Gets the region that the user belongs to.
  */
  region?: string;
  /**
   * Possible values include: 'audienceInsights', 'engagementInsights', 'audienceInsightsB2B'
  */
  lastUsedExperience?: string;
  /**
   * Customer Insights instance id associated with this object.
  */
  instanceId?: string;
}
