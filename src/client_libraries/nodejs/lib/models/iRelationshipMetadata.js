/*
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

/**
 * Represents Relationship Metadata
 *
 */
class IRelationshipMetadata {
  /**
   * Create a IRelationshipMetadata.
   * @property {string} [name] Unique Name for relationship
   * @property {string} [friendlyName] User Friendly Name for relationship
   * @property {object} [fromAttribute]
   * @property {string} [fromAttribute.name] Unique Name for Attribute Metadata
   * @property {string} [fromAttribute.friendlyName] User friendly Name for
   * Attribute Metadata
   * @property {string} [fromAttribute.baseName] Base Name for Attribute
   * Metadata
   * @property {string} [fromAttribute.dataType] Gets data type for property.
   * @property {string} [fromAttribute.semanticType] Gets semantic type for
   * property. Possible values include: 'CalendarDate', 'CalendarDayOfMonth',
   * 'CalendarDayOfWeek', 'CalendarDayOfYear', 'CalendarHalfYear',
   * 'CalendarMonthOfYear', 'CalendarMonth', 'CalendarWeek', 'CalendarYear',
   * 'CalendarFiscalDate', 'CalendarFiscalDayOfMonth',
   * 'CalendarFiscalDayOfWeek', 'CalendarFiscalDayOfYear',
   * 'CalendarFiscalHalfYear', 'CalendarFiscalMonthOfYear',
   * 'CalendarFiscalMonth', 'CalendarFiscalQuarter',
   * 'CalendarFiscalWeekOfMonth', 'CalendarFiscalWeekOfYear',
   * 'CalendarFiscalWeek', 'CalendarFiscalYear', 'Account', 'Channel',
   * 'Contact', 'Customer', 'Language', 'Organization', 'OrganizationUnit',
   * 'Person', 'Product', 'ProductGroup', 'LocationAddress',
   * 'LocationAddressStreet', 'LocationCity', 'LocationContinent',
   * 'LocationCountry', 'LocationCounty', 'LocationLatitude',
   * 'LocationLongitude', 'LocationPoint', 'LocationPostalCode',
   * 'LocationProvince', 'LocationRegion', 'LocationState', 'LocationTimezone',
   * 'MeasurementDateCreation', 'MeasurementDateModify', 'MeasurementStatus',
   * 'MeasurementVersion', 'BarCode', 'Brand', 'IdentityGovernmentID',
   * 'PersonFirstName', 'PersonFullName', 'PersonLastName', 'PersonMiddleName',
   * 'IdentityServiceEmail', 'IdentityServiceFacebook', 'IdentityServicePhone',
   * 'IdentityServiceTwitter', 'Image', 'Place', 'ReferenceDescription',
   * 'ReferenceImageURL', 'ReferencePhonetic', 'ReferenceURL'
   * @property {object} [fromAttribute.searchProperties]
   * @property {boolean} [fromAttribute.searchProperties.isSearchable] Gets a
   * value indicating whether the attribute supports full text search.
   * @property {boolean} [fromAttribute.searchProperties.isFilterable] Gets a
   * value indicating whether the attribute supports filtering.
   * @property {boolean} [fromAttribute.searchProperties.isFacetable] Gets a
   * value indicating whether the attribute can be included as facet results.
   * @property {boolean} [fromAttribute.searchProperties.isSortable] Gets a
   * value indicating whether the attribute can be included in orderby
   * directives.
   * @property {string} [fromAttribute.searchProperties.facetSpecification]
   * Gets an optional specification for search faceting used at query time
   * (advanced).
   * this is the part behind the comma in the examples below.
   * bucket facet: "price,interval:10"
   * other type: "listPrice,values:10|25|100|500|1000|2500"
   * value facet: city,count:5
   * @property {object} [toAttribute]
   * @property {string} [toAttribute.name] Unique Name for Attribute Metadata
   * @property {string} [toAttribute.friendlyName] User friendly Name for
   * Attribute Metadata
   * @property {string} [toAttribute.baseName] Base Name for Attribute Metadata
   * @property {string} [toAttribute.dataType] Gets data type for property.
   * @property {string} [toAttribute.semanticType] Gets semantic type for
   * property. Possible values include: 'CalendarDate', 'CalendarDayOfMonth',
   * 'CalendarDayOfWeek', 'CalendarDayOfYear', 'CalendarHalfYear',
   * 'CalendarMonthOfYear', 'CalendarMonth', 'CalendarWeek', 'CalendarYear',
   * 'CalendarFiscalDate', 'CalendarFiscalDayOfMonth',
   * 'CalendarFiscalDayOfWeek', 'CalendarFiscalDayOfYear',
   * 'CalendarFiscalHalfYear', 'CalendarFiscalMonthOfYear',
   * 'CalendarFiscalMonth', 'CalendarFiscalQuarter',
   * 'CalendarFiscalWeekOfMonth', 'CalendarFiscalWeekOfYear',
   * 'CalendarFiscalWeek', 'CalendarFiscalYear', 'Account', 'Channel',
   * 'Contact', 'Customer', 'Language', 'Organization', 'OrganizationUnit',
   * 'Person', 'Product', 'ProductGroup', 'LocationAddress',
   * 'LocationAddressStreet', 'LocationCity', 'LocationContinent',
   * 'LocationCountry', 'LocationCounty', 'LocationLatitude',
   * 'LocationLongitude', 'LocationPoint', 'LocationPostalCode',
   * 'LocationProvince', 'LocationRegion', 'LocationState', 'LocationTimezone',
   * 'MeasurementDateCreation', 'MeasurementDateModify', 'MeasurementStatus',
   * 'MeasurementVersion', 'BarCode', 'Brand', 'IdentityGovernmentID',
   * 'PersonFirstName', 'PersonFullName', 'PersonLastName', 'PersonMiddleName',
   * 'IdentityServiceEmail', 'IdentityServiceFacebook', 'IdentityServicePhone',
   * 'IdentityServiceTwitter', 'Image', 'Place', 'ReferenceDescription',
   * 'ReferenceImageURL', 'ReferencePhonetic', 'ReferenceURL'
   * @property {object} [toAttribute.searchProperties]
   * @property {boolean} [toAttribute.searchProperties.isSearchable] Gets a
   * value indicating whether the attribute supports full text search.
   * @property {boolean} [toAttribute.searchProperties.isFilterable] Gets a
   * value indicating whether the attribute supports filtering.
   * @property {boolean} [toAttribute.searchProperties.isFacetable] Gets a
   * value indicating whether the attribute can be included as facet results.
   * @property {boolean} [toAttribute.searchProperties.isSortable] Gets a value
   * indicating whether the attribute can be included in orderby directives.
   * @property {string} [toAttribute.searchProperties.facetSpecification] Gets
   * an optional specification for search faceting used at query time
   * (advanced).
   * this is the part behind the comma in the examples below.
   * bucket facet: "price,interval:10"
   * other type: "listPrice,values:10|25|100|500|1000|2500"
   * value facet: city,count:5
   * @property {string} [relationshipType] Possible values include:
   * 'singleKeyRelationshipOrigin', 'singleKeyRelationshipDestination',
   * 'dataSourceLineageOrigin', 'dataSourceLineageDestination'
   * @property {object} [dataSourceEntity]
   * @property {string} [dataSourceEntity.name] Gets the name of the entity.
   * eg: Contact.
   * @property {string} [dataSourceEntity.qualifiedEntityName] Gets the unqiue
   * logical name for the entity
   * If entity is from a datasource, QualifiedEntityName =
   * datasourceId_EntityName eg: d8d3b26a-a8ad-42f7-901e-f7f745003a84_Contact.
   * If entity is generated by C360, QualifiedEntityName = EntityName eg:
   * Contact.
   * @property {string} [dataSourceEntity.dataSourceName] Gets the datasource
   * name of this entity, if no data source, return null or emptyString
   * @property {string} [dataSourceEntity.dataflowType] Possible values
   * include: 'dynamics365', 'salesforce', 'conflationSortAndRefine',
   * 'conflationDeduplication', 'conflationMatchPairs',
   * 'conflationResolveConflicts', 'enriched', 'kpi', 'powerQuery',
   * 'dataPreparation', 'intelligence', 'unifiedActivity', 'segmentation',
   * 'ingestion', 'attachCdm', 'genericPrediction', 'attachCds', 'unknown',
   * 'powerPlatform', 'datahub', 'insights', 'derivedEntity',
   * 'powerPlatformSource', 'powerPlatformBYDL', 'powerPlatformBYDLSource',
   * 'semanticActivity', 'segmentMembership', 'cjoData', 'eiData', 'hierarchy'
   * @property {boolean} [dataSourceEntity.shouldUseSparkSasAuth] Gets a value
   * indicating whether Sas Auth is used for the entity.
   * @property {uuid} [dataSourceEntity.datasourceId] Gets the original
   * datasourceid of this entity, if no data source, return null or emptyString
   * @property {string} [dataSourceEntity.entityType] Possible values include:
   * 'unspecified', 'profile', 'conflationMap', 'activity', 'aggregateKpi',
   * 'profileKpi', 'unifiedActivity', 'segment', 'intelligence',
   * 'genericPrediction', 'enrichment', 'insights', 'derivedEntity', 'corrupt',
   * 'selfConflation', 'conflationManualReview', 'selfConflationManualReview',
   * 'semanticActivity', 'segmentMembership'
   * @property {array} [dataSourceEntity.attributes] Gets entity attributes.
   * @property {array} [dataSourceEntity.keys] Gets the keys of the entity.
   * @property {array} [dataSourceEntity.relationships] Gets entity
   * relationships.
   * @property {object} [dataSourceEntity.timestampAttribute]
   * @property {string} [dataSourceEntity.timestampAttribute.name] Unique Name
   * for Attribute Metadata
   * @property {string} [dataSourceEntity.timestampAttribute.friendlyName] User
   * friendly Name for Attribute Metadata
   * @property {string} [dataSourceEntity.timestampAttribute.baseName] Base
   * Name for Attribute Metadata
   * @property {string} [dataSourceEntity.timestampAttribute.dataType] Gets
   * data type for property.
   * @property {string} [dataSourceEntity.timestampAttribute.semanticType] Gets
   * semantic type for property. Possible values include: 'CalendarDate',
   * 'CalendarDayOfMonth', 'CalendarDayOfWeek', 'CalendarDayOfYear',
   * 'CalendarHalfYear', 'CalendarMonthOfYear', 'CalendarMonth',
   * 'CalendarWeek', 'CalendarYear', 'CalendarFiscalDate',
   * 'CalendarFiscalDayOfMonth', 'CalendarFiscalDayOfWeek',
   * 'CalendarFiscalDayOfYear', 'CalendarFiscalHalfYear',
   * 'CalendarFiscalMonthOfYear', 'CalendarFiscalMonth',
   * 'CalendarFiscalQuarter', 'CalendarFiscalWeekOfMonth',
   * 'CalendarFiscalWeekOfYear', 'CalendarFiscalWeek', 'CalendarFiscalYear',
   * 'Account', 'Channel', 'Contact', 'Customer', 'Language', 'Organization',
   * 'OrganizationUnit', 'Person', 'Product', 'ProductGroup',
   * 'LocationAddress', 'LocationAddressStreet', 'LocationCity',
   * 'LocationContinent', 'LocationCountry', 'LocationCounty',
   * 'LocationLatitude', 'LocationLongitude', 'LocationPoint',
   * 'LocationPostalCode', 'LocationProvince', 'LocationRegion',
   * 'LocationState', 'LocationTimezone', 'MeasurementDateCreation',
   * 'MeasurementDateModify', 'MeasurementStatus', 'MeasurementVersion',
   * 'BarCode', 'Brand', 'IdentityGovernmentID', 'PersonFirstName',
   * 'PersonFullName', 'PersonLastName', 'PersonMiddleName',
   * 'IdentityServiceEmail', 'IdentityServiceFacebook', 'IdentityServicePhone',
   * 'IdentityServiceTwitter', 'Image', 'Place', 'ReferenceDescription',
   * 'ReferenceImageURL', 'ReferencePhonetic', 'ReferenceURL'
   * @property {object} [dataSourceEntity.timestampAttribute.searchProperties]
   * @property {boolean}
   * [dataSourceEntity.timestampAttribute.searchProperties.isSearchable] Gets a
   * value indicating whether the attribute supports full text search.
   * @property {boolean}
   * [dataSourceEntity.timestampAttribute.searchProperties.isFilterable] Gets a
   * value indicating whether the attribute supports filtering.
   * @property {boolean}
   * [dataSourceEntity.timestampAttribute.searchProperties.isFacetable] Gets a
   * value indicating whether the attribute can be included as facet results.
   * @property {boolean}
   * [dataSourceEntity.timestampAttribute.searchProperties.isSortable] Gets a
   * value indicating whether the attribute can be included in orderby
   * directives.
   * @property {string}
   * [dataSourceEntity.timestampAttribute.searchProperties.facetSpecification]
   * Gets an optional specification for search faceting used at query time
   * (advanced).
   * this is the part behind the comma in the examples below.
   * bucket facet: "price,interval:10"
   * other type: "listPrice,values:10|25|100|500|1000|2500"
   * value facet: city,count:5
   * @property {object} [dataSourceEntity.incrementalAttribute]
   * @property {string} [dataSourceEntity.incrementalAttribute.name] Unique
   * Name for Attribute Metadata
   * @property {string} [dataSourceEntity.incrementalAttribute.friendlyName]
   * User friendly Name for Attribute Metadata
   * @property {string} [dataSourceEntity.incrementalAttribute.baseName] Base
   * Name for Attribute Metadata
   * @property {string} [dataSourceEntity.incrementalAttribute.dataType] Gets
   * data type for property.
   * @property {string} [dataSourceEntity.incrementalAttribute.semanticType]
   * Gets semantic type for property. Possible values include: 'CalendarDate',
   * 'CalendarDayOfMonth', 'CalendarDayOfWeek', 'CalendarDayOfYear',
   * 'CalendarHalfYear', 'CalendarMonthOfYear', 'CalendarMonth',
   * 'CalendarWeek', 'CalendarYear', 'CalendarFiscalDate',
   * 'CalendarFiscalDayOfMonth', 'CalendarFiscalDayOfWeek',
   * 'CalendarFiscalDayOfYear', 'CalendarFiscalHalfYear',
   * 'CalendarFiscalMonthOfYear', 'CalendarFiscalMonth',
   * 'CalendarFiscalQuarter', 'CalendarFiscalWeekOfMonth',
   * 'CalendarFiscalWeekOfYear', 'CalendarFiscalWeek', 'CalendarFiscalYear',
   * 'Account', 'Channel', 'Contact', 'Customer', 'Language', 'Organization',
   * 'OrganizationUnit', 'Person', 'Product', 'ProductGroup',
   * 'LocationAddress', 'LocationAddressStreet', 'LocationCity',
   * 'LocationContinent', 'LocationCountry', 'LocationCounty',
   * 'LocationLatitude', 'LocationLongitude', 'LocationPoint',
   * 'LocationPostalCode', 'LocationProvince', 'LocationRegion',
   * 'LocationState', 'LocationTimezone', 'MeasurementDateCreation',
   * 'MeasurementDateModify', 'MeasurementStatus', 'MeasurementVersion',
   * 'BarCode', 'Brand', 'IdentityGovernmentID', 'PersonFirstName',
   * 'PersonFullName', 'PersonLastName', 'PersonMiddleName',
   * 'IdentityServiceEmail', 'IdentityServiceFacebook', 'IdentityServicePhone',
   * 'IdentityServiceTwitter', 'Image', 'Place', 'ReferenceDescription',
   * 'ReferenceImageURL', 'ReferencePhonetic', 'ReferenceURL'
   * @property {object}
   * [dataSourceEntity.incrementalAttribute.searchProperties]
   * @property {boolean}
   * [dataSourceEntity.incrementalAttribute.searchProperties.isSearchable] Gets
   * a value indicating whether the attribute supports full text search.
   * @property {boolean}
   * [dataSourceEntity.incrementalAttribute.searchProperties.isFilterable] Gets
   * a value indicating whether the attribute supports filtering.
   * @property {boolean}
   * [dataSourceEntity.incrementalAttribute.searchProperties.isFacetable] Gets
   * a value indicating whether the attribute can be included as facet results.
   * @property {boolean}
   * [dataSourceEntity.incrementalAttribute.searchProperties.isSortable] Gets a
   * value indicating whether the attribute can be included in orderby
   * directives.
   * @property {string}
   * [dataSourceEntity.incrementalAttribute.searchProperties.facetSpecification]
   * Gets an optional specification for search faceting used at query time
   * (advanced).
   * this is the part behind the comma in the examples below.
   * bucket facet: "price,interval:10"
   * other type: "listPrice,values:10|25|100|500|1000|2500"
   * value facet: city,count:5
   * @property {string} [dataSourceEntity.semanticType] Possible values
   * include: 'Account', 'AccountLeads', 'ActivityParty', 'ActivityPointer',
   * 'Annotation', 'Appointment', 'BusinessUnit', 'Campaign',
   * 'CampaignActivity', 'CampaignItem', 'CampaignResponse', 'Characteristic',
   * 'Competitor', 'CompetitorAddress', 'CompetitorProduct', 'Connection',
   * 'ConnectionRole', 'Contact', 'Contract', 'ContractDetail', 'Customer',
   * 'CustomerAddress', 'CustomerRelationship', 'Discount', 'DiscountType',
   * 'Email', 'Entitlement', 'Equipment', 'Fax', 'Feedback', 'Goal',
   * 'Incident', 'Invoice', 'InvoiceDetail', 'KbArticle', 'KnowledgeArticle',
   * 'Lead', 'LeadAddress', 'Letter', 'Metric', 'Opportunity', 'Organization',
   * 'Owner', 'PhoneCall', 'Position', 'PriceLevel', 'Product', 'Quote',
   * 'RatingModel', 'Resource', 'ResourceGroup', 'SalesLiterature',
   * 'SalesOrder', 'Service', 'ServiceAppointment', 'Site', 'SLA',
   * 'SocialActivity', 'SocialProfile', 'SystemUser', 'Task', 'Team',
   * 'Territory', 'UoM'
   * @property {date} [dataSourceEntity.refreshTime] Gets last refresh time for
   * entity.
   * @property {array} [dataSourceEntity.partitions] Gets entity data
   * partitions.
   * @property {array} [dataSourceEntity.incrementalUpsertPartitions] Gets
   * entity incremental upsert data partitions.
   * @property {array} [dataSourceEntity.incrementalDeletePartitions] Gets
   * entity incremental delete data partitions.
   * @property {array} [dataSourceEntity.fullPartitionsParquet] Gets entity
   * data parquet partitions.
   * @property {array} [dataSourceEntity.incrementalUpsertPartitionsParquet]
   * Gets entity incremental upsert data parquet partitions.
   * @property {array} [dataSourceEntity.incrementalDeletePartitionsParquet]
   * Gets entity incremental delete data parquet partitions.
   * @property {array} [dataSourceEntity.annotations] Gets base entity name
   * @property {array} [dataSourceMappingAttributes] List of data source
   * mapping attributes
   */
  constructor() {
  }

  /**
   * Defines the metadata of IRelationshipMetadata
   *
   * @returns {object} metadata of IRelationshipMetadata
   *
   */
  mapper() {
    return {
      required: false,
      serializedName: 'IRelationshipMetadata',
      type: {
        name: 'Composite',
        className: 'IRelationshipMetadata',
        modelProperties: {
          name: {
            required: false,
            serializedName: 'name',
            type: {
              name: 'String'
            }
          },
          friendlyName: {
            required: false,
            serializedName: 'friendlyName',
            type: {
              name: 'String'
            }
          },
          fromAttribute: {
            required: false,
            serializedName: 'fromAttribute',
            type: {
              name: 'Composite',
              className: 'IAttributeMetadata'
            }
          },
          toAttribute: {
            required: false,
            serializedName: 'toAttribute',
            type: {
              name: 'Composite',
              className: 'IAttributeMetadata'
            }
          },
          relationshipType: {
            required: false,
            serializedName: 'relationshipType',
            type: {
              name: 'String'
            }
          },
          dataSourceEntity: {
            required: false,
            serializedName: 'dataSourceEntity',
            type: {
              name: 'Composite',
              className: 'IEntityMetadata'
            }
          },
          dataSourceMappingAttributes: {
            required: false,
            serializedName: 'dataSourceMappingAttributes',
            type: {
              name: 'Sequence',
              element: {
                  required: false,
                  serializedName: 'IAttributeMetadataElementType',
                  type: {
                    name: 'Composite',
                    className: 'IAttributeMetadata'
                  }
              }
            }
          }
        }
      }
    };
  }
}

module.exports = IRelationshipMetadata;
